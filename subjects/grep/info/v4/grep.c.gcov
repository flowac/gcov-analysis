        -:    0:Source:grep.c
        -:    0:Graph:grep.gcno
        -:    0:Data:grep.gcda
        -:    0:Runs:809
        -:    1:/* grep.c - main driver file for grep.
        -:    2:   Copyright 1992, 1997-1999, 2000 Free Software Foundation, Inc.
        -:    3:
        -:    4:   This program is free software; you can redistribute it and/or modify
        -:    5:   it under the terms of the GNU General Public License as published by
        -:    6:   the Free Software Foundation; either version 2, or (at your option)
        -:    7:   any later version.
        -:    8:
        -:    9:   This program is distributed in the hope that it will be useful,
        -:   10:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   11:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   12:   GNU General Public License for more details.
        -:   13:
        -:   14:   You should have received a copy of the GNU General Public License
        -:   15:   along with this program; if not, write to the Free Software
        -:   16:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
        -:   17:   02111-1307, USA.  */
        -:   18:
        -:   19:/* Written July 1992 by Mike Haertel.  */
        -:   20:/********* I added follow from makefile in order to run cfe*********/
        -:   21:#define HAVE_CONFIG_H 1
        -:   22:#define LOCALEDIR "/nfs/spectre/u4/jin/research/experiments/grep/docs/grep_2.4.1/lib/locale"
        -:   23:/*#define _FILE_OFFSET_BITS 32 */  /** I change this line in config.h from 64 to 32 **/
        -:   24:
        -:   25:/*** end of added for cfe ****/ 
        -:   26:
        -:   27:#ifdef HAVE_CONFIG_H
        -:   28:# include <config.h>
        -:   29:#define flag_config 1
        -:   30:#endif
        -:   31:#include <sys/types.h>
        -:   32:#define flag_systypes 1
        -:   33:#include <sys/stat.h>
        -:   34:#if defined(HAVE_MMAP)
        -:   35:# include <sys/mman.h>
        -:   36:#endif
        -:   37:#if defined(HAVE_SETRLIMIT)
        -:   38:# include <sys/time.h>
        -:   39:# include <sys/resource.h>
        -:   40:#endif
        -:   41:#include <stdio.h>
        -:   42:
        -:   43:/*******IMPORTANT CHANGE for let stderr redirect to a file *******/
        -:   44:#undef stderr
        -:   45:#define stderr stdout
        -:   46:/******* FINISH IMPORTANT CHANGE *********/
        -:   47:
        -:   48:#include "system.h"
        -:   49:#include "getopt.h"
        -:   50:#include "getpagesize.h"
        -:   51:#include "grep.h"
        -:   52:#include "savedir.h"
        -:   53:
        -:   54:#undef MAX
        -:   55:#define MAX(A,B) ((A) > (B) ? (A) : (B))
        -:   56:
        -:   57:struct stats
        -:   58:{
        -:   59:  struct stats *parent;
        -:   60:  struct stat stat;
        -:   61:};
        -:   62:
        -:   63:/* base of chain of stat buffers, used to detect directory loops */
        -:   64:static struct stats stats_base;
        -:   65:
        -:   66:/* if non-zero, display usage information and exit */
        -:   67:static int show_help;
        -:   68:
        -:   69:/* If non-zero, print the version on standard output and exit.  */
        -:   70:static int show_version;
        -:   71:
        -:   72:/* If nonzero, use mmap if possible.  */
        -:   73:static int mmap_option;
        -:   74:
        -:   75:/* Short options.  */
        -:   76:static char const short_options[] =
        -:   77:"0123456789A:B:C::EFGHIUVX:abcd:e:f:hiLlnqrsuvwxyZz";
        -:   78:
        -:   79:/* Non-boolean long options that have no corresponding short equivalents.  */
        -:   80:enum
        -:   81:{
        -:   82:  BINARY_FILES_OPTION = CHAR_MAX + 1
        -:   83:};
        -:   84:
        -:   85:/* Long options equivalences. */
        -:   86:static struct option long_options[] =
        -:   87:{
        -:   88:  {"after-context", required_argument, NULL, 'A'},
        -:   89:  {"basic-regexp", no_argument, NULL, 'G'},
        -:   90:  {"before-context", required_argument, NULL, 'B'},
        -:   91:  {"binary-files", required_argument, NULL, BINARY_FILES_OPTION},
        -:   92:  {"byte-offset", no_argument, NULL, 'b'},
        -:   93:  {"context", optional_argument, NULL, 'C'},
        -:   94:  {"count", no_argument, NULL, 'c'},
        -:   95:  {"directories", required_argument, NULL, 'd'},
        -:   96:  {"extended-regexp", no_argument, NULL, 'E'},
        -:   97:  {"file", required_argument, NULL, 'f'},
        -:   98:  {"files-with-matches", no_argument, NULL, 'l'},
        -:   99:  {"files-without-match", no_argument, NULL, 'L'},
        -:  100:  {"fixed-regexp", no_argument, NULL, 'F'},
        -:  101:  {"fixed-strings", no_argument, NULL, 'F'},
        -:  102:  {"help", no_argument, &show_help, 1},
        -:  103:  {"ignore-case", no_argument, NULL, 'i'},
        -:  104:  {"line-number", no_argument, NULL, 'n'},
        -:  105:  {"line-regexp", no_argument, NULL, 'x'},
        -:  106:  {"mmap", no_argument, &mmap_option, 1},
        -:  107:  {"no-filename", no_argument, NULL, 'h'},
        -:  108:  {"no-messages", no_argument, NULL, 's'},
        -:  109:  {"null", no_argument, NULL, 'Z'},
        -:  110:  {"null-data", no_argument, NULL, 'z'},
        -:  111:  {"quiet", no_argument, NULL, 'q'},
        -:  112:  {"recursive", no_argument, NULL, 'r'},
        -:  113:  {"regexp", required_argument, NULL, 'e'},
        -:  114:  {"invert-match", no_argument, NULL, 'v'},
        -:  115:  {"silent", no_argument, NULL, 'q'},
        -:  116:  {"text", no_argument, NULL, 'a'},
        -:  117:  {"binary", no_argument, NULL, 'U'},
        -:  118:  {"unix-byte-offsets", no_argument, NULL, 'u'},
        -:  119:  {"version", no_argument, NULL, 'V'},
        -:  120:  {"with-filename", no_argument, NULL, 'H'},
        -:  121:  {"word-regexp", no_argument, NULL, 'w'},
        -:  122:  {0, 0, 0, 0}
        -:  123:};
        -:  124:
        -:  125:/* Define flags declared in grep.h. */
        -:  126:int match_icase;
        -:  127:int match_words;
        -:  128:int match_lines;
        -:  129:unsigned char eolbyte;
        -:  130:
        -:  131:/* For error messages. */
        -:  132:static char *prog;
        -:  133:static char const *filename;
        -:  134:static int errseen;
        -:  135:
        -:  136:/* How to handle directories.  */
        -:  137:static enum
        -:  138:  {
        -:  139:    READ_DIRECTORIES,
        -:  140:    RECURSE_DIRECTORIES,
        -:  141:    SKIP_DIRECTORIES
        -:  142:  } directories;
        -:  143:
        -:  144:static int  ck_atoi PARAMS ((char const *, int *));
        -:  145:static void usage PARAMS ((int)) __attribute__((noreturn));
        -:  146:static void error PARAMS ((const char *, int));
        -:  147:static void setmatcher PARAMS ((char const *));
        -:  148:static int  install_matcher PARAMS ((char const *));
        -:  149:static int  prepend_args PARAMS ((char const *, char *, char **));
        -:  150:static void prepend_default_options PARAMS ((char const *, int *, char ***));
        -:  151:static char *page_alloc PARAMS ((size_t, char **));
        -:  152:static int  reset PARAMS ((int, char const *, struct stats *));
        -:  153:static int  fillbuf PARAMS ((size_t, struct stats *));
        -:  154:static int  grepbuf PARAMS ((char *, char *));
        -:  155:static void prtext PARAMS ((char *, char *, int *));
        -:  156:static void prpending PARAMS ((char *));
        -:  157:static void prline PARAMS ((char *, char *, int));
        -:  158:static void print_offset_sep PARAMS ((off_t, int));
        -:  159:static void nlscan PARAMS ((char *));
        -:  160:static int  grep PARAMS ((int, char const *, struct stats *));
        -:  161:static int  grepdir PARAMS ((char const *, struct stats *));
        -:  162:static int  grepfile PARAMS ((char const *, struct stats *));
        -:  163:#if O_BINARY
        -:  164:static inline int undossify_input PARAMS ((register char *, size_t));
        -:  165:#endif
        -:  166:
        -:  167:/* Functions we'll use to search. */
        -:  168:static void (*compile) PARAMS ((char *, size_t));
        -:  169:static char *(*execute) PARAMS ((char *, size_t, char **));
        -:  170:
        -:  171:/* Print a message and possibly an error string.  Remember
        -:  172:   that something awful happened. */
        -:  173:static void
function error called 86 returned 100% blocks executed 100%
       86:  174:error (const char *mesg, int errnum)
        -:  175:{
       86:  176:  if (errnum)
branch  0 taken 21 (fallthrough)
branch  1 taken 65
       21:  177:    fprintf (stderr, "%s: %s: %s\n", prog, mesg, strerror (errnum));
call    0 returned 21
call    1 returned 21
        -:  178:  else
       65:  179:    fprintf (stderr, "%s: %s\n", prog, mesg);
call    0 returned 65
       86:  180:  errseen = 1;
       86:  181:}
        -:  182:
        -:  183:/* Like error (), but die horribly after printing. */
        -:  184:void
function fatal called 79 returned 0% blocks executed 100%
       79:  185:fatal (const char *mesg, int errnum)
        -:  186:{
       79:  187:  error (mesg, errnum);
call    0 returned 79
       79:  188:  exit (2);
        -:  189:}
        -:  190:
        -:  191:/* Interface to handle errors and fix library lossage. */
        -:  192:char *
function xmalloc called 2763 returned 100% blocks executed 80%
     2763:  193:xmalloc (size_t size)
        -:  194:{
        -:  195:  char *result;
        -:  196:
     2763:  197:  result = malloc (size);
     2763:  198:  if (size && !result)
branch  0 taken 2763 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 2763
    #####:  199:    fatal (_("memory exhausted"), 0);
call    0 never executed
     2763:  200:  return result;
        -:  201:}
        -:  202:
        -:  203:/* Interface to handle errors and fix some library lossage. */
        -:  204:char *
function xrealloc called 37 returned 100% blocks executed 88%
       37:  205:xrealloc (char *ptr, size_t size)
        -:  206:{
        -:  207:  char *result;
        -:  208:
       37:  209:  if (ptr)
branch  0 taken 28 (fallthrough)
branch  1 taken 9
       28:  210:    result = realloc (ptr, size);
        -:  211:  else
        9:  212:    result = malloc (size);
       37:  213:  if (size && !result)
branch  0 taken 37 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 37
    #####:  214:    fatal (_("memory exhausted"), 0);
call    0 never executed
       37:  215:  return result;
        -:  216:}
        -:  217:
        -:  218:/* Convert STR to a positive integer, storing the result in *OUT.
        -:  219:   If STR is not a valid integer, return -1 (otherwise 0). */
        -:  220:static int
function ck_atoi called 6 returned 100% blocks executed 100%
        6:  221:ck_atoi (char const *str, int *out)
        -:  222:{
        -:  223:  char const *p;
       10:  224:  for (p = str; *p; p++)
branch  0 taken 6
branch  1 taken 4 (fallthrough)
        6:  225:    if (*p < '0' || *p > '9')
branch  0 taken 4 (fallthrough)
branch  1 taken 2
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        2:  226:      return -1;
        -:  227:
        4:  228:  *out = atoi (optarg);
        4:  229:  return 0;
        -:  230:}
        -:  231:
        -:  232:
        -:  233:/* Hairy buffering mechanism for grep.  The intent is to keep
        -:  234:   all reads aligned on a page boundary and multiples of the
        -:  235:   page size. */
        -:  236:
        -:  237:static char *ubuffer;		/* Unaligned base of buffer. */
        -:  238:static char *buffer;		/* Base of buffer. */
        -:  239:static size_t bufsalloc;	/* Allocated size of buffer save region. */
        -:  240:static size_t bufalloc;		/* Total buffer size. */
        -:  241:#define PREFERRED_SAVE_FACTOR 5	/* Preferred value of bufalloc / bufsalloc.  */
        -:  242:static int bufdesc;		/* File descriptor. */
        -:  243:static char *bufbeg;		/* Beginning of user-visible stuff. */
        -:  244:static char *buflim;		/* Limit of user-visible stuff. */
        -:  245:static size_t pagesize;		/* alignment of memory pages */
        -:  246:static off_t bufoffset;		/* Read offset; defined on regular files.  */
        -:  247:
        -:  248:#if defined(HAVE_MMAP)
        -:  249:static int bufmapped;		/* True if buffer is memory-mapped.  */
        -:  250:static off_t initial_bufoffset;	/* Initial value of bufoffset. */
        -:  251:#endif
        -:  252:
        -:  253:/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be
        -:  254:   an integer or a pointer.  Both args must be free of side effects.  */
        -:  255:#define ALIGN_TO(val, alignment) \
        -:  256:  ((size_t) (val) % (alignment) == 0 \
        -:  257:   ? (val) \
        -:  258:   : (val) + ((alignment) - (size_t) (val) % (alignment)))
        -:  259:
        -:  260:/* Return the address of a page-aligned buffer of size SIZE,
        -:  261:   reallocating it from *UP.  Set *UP to the newly allocated (but
        -:  262:   possibly unaligned) buffer used to build the aligned buffer.  To
        -:  263:   free the buffer, free (*UP).  */
        -:  264:static char *
function page_alloc called 720 returned 100% blocks executed 73%
      720:  265:page_alloc (size_t size, char **up)
        -:  266:{
      720:  267:  size_t asize = size + pagesize - 1;
      720:  268:  if (size <= asize)
branch  0 taken 720 (fallthrough)
branch  1 taken 0
        -:  269:    {
     720*:  270:      char *p = *up ? realloc (*up, asize) : malloc (asize);
branch  0 taken 0 (fallthrough)
branch  1 taken 720
      720:  271:      if (p)
branch  0 taken 720 (fallthrough)
branch  1 taken 0
        -:  272:	{
      720:  273:	  *up = p;
     720*:  274:	  return ALIGN_TO (p, pagesize);
branch  0 taken 720 (fallthrough)
branch  1 taken 0
        -:  275:	}
        -:  276:    }
    #####:  277:  return NULL;
        -:  278:}
        -:  279:
        -:  280:/* Reset the buffer for a new file, returning zero if we should skip it.
        -:  281:   Initialize on the first time through. */
        -:  282:static int
function reset called 1696 returned 100% blocks executed 66%
     1696:  283:reset (int fd, char const *file, struct stats *stats)
        -:  284:{
     1696:  285:  if (pagesize)
branch  0 taken 976 (fallthrough)
branch  1 taken 720
     976*:  286:    bufsalloc = ALIGN_TO (bufalloc / PREFERRED_SAVE_FACTOR, pagesize);
branch  0 taken 976 (fallthrough)
branch  1 taken 0
        -:  287:  else
        -:  288:    {
        -:  289:      size_t ubufsalloc;
      720:  290:      pagesize = getpagesize ();
      720:  291:      if (pagesize == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 720
    #####:  292:	abort ();
call    0 never executed
        -:  293:#ifndef BUFSALLOC
      720:  294:      ubufsalloc = MAX (8192, pagesize);
        -:  295:#else
        -:  296:      ubufsalloc = BUFSALLOC;
        -:  297:#endif
     720*:  298:      bufsalloc = ALIGN_TO (ubufsalloc, pagesize);
branch  0 taken 0 (fallthrough)
branch  1 taken 720
      720:  299:      bufalloc = PREFERRED_SAVE_FACTOR * bufsalloc;
        -:  300:      /* The 1 byte of overflow is a kludge for dfaexec(), which
        -:  301:	 inserts a sentinel newline at the end of the buffer
        -:  302:	 being searched.  There's gotta be a better way... */
      720:  303:      if (bufsalloc < ubufsalloc
branch  0 taken 720 (fallthrough)
branch  1 taken 0
      720:  304:	  || bufalloc / PREFERRED_SAVE_FACTOR != bufsalloc
branch  0 taken 720 (fallthrough)
branch  1 taken 0
      720:  305:	  || bufalloc + 1 < bufalloc
branch  0 taken 720 (fallthrough)
branch  1 taken 0
      720:  306:	  || ! (buffer = page_alloc (bufalloc + 1, &ubuffer)))
call    0 returned 720
branch  1 taken 0 (fallthrough)
branch  2 taken 720
    #####:  307:	fatal (_("memory exhausted"), 0);
call    0 never executed
        -:  308:    }
        -:  309:
     1696:  310:  buflim = buffer;
     1696:  311:  bufdesc = fd;
        -:  312:
     1696:  313:  if (fstat (fd, &stats->stat) != 0)
call    0 returned 1696
branch  1 taken 0 (fallthrough)
branch  2 taken 1696
        -:  314:    {
    #####:  315:      error ("fstat", errno);
call    0 never executed
    #####:  316:      return 0;
        -:  317:    }
    1696*:  318:  if (directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
branch  0 taken 0 (fallthrough)
branch  1 taken 1696
branch  2 never executed
branch  3 never executed
    #####:  319:    return 0;
     1696:  320:  if (S_ISREG (stats->stat.st_mode))
branch  0 taken 1696 (fallthrough)
branch  1 taken 0
        -:  321:    {
     1696:  322:      if (file)
branch  0 taken 1687 (fallthrough)
branch  1 taken 9
     1687:  323:	bufoffset = 0;
        -:  324:      else
        -:  325:	{
        9:  326:	  bufoffset = lseek (fd, 0, SEEK_CUR);
call    0 returned 9
        9:  327:	  if (bufoffset < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
        -:  328:	    {
    #####:  329:	      error ("lseek", errno);
call    0 never executed
    #####:  330:	      return 0;
        -:  331:	    }
        -:  332:	}
        -:  333:#ifdef HAVE_MMAP
     1696:  334:      initial_bufoffset = bufoffset;
    1696*:  335:      bufmapped = mmap_option && bufoffset % pagesize == 0;
branch  0 taken 0 (fallthrough)
branch  1 taken 1696
branch  2 never executed
branch  3 never executed
        -:  336:#endif
        -:  337:    }
        -:  338:  else
        -:  339:    {
        -:  340:#ifdef HAVE_MMAP
    #####:  341:      bufmapped = 0;
        -:  342:#endif
        -:  343:    }
     1696:  344:  return 1;
        -:  345:}
        -:  346:
        -:  347:/* Read new stuff into the buffer, saving the specified
        -:  348:   amount of old stuff.  When we're done, 'bufbeg' points
        -:  349:   to the beginning of the buffer contents, and 'buflim'
        -:  350:   points just after the end.  Return zero if there's an error.  */
        -:  351:static int
function fillbuf called 9127 returned 100% blocks executed 21%
     9127:  352:fillbuf (size_t save, struct stats *stats)
        -:  353:{
     9127:  354:  size_t fillsize = 0;
     9127:  355:  int cc = 1;
        -:  356:  size_t readsize;
        -:  357:
        -:  358:  /* Offset from start of unaligned buffer to start of old stuff
        -:  359:     that we want to save.  */
     9127:  360:  size_t saved_offset = buflim - ubuffer - save;
        -:  361:
     9127:  362:  if (bufsalloc < save)
branch  0 taken 0 (fallthrough)
branch  1 taken 9127
        -:  363:    {
    #####:  364:      size_t aligned_save = ALIGN_TO (save, pagesize);
branch  0 never executed
branch  1 never executed
    #####:  365:      size_t maxalloc = (size_t) -1;
        -:  366:      size_t newalloc;
        -:  367:
    #####:  368:      if (S_ISREG (stats->stat.st_mode))
branch  0 never executed
branch  1 never executed
        -:  369:	{
        -:  370:	  /* Calculate an upper bound on how much memory we should allocate.
        -:  371:	     We can't use ALIGN_TO here, since off_t might be longer than
        -:  372:	     size_t.  Watch out for arithmetic overflow.  */
    #####:  373:	  off_t to_be_read = stats->stat.st_size - bufoffset;
    #####:  374:	  size_t slop = to_be_read % pagesize;
    #####:  375:	  off_t aligned_to_be_read = to_be_read + (slop ? pagesize - slop : 0);
branch  0 never executed
branch  1 never executed
    #####:  376:	  off_t maxalloc_off = aligned_save + aligned_to_be_read;
    #####:  377:	  if (0 <= maxalloc_off && maxalloc_off == (size_t) maxalloc_off)
branch  0 never executed
branch  1 never executed
    #####:  378:	    maxalloc = maxalloc_off;
        -:  379:	}
        -:  380:
        -:  381:      /* Grow bufsalloc until it is at least as great as `save'; but
        -:  382:	 if there is an overflow, just grow it to the next page boundary.  */
    #####:  383:      while (bufsalloc < save)
branch  0 never executed
branch  1 never executed
    #####:  384:	if (bufsalloc < bufsalloc * 2)
branch  0 never executed
branch  1 never executed
    #####:  385:	  bufsalloc *= 2;
        -:  386:	else
        -:  387:	  {
    #####:  388:	    bufsalloc = aligned_save;
    #####:  389:	    break;
        -:  390:	  }
        -:  391:
        -:  392:      /* Grow the buffer size to be PREFERRED_SAVE_FACTOR times
        -:  393:	 bufsalloc....  */
    #####:  394:      newalloc = PREFERRED_SAVE_FACTOR * bufsalloc;
    #####:  395:      if (maxalloc < newalloc)
branch  0 never executed
branch  1 never executed
        -:  396:	{
        -:  397:	  /* ... except don't grow it more than a pagesize past the
        -:  398:	     file size, as that might cause unnecessary memory
        -:  399:	     exhaustion if the file is large.  */
    #####:  400:	  newalloc = maxalloc;
    #####:  401:	  bufsalloc = aligned_save;
        -:  402:	}
        -:  403:
        -:  404:      /* Check that the above calculations made progress, which might
        -:  405:         not occur if there is arithmetic overflow.  If there's no
        -:  406:	 progress, or if the new buffer size is larger than the old
        -:  407:	 and buffer reallocation fails, report memory exhaustion.  */
    #####:  408:      if (bufsalloc < save || newalloc < save
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  409:	  || (newalloc == save && newalloc != maxalloc)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  410:	  || (bufalloc < newalloc
branch  0 never executed
branch  1 never executed
    #####:  411:	      && ! (buffer
    #####:  412:		    = page_alloc ((bufalloc = newalloc) + 1, &ubuffer))))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  413:	fatal (_("memory exhausted"), 0);
call    0 never executed
        -:  414:    }
        -:  415:
     9127:  416:  bufbeg = buffer + bufsalloc - save;
     9127:  417:  memmove (bufbeg, ubuffer + saved_offset, save);
     9127:  418:  readsize = bufalloc - bufsalloc;
        -:  419:
        -:  420:#if defined(HAVE_MMAP)
     9127:  421:  if (bufmapped)
branch  0 taken 0 (fallthrough)
branch  1 taken 9127
        -:  422:    {
    #####:  423:      size_t mmapsize = readsize;
        -:  424:
        -:  425:      /* Don't mmap past the end of the file; some hosts don't allow this.
        -:  426:	 Use `read' on the last page.  */
    #####:  427:      if (stats->stat.st_size - bufoffset < mmapsize)
branch  0 never executed
branch  1 never executed
        -:  428:	{
    #####:  429:	  mmapsize = stats->stat.st_size - bufoffset;
    #####:  430:	  mmapsize -= mmapsize % pagesize;
        -:  431:	}
        -:  432:
    #####:  433:      if (mmapsize
branch  0 never executed
branch  1 never executed
    #####:  434:	  && (mmap ((caddr_t) (buffer + bufsalloc), mmapsize,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  435:		    PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_FIXED,
        -:  436:		    bufdesc, bufoffset)
        -:  437:	      != (caddr_t) -1))
        -:  438:	{
        -:  439:	  /* Do not bother to use madvise with MADV_SEQUENTIAL or
        -:  440:	     MADV_WILLNEED on the mmapped memory.  One might think it
        -:  441:	     would help, but it slows us down about 30% on SunOS 4.1.  */
    #####:  442:	  fillsize = mmapsize;
        -:  443:	}
        -:  444:      else
        -:  445:	{
        -:  446:	  /* Stop using mmap on this file.  Synchronize the file
        -:  447:	     offset.  Do not warn about mmap failures.  On some hosts
        -:  448:	     (e.g. Solaris 2.5) mmap can fail merely because some
        -:  449:	     other process has an advisory read lock on the file.
        -:  450:	     There's no point alarming the user about this misfeature.  */
    #####:  451:	  bufmapped = 0;
    #####:  452:	  if (bufoffset != initial_bufoffset
branch  0 never executed
branch  1 never executed
    #####:  453:	      && lseek (bufdesc, bufoffset, SEEK_SET) < 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  454:	    {
    #####:  455:	      error ("lseek", errno);
call    0 never executed
    #####:  456:	      cc = 0;
        -:  457:	    }
        -:  458:	}
        -:  459:    }
        -:  460:#endif /*HAVE_MMAP*/
        -:  461:
     9127:  462:  if (! fillsize)
branch  0 taken 9127 (fallthrough)
branch  1 taken 0
    #####:  463:    {
        -:  464:      ssize_t bytesread;
     9127:  465:      while ((bytesread = read (bufdesc, buffer + bufsalloc, readsize)) < 0
call    0 returned 9127
    9127*:  466:	     && errno == EINTR)
branch  0 taken 0 (fallthrough)
branch  1 taken 9127
branch  2 never executed
branch  3 never executed
    #####:  467:	continue;
     9127:  468:      if (bytesread < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 9127
    #####:  469:	cc = 0;
        -:  470:      else
     9127:  471:	fillsize = bytesread;
        -:  472:    }
        -:  473:
     9127:  474:  bufoffset += fillsize;
        -:  475:#if O_BINARY
        -:  476:  if (fillsize)
        -:  477:    fillsize = undossify_input (buffer + bufsalloc, fillsize);
        -:  478:#endif
     9127:  479:  buflim = buffer + bufsalloc + fillsize;
     9127:  480:  return cc;
        -:  481:}
        -:  482:
        -:  483:/* Flags controlling the style of output. */
        -:  484:static enum
        -:  485:  {
        -:  486:    BINARY_BINARY_FILES,
        -:  487:    TEXT_BINARY_FILES,
        -:  488:    WITHOUT_MATCH_BINARY_FILES
        -:  489:  } binary_files;		/* How to handle binary files.  */
        -:  490:static int filename_mask;	/* If zero, output nulls after filenames.  */
        -:  491:static int out_quiet;		/* Suppress all normal output. */
        -:  492:static int out_invert;		/* Print nonmatching stuff. */
        -:  493:static int out_file;		/* Print filenames. */
        -:  494:static int out_line;		/* Print line numbers. */
        -:  495:static int out_byte;		/* Print byte offsets. */
        -:  496:static int out_before;		/* Lines of leading context. */
        -:  497:static int out_after;		/* Lines of trailing context. */
        -:  498:static int count_matches;	/* Count matching lines.  */
        -:  499:static int list_files;		/* List matching files.  */
        -:  500:static int no_filenames;	/* Suppress file names.  */
        -:  501:static int suppress_errors;	/* Suppress diagnostics.  */
        -:  502:
        -:  503:/* Internal variables to keep track of byte count, context, etc. */
        -:  504:static off_t totalcc;		/* Total character count before bufbeg. */
        -:  505:static char *lastnl;		/* Pointer after last newline counted. */
        -:  506:static char *lastout;		/* Pointer after last character output;
        -:  507:				   NULL if no character has been output
        -:  508:				   or if it's conceptually before bufbeg. */
        -:  509:static off_t totalnl;		/* Total newline count before lastnl. */
        -:  510:static int pending;		/* Pending lines of output. */
        -:  511:static int done_on_match;		/* Stop scanning file on first match */
        -:  512:
        -:  513:#if O_BINARY
        -:  514:# include "dosbuf.c"
        -:  515:#endif
        -:  516:
        -:  517:static void
function nlscan called 200659 returned 100% blocks executed 100%
   200659:  518:nlscan (char *lim)
        -:  519:{
        -:  520:  char *beg;
   417243:  521:  for (beg = lastnl;  (beg = memchr (beg, eolbyte, lim - beg));  beg++)
branch  0 taken 216584
branch  1 taken 200659 (fallthrough)
   216584:  522:    totalnl++;
   200659:  523:  lastnl = lim;
   200659:  524:}
        -:  525:
        -:  526:static void
function print_offset_sep called 397777 returned 100% blocks executed 100%
   397777:  527:print_offset_sep (off_t pos, int sep)
        -:  528:{
        -:  529:  /* Do not rely on printf to print pos, since off_t may be longer than long,
        -:  530:     and long long is not portable.  */
        -:  531:
        -:  532:  char buf[sizeof pos * CHAR_BIT];
   397777:  533:  char *p = buf + sizeof buf - 1;
   397777:  534:  *p = sep;
        -:  535:
        -:  536:  do
  1911863:  537:    *--p = '0' + pos % 10;
  1911863:  538:  while ((pos /= 10) != 0);
branch  0 taken 1514086
branch  1 taken 397777 (fallthrough)
        -:  539:
   397777:  540:  fwrite (p, 1, buf + sizeof buf - p, stdout);
call    0 returned 397777
   397777:  541:}
        -:  542:
        -:  543:static void
function prline called 834203 returned 100% blocks executed 92%
   834203:  544:prline (char *beg, char *lim, int sep)
        -:  545:{
   834203:  546:  if (out_file)
branch  0 taken 162037 (fallthrough)
branch  1 taken 672166
   162037:  547:    printf ("%s%c", filename, sep & filename_mask);
call    0 returned 162037
   834203:  548:  if (out_line)
branch  0 taken 200262 (fallthrough)
branch  1 taken 633941
        -:  549:    {
   200262:  550:      nlscan (beg);
call    0 returned 200262
   200262:  551:      print_offset_sep (++totalnl, sep);
call    0 returned 200262
   200262:  552:      lastnl = lim;
        -:  553:    }
   834203:  554:  if (out_byte)
branch  0 taken 197515 (fallthrough)
branch  1 taken 636688
        -:  555:    {
   197515:  556:      off_t pos = totalcc + (beg - bufbeg);
        -:  557:#if O_BINARY
        -:  558:      pos = dossified_pos (pos);
        -:  559:#endif
   197515:  560:      print_offset_sep (pos, sep);
call    0 returned 197515
        -:  561:    }
   834203:  562:  fwrite (beg, 1, lim - beg, stdout);
call    0 returned 834203
   834203:  563:  if (ferror (stdout))
call    0 returned 834203
branch  1 taken 0 (fallthrough)
branch  2 taken 834203
    #####:  564:    error (_("writing output"), errno);
call    0 never executed
   834203:  565:  lastout = lim;
   834203:  566:}
        -:  567:
        -:  568:/* Print pending lines of trailing context prior to LIM. */
        -:  569:static void
function prpending called 2625 returned 100% blocks executed 80%
     2625:  570:prpending (char *lim)
        -:  571:{
        -:  572:  char *nl;
        -:  573:
     2625:  574:  if (!lastout)
branch  0 taken 0 (fallthrough)
branch  1 taken 2625
    #####:  575:    lastout = bufbeg;
    10807:  576:  while (pending > 0 && lastout < lim)
branch  0 taken 9066 (fallthrough)
branch  1 taken 1741
branch  2 taken 8182
branch  3 taken 884 (fallthrough)
        -:  577:    {
     8182:  578:      --pending;
     8182:  579:      if ((nl = memchr (lastout, eolbyte, lim - lastout)) != 0)
branch  0 taken 8182 (fallthrough)
branch  1 taken 0
     8182:  580:	++nl;
        -:  581:      else
    #####:  582:	nl = lim;
     8182:  583:      prline (lastout, nl, '-');
call    0 returned 8182
        -:  584:    }
     2625:  585:}
        -:  586:
        -:  587:/* Print the lines between BEG and LIM.  Deal with context crap.
        -:  588:   If NLINESP is non-null, store a count of lines between BEG and LIM. */
        -:  589:static void
function prtext called 552938 returned 100% blocks executed 97%
   552938:  590:prtext (char *beg, char *lim, int *nlinesp)
        -:  591:{
        -:  592:  static int used;		/* avoid printing "--" before any output */
        -:  593:  char *bp, *p, *nl;
   552938:  594:  char eol = eolbyte;
        -:  595:  int i, n;
        -:  596:
   552938:  597:  if (!out_quiet && pending > 0)
branch  0 taken 474478 (fallthrough)
branch  1 taken 78460
branch  2 taken 2544 (fallthrough)
branch  3 taken 471934
     2544:  598:    prpending (beg);
call    0 returned 2544
        -:  599:
   552938:  600:  p = beg;
        -:  601:
   552938:  602:  if (!out_quiet)
branch  0 taken 474478 (fallthrough)
branch  1 taken 78460
        -:  603:    {
        -:  604:      /* Deal with leading context crap. */
        -:  605:
   474478:  606:      bp = lastout ? lastout : bufbeg;
branch  0 taken 471881 (fallthrough)
branch  1 taken 2597
   485146:  607:      for (i = 0; i < out_before; ++i)
branch  0 taken 10668
branch  1 taken 474478 (fallthrough)
    10668:  608:	if (p > bp)
branch  0 taken 5207 (fallthrough)
branch  1 taken 5461
        -:  609:	  do
   140669:  610:	    --p;
   140669:  611:	  while (p > bp && p[-1] != eol);
branch  0 taken 140302 (fallthrough)
branch  1 taken 367
branch  2 taken 135462
branch  3 taken 4840 (fallthrough)
        -:  612:
        -:  613:      /* We only print the "--" separator if our output is
        -:  614:	 discontiguous from the last output in the file. */
   474478:  615:      if ((out_before || out_after) && used && p != lastout)
branch  0 taken 471864 (fallthrough)
branch  1 taken 2614
branch  2 taken 260 (fallthrough)
branch  3 taken 471604
branch  4 taken 2857 (fallthrough)
branch  5 taken 17
branch  6 taken 1470 (fallthrough)
branch  7 taken 1387
     1470:  616:	puts ("--");
call    0 returned 1470
        -:  617:
   479685:  618:      while (p < beg)
branch  0 taken 5207
branch  1 taken 474478 (fallthrough)
        -:  619:	{
     5207:  620:	  nl = memchr (p, eol, beg - p);
     5207:  621:	  prline (p, nl + 1, '-');
call    0 returned 5207
     5207:  622:	  p = nl + 1;
        -:  623:	}
        -:  624:    }
        -:  625:
   552938:  626:  if (nlinesp)
branch  0 taken 3217 (fallthrough)
branch  1 taken 549721
        -:  627:    {
        -:  628:      /* Caller wants a line count. */
   487952:  629:      for (n = 0; p < lim; ++n)
branch  0 taken 484735
branch  1 taken 3217 (fallthrough)
        -:  630:	{
   484735:  631:	  if ((nl = memchr (p, eol, lim - p)) != 0)
branch  0 taken 484735 (fallthrough)
branch  1 taken 0
   484735:  632:	    ++nl;
        -:  633:	  else
    #####:  634:	    nl = lim;
   484735:  635:	  if (!out_quiet)
branch  0 taken 348688 (fallthrough)
branch  1 taken 136047
   348688:  636:	    prline (p, nl, ':');
call    0 returned 348688
   484735:  637:	  p = nl;
        -:  638:	}
     3217:  639:      *nlinesp = n;
        -:  640:    }
        -:  641:  else
   549721:  642:    if (!out_quiet)
branch  0 taken 472126 (fallthrough)
branch  1 taken 77595
   472126:  643:      prline (beg, lim, ':');
call    0 returned 472126
        -:  644:
   552938:  645:  pending = out_quiet ? 0 : out_after;
branch  0 taken 474478 (fallthrough)
branch  1 taken 78460
   552938:  646:  used = 1;
   552938:  647:}
        -:  648:
        -:  649:/* Scan the specified portion of the buffer, matching lines (or
        -:  650:   between matching lines if OUT_INVERT is true).  Return a count of
        -:  651:   lines printed. */
        -:  652:static int
function grepbuf called 8639 returned 100% blocks executed 86%
     8639:  653:grepbuf (char *beg, char *lim)
        -:  654:{
        -:  655:  int nlines, n;
        -:  656:  register char *p, *b;
        -:  657:  char *endp;
     8639:  658:  char eol = eolbyte;
        -:  659:
     8639:  660:  nlines = 0;
     8639:  661:  p = beg;
   561562:  662:  while ((b = (*execute)(p, lim - p, &endp)) != 0)
call    0 returned 561562
branch  1 taken 552942
branch  2 taken 8620 (fallthrough)
        -:  663:    {
        -:  664:      /* Avoid matching the empty line at the end of the buffer. */
  552942*:  665:      if (b == lim && ((b > beg && b[-1] == eol) || b == beg))
branch  0 taken 0 (fallthrough)
branch  1 taken 552942
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:  666:	break;
   552942:  667:      if (!out_invert)
branch  0 taken 549721 (fallthrough)
branch  1 taken 3221
        -:  668:	{
   549721:  669:	  prtext (b, endp, (int *) 0);
call    0 returned 549721
   549721:  670:	  nlines += 1;
   549721:  671:	  if (done_on_match)
branch  0 taken 19 (fallthrough)
branch  1 taken 549702
       19:  672:	    return nlines;
        -:  673:	}
     3221:  674:      else if (p < b)
branch  0 taken 2658 (fallthrough)
branch  1 taken 563
        -:  675:	{
     2658:  676:	  prtext (p, b, &n);
call    0 returned 2658
     2658:  677:	  nlines += n;
        -:  678:	}
   552923:  679:      p = endp;
        -:  680:    }
     8620:  681:  if (out_invert && p < lim)
branch  0 taken 560 (fallthrough)
branch  1 taken 8060
branch  2 taken 559 (fallthrough)
branch  3 taken 1
        -:  682:    {
      559:  683:      prtext (p, lim, &n);
call    0 returned 559
      559:  684:      nlines += n;
        -:  685:    }
     8620:  686:  return nlines;
        -:  687:}
        -:  688:
        -:  689:/* Search a given file.  Normally, return a count of lines printed;
        -:  690:   but if the file is a directory and we search it recursively, then
        -:  691:   return -2 if there was a match, and -1 otherwise.  */
        -:  692:static int
function grep called 1696 returned 100% blocks executed 77%
     1696:  693:grep (int fd, char const *file, struct stats *stats)
        -:  694:{
        -:  695:  int nlines, i;
        -:  696:  int not_text;
        -:  697:  size_t residue, save;
        -:  698:  char *beg, *lim;
     1696:  699:  char eol = eolbyte;
        -:  700:
     1696:  701:  if (!reset (fd, file, stats))
call    0 returned 1696
branch  1 taken 0 (fallthrough)
branch  2 taken 1696
    #####:  702:    return 0;
        -:  703:
     1696:  704:  if (file && directories == RECURSE_DIRECTORIES
branch  0 taken 1687 (fallthrough)
branch  1 taken 9
branch  2 taken 0 (fallthrough)
branch  3 taken 1687
    #####:  705:      && S_ISDIR (stats->stat.st_mode))
branch  0 never executed
branch  1 never executed
        -:  706:    {
        -:  707:      /* Close fd now, so that we don't open a lot of file descriptors
        -:  708:	 when we recurse deeply.  */
    #####:  709:      if (close (fd) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  710:	error (file, errno);
call    0 never executed
    #####:  711:      return grepdir (file, stats) - 2;
call    0 never executed
        -:  712:    }
        -:  713:
     1696:  714:  totalcc = 0;
     1696:  715:  lastout = 0;
     1696:  716:  totalnl = 0;
     1696:  717:  pending = 0;
        -:  718:
     1696:  719:  nlines = 0;
     1696:  720:  residue = 0;
     1696:  721:  save = 0;
        -:  722:
     1696:  723:  if (! fillbuf (save, stats))
call    0 returned 1696
branch  1 taken 0 (fallthrough)
branch  2 taken 1696
        -:  724:    {
    #####:  725:      if (! (is_EISDIR (errno, file) && suppress_errors))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  726:	error (filename, errno);
call    0 never executed
    #####:  727:      return 0;
        -:  728:    }
        -:  729:
        -:  730:#ifndef FAULTY_F_KP_5
     1696:  731:  not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)
branch  0 taken 124 (fallthrough)
branch  1 taken 1572
      124:  732:	       || binary_files == WITHOUT_MATCH_BINARY_FILES)
branch  0 taken 0 (fallthrough)
branch  1 taken 124
        -:  733:#else
        -:  734:  not_text = ((binary_files == WITHOUT_MATCH_BINARY_FILES || !out_quiet)
        -:  735:#endif
    3392*:  736:	      && memchr (bufbeg, eol ? '\0' : '\200', buflim - bufbeg));
branch  0 taken 1696 (fallthrough)
branch  1 taken 0
branch  2 taken 1572 (fallthrough)
branch  3 taken 0
branch  4 taken 16 (fallthrough)
branch  5 taken 1556
        -:  737:  #ifndef FAULTY_F_DG_4
     1696:  738:  if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)
branch  0 taken 16 (fallthrough)
branch  1 taken 1680
branch  2 taken 0 (fallthrough)
branch  3 taken 16
    #####:  739:    return 0;
        -:  740:  #else
        -:  741:	/* Nothing here because the fault is only a code removal */
        -:  742:  #endif
     1696:  743:  done_on_match += not_text;
     1696:  744:  out_quiet += not_text;
        -:  745:
        -:  746:  for (;;)
        -:  747:    {
     9127:  748:      lastnl = bufbeg;
     9127:  749:      if (lastout)
branch  0 taken 796 (fallthrough)
branch  1 taken 8331
      796:  750:	lastout = bufbeg;
     9127:  751:      if (buflim - bufbeg == save)
branch  0 taken 1677 (fallthrough)
branch  1 taken 7450
     1677:  752:	break;
     7450:  753:      beg = bufbeg + save - residue;
   257206:  754:      for (lim = buflim; lim > beg && lim[-1] != eol; --lim)
branch  0 taken 257206 (fallthrough)
branch  1 taken 0
branch  2 taken 249756
branch  3 taken 7450 (fallthrough)
        -:  755:	;
     7450:  756:      residue = buflim - lim;
     7450:  757:      if (beg < lim)
branch  0 taken 7450 (fallthrough)
branch  1 taken 0
        -:  758:	{
     7450:  759:	  nlines += grepbuf (beg, lim);
call    0 returned 7450
     7450:  760:	  if (pending)
branch  0 taken 80 (fallthrough)
branch  1 taken 7370
       80:  761:	    prpending (lim);
call    0 returned 80
     7450:  762:	  if (nlines && done_on_match && !out_invert)
branch  0 taken 4800 (fallthrough)
branch  1 taken 2650
branch  2 taken 127 (fallthrough)
branch  3 taken 4673
branch  4 taken 19 (fallthrough)
branch  5 taken 108
       19:  763:	    goto finish_grep;
        -:  764:	}
     7431:  765:      i = 0;
     7431:  766:      beg = lim;
     8071:  767:      while (i < out_before && beg > bufbeg && beg != lastout)
branch  0 taken 657 (fallthrough)
branch  1 taken 7414
branch  2 taken 657 (fallthrough)
branch  3 taken 0
branch  4 taken 640
branch  5 taken 17 (fallthrough)
        -:  768:	{
      640:  769:	  ++i;
        -:  770:	  do
    18191:  771:	    --beg;
    18191:  772:	  while (beg > bufbeg && beg[-1] != eol);
branch  0 taken 18191 (fallthrough)
branch  1 taken 0
branch  2 taken 17551
branch  3 taken 640 (fallthrough)
        -:  773:	}
     7431:  774:      if (beg != lastout)
branch  0 taken 6635 (fallthrough)
branch  1 taken 796
     6635:  775:	lastout = 0;
     7431:  776:      save = residue + lim - beg;
     7431:  777:      totalcc += buflim - bufbeg - save;
     7431:  778:      if (out_line)
branch  0 taken 397 (fallthrough)
branch  1 taken 7034
      397:  779:	nlscan (beg);
call    0 returned 397
     7431:  780:      if (! fillbuf (save, stats))
call    0 returned 7431
branch  1 taken 0 (fallthrough)
branch  2 taken 7431
        -:  781:	{
    #####:  782:	  if (! (is_EISDIR (errno, file) && suppress_errors))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:  783:	    error (filename, errno);
call    0 never executed
    #####:  784:	  goto finish_grep;
        -:  785:	}
        -:  786:    }
     1677:  787:  if (residue)
branch  0 taken 488 (fallthrough)
branch  1 taken 1189
        -:  788:    {
     1189:  789:      *buflim++ = eol;
     1189:  790:      nlines += grepbuf (bufbeg + save - residue, buflim);
call    0 returned 1189
     1189:  791:      if (pending)
branch  0 taken 1188 (fallthrough)
branch  1 taken 1
        1:  792:	prpending (buflim);
call    0 returned 1
        -:  793:    }
        -:  794:
     1676:  795: finish_grep:
     1696:  796:  done_on_match -= not_text;
     1696:  797:  out_quiet -= not_text;
     1696:  798:  if ((not_text & ~out_quiet) && nlines != 0)
branch  0 taken 16 (fallthrough)
branch  1 taken 1680
branch  2 taken 8 (fallthrough)
branch  3 taken 8
        8:  799:    printf (_("Binary file %s matches\n"), filename);
call    0 returned 8
     1696:  800:  return nlines;
        -:  801:}
        -:  802:
        -:  803:static int
function grepfile called 1704 returned 100% blocks executed 59%
     1704:  804:grepfile (char const *file, struct stats *stats)
        -:  805:{
        -:  806:  int desc;
        -:  807:  int count;
        -:  808:  int status;
        -:  809:
    1704*:  810:  if (! file)
branch  0 taken 9 (fallthrough)
branch  1 taken 1695
        -:  811:    {
        9:  812:      desc = 0;
        9:  813:      filename = _("(standard input)");
        -:  814:    }
        -:  815:  else
        -:  816:    {
     1695:  817:      while ((desc = open (file, O_RDONLY)) < 0 && errno == EINTR)
call    0 returned 1695
branch  1 taken 8 (fallthrough)
branch  2 taken 1687
branch  3 taken 0
branch  4 taken 8 (fallthrough)
    #####:  818:	continue;
        -:  819:
     1695:  820:      if (desc < 0)
branch  0 taken 8 (fallthrough)
branch  1 taken 1687
        -:  821:	{
        8:  822:	  int e = errno;
        -:  823:	    
       8*:  824:	  if (is_EISDIR (e, file) && directories == RECURSE_DIRECTORIES)
branch  0 taken 0 (fallthrough)
branch  1 taken 8
branch  2 never executed
branch  3 never executed
        -:  825:	    {
    #####:  826:	      if (stat (file, &stats->stat) != 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:  827:		{
    #####:  828:		  error (file, errno);
call    0 never executed
    #####:  829:		  return 1;
        -:  830:		}
        -:  831:
    #####:  832:	      return grepdir (file, stats);
call    0 never executed
        -:  833:	    }
        -:  834:	      
        8:  835:	  if (!suppress_errors)
branch  0 taken 7 (fallthrough)
branch  1 taken 1
        -:  836:	    {
        7:  837:	      if (directories == SKIP_DIRECTORIES)
branch  0 taken 0 (fallthrough)
branch  1 taken 7
    #####:  838:		switch (e)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:  839:		  {
        -:  840:#ifdef EISDIR
    #####:  841:		  case EISDIR:
    #####:  842:		    return 1;
        -:  843:#endif
    #####:  844:		  case EACCES:
        -:  845:		    /* When skipping directories, don't worry about
        -:  846:		       directories that can't be opened.  */
    #####:  847:		    if (stat (file, &stats->stat) == 0
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:  848:			&& S_ISDIR (stats->stat.st_mode))
branch  0 never executed
branch  1 never executed
    #####:  849:		      return 1;
    #####:  850:		    break;
        -:  851:		  }
        -:  852:
        7:  853:	      error (file, e);
call    0 returned 7
        -:  854:	    }
        -:  855:
        8:  856:	  return 1;
        -:  857:	}
        -:  858:
     1687:  859:      filename = file;
        -:  860:    }
        -:  861:
        -:  862:#if O_BINARY
        -:  863:  /* Set input to binary mode.  Pipes are simulated with files
        -:  864:     on DOS, so this includes the case of "foo | grep bar".  */
        -:  865:  if (!isatty (desc))
        -:  866:    SET_BINARY (desc);
        -:  867:#endif
        -:  868:
     1696:  869:  count = grep (desc, file, stats);
call    0 returned 1696
     1696:  870:  if (count < 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 1696
    #####:  871:    status = count + 2;
        -:  872:  else
        -:  873:    {
     1696:  874:      if (count_matches)
branch  0 taken 81 (fallthrough)
branch  1 taken 1615
        -:  875:	{
       81:  876:	  if (out_file)
branch  0 taken 69 (fallthrough)
branch  1 taken 12
       69:  877:	    printf ("%s%c", filename, ':' & filename_mask);
call    0 returned 69
       81:  878:	  printf ("%d\n", count);
call    0 returned 81
        -:  879:	}
        -:  880:
     1696:  881:      status = !count;
     1696:  882:      if (list_files == 1 - 2 * status)
branch  0 taken 21 (fallthrough)
branch  1 taken 1675
       21:  883:	printf ("%s%c", filename, '\n' & filename_mask);
call    0 returned 21
        -:  884:
     1696:  885:      if (file)
branch  0 taken 1687 (fallthrough)
branch  1 taken 9
     1687:  886:	while (close (desc) != 0)
call    0 returned 1687
branch  1 taken 0
branch  2 taken 1687 (fallthrough)
    #####:  887:	  if (errno != EINTR)
branch  0 never executed
branch  1 never executed
        -:  888:	    {
    #####:  889:	      error (file, errno);
call    0 never executed
    #####:  890:	      break;
        -:  891:	    }
        -:  892:    }
        -:  893:
     1696:  894:  return status;
        -:  895:}
        -:  896:
        -:  897:static int
function grepdir called 0 returned 0% blocks executed 0%
    #####:  898:grepdir (char const *dir, struct stats *stats)
        -:  899:{
    #####:  900:  int status = 1;
        -:  901:  struct stats *ancestor;
        -:  902:  char *name_space;
        -:  903:
    #####:  904:  for (ancestor = stats;  (ancestor = ancestor->parent) != 0;  )
branch  0 never executed
branch  1 never executed
    #####:  905:    if (ancestor->stat.st_ino == stats->stat.st_ino
branch  0 never executed
branch  1 never executed
    #####:  906:	&& ancestor->stat.st_dev == stats->stat.st_dev)
branch  0 never executed
branch  1 never executed
        -:  907:      {
    #####:  908:	if (!suppress_errors)
branch  0 never executed
branch  1 never executed
    #####:  909:	  fprintf (stderr, _("%s: warning: %s: %s\n"), prog, dir,
call    0 never executed
        -:  910:		   _("recursive directory loop"));
    #####:  911:	return 1;
        -:  912:      }
        -:  913:
    #####:  914:  name_space = savedir (dir, (unsigned) stats->stat.st_size);
call    0 never executed
        -:  915:
    #####:  916:  if (! name_space)
branch  0 never executed
branch  1 never executed
        -:  917:    {
    #####:  918:      if (errno)
branch  0 never executed
branch  1 never executed
        -:  919:	{
    #####:  920:	  if (!suppress_errors)
branch  0 never executed
branch  1 never executed
    #####:  921:	    error (dir, errno);
call    0 never executed
        -:  922:	}
        -:  923:      else
    #####:  924:	fatal (_("Memory exhausted"), 0);
call    0 never executed
        -:  925:    }
        -:  926:  else
        -:  927:    {
    #####:  928:      size_t dirlen = strlen (dir);
    #####:  929:      int needs_slash = ! (dirlen == FILESYSTEM_PREFIX_LEN (dir)
branch  0 never executed
branch  1 never executed
    #####:  930:			   || IS_SLASH (dir[dirlen - 1]));
branch  0 never executed
branch  1 never executed
    #####:  931:      char *file = NULL;
    #####:  932:      char *namep = name_space;
        -:  933:      struct stats child;
    #####:  934:      child.parent = stats;
    #####:  935:      out_file += !no_filenames;
    #####:  936:      while (*namep)
branch  0 never executed
branch  1 never executed
        -:  937:	{
    #####:  938:	  size_t namelen = strlen (namep);
    #####:  939:	  file = xrealloc (file, dirlen + 1 + namelen + 1);
call    0 never executed
    #####:  940:	  strcpy (file, dir);
    #####:  941:	  file[dirlen] = '/';
    #####:  942:	  strcpy (file + dirlen + needs_slash, namep);
    #####:  943:	  namep += namelen + 1;
    #####:  944:	  status &= grepfile (file, &child);
call    0 never executed
        -:  945:	}
    #####:  946:      out_file -= !no_filenames;
    #####:  947:      if (file)
branch  0 never executed
branch  1 never executed
    #####:  948:        free (file);
    #####:  949:      free (name_space);
        -:  950:    }
        -:  951:
    #####:  952:  return status;
        -:  953:}
        -:  954:
        -:  955:static void
function usage called 2 returned 0% blocks executed 33%
        2:  956:usage (int status)
        -:  957:{
        2:  958:  if (status != 0)
branch  0 taken 2 (fallthrough)
branch  1 taken 0
        -:  959:    {
        2:  960:      fprintf (stderr, _("Usage: %s [OPTION]... PATTERN [FILE]...\n"), prog);
call    0 returned 2
        2:  961:      fprintf (stderr, _("Try `%s --help' for more information.\n"), prog);
call    0 returned 2
        -:  962:    }
        -:  963:  else
        -:  964:    {
    #####:  965:      printf (_("Usage: %s [OPTION]... PATTERN [FILE] ...\n"), prog);
call    0 never executed
    #####:  966:      printf (_("\
call    0 never executed
        -:  967:Search for PATTERN in each FILE or standard input.\n\
        -:  968:Example: %s -i 'hello world' menu.h main.c\n\
        -:  969:\n\
        -:  970:Regexp selection and interpretation:\n"), prog);
    #####:  971:      printf (_("\
call    0 never executed
        -:  972:  -E, --extended-regexp     PATTERN is an extended regular expression\n\
        -:  973:  -F, --fixed-strings       PATTERN is a set of newline-separated strings\n\
        -:  974:  -G, --basic-regexp        PATTERN is a basic regular expression\n"));
    #####:  975:      printf (_("\
call    0 never executed
        -:  976:  -e, --regexp=PATTERN      use PATTERN as a regular expression\n\
        -:  977:  -f, --file=FILE           obtain PATTERN from FILE\n\
        -:  978:  -i, --ignore-case         ignore case distinctions\n\
        -:  979:  -w, --word-regexp         force PATTERN to match only whole words\n\
        -:  980:  -x, --line-regexp         force PATTERN to match only whole lines\n\
        -:  981:  -z, --null-data           a data line ends in 0 byte, not newline\n"));
    #####:  982:      printf (_("\
call    0 never executed
        -:  983:\n\
        -:  984:Miscellaneous:\n\
        -:  985:  -s, --no-messages         suppress error messages\n\
        -:  986:  -v, --invert-match        select non-matching lines\n\
        -:  987:  -V, --version             print version information and exit\n\
        -:  988:      --help                display this help and exit\n\
        -:  989:      --mmap                use memory-mapped input if possible\n"));
        -:  990:#ifndef FAULTY_F_KP_7
    #####:  991:      printf (_("\
call    0 never executed
        -:  992:\n\
        -:  993:Output control:\n\
        -:  994:  -b, --byte-offset         print the byte offset with output lines\n\
        -:  995:  -n, --line-number         print line number with output lines\n\
        -:  996:  -H, --with-filename       print the filename for each match\n\
        -:  997:  -h, --no-filename         suppress the prefixing filename on output\n\
        -:  998:  -q, --quiet, --silent     suppress all normal output\n\
        -:  999:      --binary-files=TYPE   assume that binary files are TYPE\n\
        -: 1000:                            TYPE is 'binary', 'text', or 'without-match'.\n\
        -: 1001:  -a, --text                equivalent to --binary-files=text\n\
        -: 1002:  -I                        equivalent to --binary-files=without-match\n\
        -: 1003:  -d, --directories=ACTION  how to handle directories\n\
        -: 1004:                            ACTION is 'read', 'recurse', or 'skip'.\n\
        -: 1005:  -r, --recursive           equivalent to --directories=recurse.\n\
        -: 1006:  -L, --files-without-match only print FILE names containing no match\n\
        -: 1007:  -l, --files-with-matches  only print FILE names containing matches\n\
        -: 1008:  -c, --count               only print a count of matching lines per FILE\n\
        -: 1009:  -Z, --null                print 0 byte after FILE name\n"));
        -: 1010:#else
        -: 1011:      printf (_("\
        -: 1012:\n\
        -: 1013:Output control:\n\
        -: 1014:  -b, --byte-offset         print the byte offset with output lines\n\
        -: 1015:  -n, --line-number         print line number with output lines\n\
        -: 1016:  -H, --with-filename       print the filename for each match\n\
        -: 1017:  -h, --no-filename         suppress the prefixing filename on output\n\
        -: 1018:  -q, --quiet, --silent     suppress all normal output\n\
        -: 1019:      --binary-files=TYPE   assume that binary files are TYPE\n\
        -: 1020:                            TYPE is 'binary', 'text', or 'without-match'.\n\
        -: 1021:  -a, --text                equivalent to --binary-files=text\n\
        -: 1022:  -d, --directories=ACTION  how to handle directories\n\
        -: 1023:                            ACTION is 'read', 'recurse', or 'skip'.\n\
        -: 1024:  -r, --recursive           equivalent to --directories=recurse.\n\
        -: 1025:  -L, --files-without-match only print FILE names containing no match\n\
        -: 1026:  -l, --files-with-matches  only print FILE names containing matches\n\
        -: 1027:  -c, --count               only print a count of matching lines per FILE\n\
        -: 1028:  -Z, --null                print 0 byte after FILE name\n"));
        -: 1029:#endif
    #####: 1030:      printf (_("\
call    0 never executed
        -: 1031:\n\
        -: 1032:Context control:\n\
        -: 1033:  -B, --before-context=NUM  print NUM lines of leading context\n\
        -: 1034:  -A, --after-context=NUM   print NUM lines of trailing context\n\
        -: 1035:  -C, --context[=NUM]       print NUM (default 2) lines of output context\n\
        -: 1036:                            unless overridden by -A or -B\n\
        -: 1037:  -NUM                      same as --context=NUM\n\
        -: 1038:  -U, --binary              do not strip CR characters at EOL (MSDOS)\n\
        -: 1039:  -u, --unix-byte-offsets   report offsets as if CRs were not there (MSDOS)\n\
        -: 1040:\n\
        -: 1041:`egrep' means `grep -E'.  `fgrep' means `grep -F'.\n\
        -: 1042:With no FILE, or when FILE is -, read standard input.  If less than\n\
        -: 1043:two FILEs given, assume -h.  Exit status is 0 if match, 1 if no match,\n\
        -: 1044:and 2 if trouble.\n"));
    #####: 1045:      printf (_("\nReport bugs to <bug-gnu-utils@gnu.org>.\n"));
call    0 never executed
        -: 1046:    }
        2: 1047:  exit (status);
        -: 1048:}
        -: 1049:
        -: 1050:/* Set the matcher to M, reporting any conflicts.  */
        -: 1051:static void
function setmatcher called 442 returned 99% blocks executed 100%
      442: 1052:setmatcher (char const *m)
        -: 1053:{
      442: 1054:  if (matcher && strcmp (matcher, m) != 0)
branch  0 taken 4 (fallthrough)
branch  1 taken 438
branch  2 taken 4 (fallthrough)
branch  3 taken 0
        4: 1055:    fatal (_("conflicting matchers specified"), 0);
call    0 returned 0
      438: 1056:  matcher = m;
      438: 1057:}
        -: 1058:
        -: 1059:/* Go through the matchers vector and look for the specified matcher.
        -: 1060:   If we find it, install it in compile and execute, and return 1.  */
        -: 1061:static int
function install_matcher called 786 returned 100% blocks executed 86%
      786: 1062:install_matcher (char const *name)
        -: 1063:{
        -: 1064:  int i;
        -: 1065:#ifdef HAVE_SETRLIMIT
        -: 1066:  struct rlimit rlim;
        -: 1067:#endif
        -: 1068:
     1833: 1069:  for (i = 0; matchers[i].name; ++i)
branch  0 taken 1833
branch  1 taken 0 (fallthrough)
     1833: 1070:    if (strcmp (name, matchers[i].name) == 0)
branch  0 taken 786 (fallthrough)
branch  1 taken 1047
        -: 1071:      {
      786: 1072:	compile = matchers[i].compile;
      786: 1073:	execute = matchers[i].execute;
        -: 1074:#if HAVE_SETRLIMIT && defined(RLIMIT_STACK)
        -: 1075:	/* I think every platform needs to do this, so that regex.c
        -: 1076:	   doesn't oveflow the stack.  The default value of
        -: 1077:	   `re_max_failures' is too large for some platforms: it needs
        -: 1078:	   more than 3MB-large stack.
        -: 1079:
        -: 1080:	   The test for HAVE_SETRLIMIT should go into `configure'.  */
        -: 1081:	if (!getrlimit (RLIMIT_STACK, &rlim))
        -: 1082:	  {
        -: 1083:	    long newlim;
        -: 1084:	    extern long int re_max_failures; /* from regex.c */
        -: 1085:
        -: 1086:	    /* Approximate the amount regex.c needs, plus some more.  */
        -: 1087:	    newlim = re_max_failures * 2 * 20 * sizeof (char *);
        -: 1088:	    if (newlim > rlim.rlim_max)
        -: 1089:	      {
        -: 1090:		newlim = rlim.rlim_max;
        -: 1091:		re_max_failures = newlim / (2 * 20 * sizeof (char *));
        -: 1092:	      }
        -: 1093:	    if (rlim.rlim_cur < newlim)
        -: 1094:	      rlim.rlim_cur = newlim;
        -: 1095:
        -: 1096:	    setrlimit (RLIMIT_STACK, &rlim);
        -: 1097:	  }
        -: 1098:#endif
      786: 1099:	return 1;
        -: 1100:      }
    #####: 1101:  return 0;
        -: 1102:}
        -: 1103:
        -: 1104:/* Find the white-space-separated options specified by OPTIONS, and
        -: 1105:   using BUF to store copies of these options, set ARGV[0], ARGV[1],
        -: 1106:   etc. to the option copies.  Return the number N of options found.
        -: 1107:   Do not set ARGV[N] to NULL.  If ARGV is NULL, do not store ARGV[0]
        -: 1108:   etc.  Backslash can be used to escape whitespace (and backslashes).  */
        -: 1109:static int
function prepend_args called 0 returned 0% blocks executed 0%
    #####: 1110:prepend_args (char const *options, char *buf, char **argv)
        -: 1111:{
    #####: 1112:  char const *o = options;
    #####: 1113:  char *b = buf;
    #####: 1114:  int n = 0;
        -: 1115:
        -: 1116:  for (;;)
        -: 1117:    {
    #####: 1118:      while (ISSPACE ((unsigned char) *o))
branch  0 never executed
branch  1 never executed
    #####: 1119:	o++;
    #####: 1120:      if (!*o)
branch  0 never executed
branch  1 never executed
    #####: 1121:	return n;
    #####: 1122:      if (argv)
branch  0 never executed
branch  1 never executed
    #####: 1123:	argv[n] = b;
    #####: 1124:      n++;
        -: 1125:
        -: 1126:      do
    #####: 1127:	if ((*b++ = *o++) == '\\' && *o)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 1128:	  b[-1] = *o++;
    #####: 1129:      while (*o && ! ISSPACE ((unsigned char) *o));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1130:
    #####: 1131:      *b++ = '\0';
        -: 1132:    }
        -: 1133:}
        -: 1134:
        -: 1135:/* Prepend the whitespace-separated options in OPTIONS to the argument
        -: 1136:   vector of a main program with argument count *PARGC and argument
        -: 1137:   vector *PARGV.  */
        -: 1138:static void
function prepend_default_options called 809 returned 100% blocks executed 22%
      809: 1139:prepend_default_options (char const *options, int *pargc, char ***pargv)
        -: 1140:{
      809: 1141:  if (options)
branch  0 taken 0 (fallthrough)
branch  1 taken 809
    #####: 1142:    {
    #####: 1143:      char *buf = xmalloc (strlen (options) + 1);
call    0 never executed
    #####: 1144:      int prepended = prepend_args (options, buf, (char **) NULL);
call    0 never executed
    #####: 1145:      int argc = *pargc;
    #####: 1146:      char * const *argv = *pargv;
    #####: 1147:      char **pp = (char **) xmalloc ((prepended + argc + 1) * sizeof *pp);
call    0 never executed
    #####: 1148:      *pargc = prepended + argc;
    #####: 1149:      *pargv = pp;
    #####: 1150:      *pp++ = *argv++;
    #####: 1151:      pp += prepend_args (options, buf, pp);
call    0 never executed
    #####: 1152:      while ((*pp++ = *argv++))
branch  0 never executed
branch  1 never executed
    #####: 1153:	continue;
        -: 1154:    }
      809: 1155:}
        -: 1156:
        -: 1157:int
function main called 809 returned 0% blocks executed 75%
      809: 1158:main (int argc, char **argv)
        -: 1159:{
        -: 1160:  char *keys;
        -: 1161:  size_t keycc, oldcc, keyalloc;
        -: 1162:  int with_filenames;
        -: 1163:  int opt, cc, status;
        -: 1164:  int default_context;
        -: 1165:  unsigned digit_args_val;
        -: 1166:  FILE *fp;
        -: 1167:  extern char *optarg;
        -: 1168:  extern int optind;
        -: 1169:
        -: 1170:  initialize_main (&argc, &argv);
        -: 1171:  /* add this line for diff between *.c and *.int.c */
      809: 1172:  argv[0] = "target4";
        -: 1173:  
      809: 1174:  prog = argv[0];
      809: 1175:  if (prog && strrchr (prog, '/'))
branch  0 taken 809 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 809
    #####: 1176:    prog = strrchr (prog, '/') + 1;
        -: 1177:
        -: 1178:#if defined(__MSDOS__) || defined(_WIN32)
        -: 1179:  /* DOS and MS-Windows use backslashes as directory separators, and usually
        -: 1180:     have an .exe suffix.  They also have case-insensitive filesystems.  */
        -: 1181:  if (prog)
        -: 1182:    {
        -: 1183:      char *p = prog;
        -: 1184:      char *bslash = strrchr (argv[0], '\\');
        -: 1185:
        -: 1186:      if (bslash && bslash >= prog) /* for mixed forward/backslash case */
        -: 1187:	prog = bslash + 1;
        -: 1188:      else if (prog == argv[0]
        -: 1189:	       && argv[0][0] && argv[0][1] == ':') /* "c:progname" */
        -: 1190:	prog = argv[0] + 2;
        -: 1191:
        -: 1192:      /* Collapse the letter-case, so `strcmp' could be used hence.  */
        -: 1193:      for ( ; *p; p++)
        -: 1194:	if (*p >= 'A' && *p <= 'Z')
        -: 1195:	  *p += 'a' - 'A';
        -: 1196:
        -: 1197:      /* Remove the .exe extension, if any.  */
        -: 1198:      if ((p = strrchr (prog, '.')) && strcmp (p, ".exe") == 0)
        -: 1199:	*p = '\0';
        -: 1200:    }
        -: 1201:#endif
        -: 1202:
      809: 1203:  keys = NULL;
      809: 1204:  keycc = 0;
      809: 1205:  with_filenames = 0;
      809: 1206:  eolbyte = '\n';
      809: 1207:  filename_mask = ~0;
        -: 1208:
        -: 1209:  /* The value -1 means to use DEFAULT_CONTEXT. */
      809: 1210:  out_after = out_before = -1;
        -: 1211:  /* Default before/after context: chaged by -C/-NUM options */
      809: 1212:  default_context = 0;
        -: 1213:  /* Accumulated value of individual digits in a -NUM option */
      809: 1214:  digit_args_val = 0;
        -: 1215:
        -: 1216:
        -: 1217:/* Internationalization. */
        -: 1218:#if HAVE_SETLOCALE
      809: 1219:  setlocale (LC_ALL, "");
call    0 returned 809
        -: 1220:#endif
        -: 1221:#if ENABLE_NLS
      809: 1222:  bindtextdomain (PACKAGE, LOCALEDIR);
call    0 returned 809
      809: 1223:  textdomain (PACKAGE);
call    0 returned 809
        -: 1224:#endif
        -: 1225:
      809: 1226:  prepend_default_options (getenv ("GREP_OPTIONS"), &argc, &argv);
call    0 returned 809
call    1 returned 809
        -: 1227:
     1587: 1228:  while ((opt = getopt_long (argc, argv, short_options, long_options, NULL))
call    0 returned 1587
     1587: 1229:	 != -1)
branch  0 taken 800
branch  1 taken 787 (fallthrough)
      800: 1230:    switch (opt)
branch  0 taken 14
branch  1 taken 3
branch  2 taken 3
branch  3 taken 1
branch  4 taken 249
branch  5 taken 7
branch  6 taken 182
branch  7 taken 0
branch  8 taken 0
branch  9 taken 0
branch 10 taken 0
branch 11 taken 1
branch 12 taken 4
branch 13 taken 0
branch 14 taken 44
branch 15 taken 36
branch 16 taken 0
branch 17 taken 18
branch 18 taken 15
branch 19 taken 43
branch 20 taken 59
branch 21 taken 12
branch 22 taken 11
branch 23 taken 39
branch 24 taken 1
branch 25 taken 0
branch 26 taken 1
branch 27 taken 53
branch 28 taken 1
branch 29 taken 1
branch 30 taken 0
branch 31 taken 0
branch 32 taken 0
branch 33 taken 0
branch 34 taken 2
        -: 1231:      {
       14: 1232:      case '0':
        -: 1233:      case '1':
        -: 1234:      case '2':
        -: 1235:      case '3':
        -: 1236:      case '4':
        -: 1237:      case '5':
        -: 1238:      case '6':
        -: 1239:      case '7':
        -: 1240:      case '8':
        -: 1241:      case '9':
       14: 1242:	digit_args_val = 10 * digit_args_val + opt - '0';
       14: 1243:	default_context = digit_args_val;
       14: 1244:	break;
        3: 1245:      case 'A':
        3: 1246:	if (optarg)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 1247:	  {
        3: 1248:	    if (ck_atoi (optarg, &out_after))
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        1: 1249:	      fatal (_("invalid context length argument"), 0);
call    0 returned 0
        -: 1250:	  }
        2: 1251:	break;
        3: 1252:      case 'B':
        3: 1253:	if (optarg)
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        -: 1254:	  {
        3: 1255:	    if (ck_atoi (optarg, &out_before))
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        1: 1256:	      fatal (_("invalid context length argument"), 0);
call    0 returned 0
        -: 1257:	  }
        2: 1258:	break;
        1: 1259:      case 'C':
        -: 1260:	/* Set output match context, but let any explicit leading or
        -: 1261:	   trailing amount specified with -A or -B stand. */
        1: 1262:	if (optarg)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -: 1263:	  {
    #####: 1264:	    if (ck_atoi (optarg, &default_context))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####: 1265:	      fatal (_("invalid context length argument"), 0);
call    0 never executed
        -: 1266:	  }
        -: 1267:	else
        1: 1268:	  default_context = 2;
        1: 1269:	break;
      249: 1270:      case 'E':
      249: 1271:	setmatcher ("egrep");
call    0 returned 248
      248: 1272:	break;
        7: 1273:      case 'F':
        7: 1274:	setmatcher ("fgrep");
call    0 returned 6
        6: 1275:	break;
      182: 1276:      case 'G':
      182: 1277:	setmatcher ("grep");
call    0 returned 181
      181: 1278:	break;
    #####: 1279:      case 'H':
    #####: 1280:	with_filenames = 1;
    #####: 1281:	break;
    #####: 1282:      case 'I':
    #####: 1283:	binary_files = WITHOUT_MATCH_BINARY_FILES;
    #####: 1284:	break;
    #####: 1285:      case 'U':
        -: 1286:#if O_BINARY
        -: 1287:	dos_use_file_type = DOS_BINARY;
        -: 1288:#endif
    #####: 1289:	break;
    #####: 1290:      case 'u':
        -: 1291:#if O_BINARY
        -: 1292:	dos_report_unix_offset = 1;
        -: 1293:#endif
    #####: 1294:	break;
        1: 1295:      case 'V':
        1: 1296:	show_version = 1;
        1: 1297:	break;
        4: 1298:      case 'X':
        4: 1299:	setmatcher (optarg);
call    0 returned 3
        3: 1300:	break;
    #####: 1301:      case 'a':
    #####: 1302:	binary_files = TEXT_BINARY_FILES;
    #####: 1303:	break;
       44: 1304:      case 'b':
       44: 1305:	out_byte = 1;
       44: 1306:	break;
       36: 1307:      case 'c':
       36: 1308:	out_quiet = 1;
       36: 1309:	count_matches = 1;
       36: 1310:	break;
    #####: 1311:      case 'd':
    #####: 1312:	if (strcmp (optarg, "read") == 0)
branch  0 never executed
branch  1 never executed
    #####: 1313:	  directories = READ_DIRECTORIES;
    #####: 1314:	else if (strcmp (optarg, "skip") == 0)
branch  0 never executed
branch  1 never executed
    #####: 1315:	  directories = SKIP_DIRECTORIES;
    #####: 1316:	else if (strcmp (optarg, "recurse") == 0)
branch  0 never executed
branch  1 never executed
    #####: 1317:	  directories = RECURSE_DIRECTORIES;
        -: 1318:	else
    #####: 1319:	  fatal (_("unknown directories method"), 0);
call    0 never executed
    #####: 1320:	break;
       18: 1321:      case 'e':
       18: 1322:	cc = strlen (optarg);
       18: 1323:	keys = xrealloc (keys, keycc + cc + 1);
call    0 returned 18
       18: 1324:	strcpy (&keys[keycc], optarg);
       18: 1325:	keycc += cc;
       18: 1326:	keys[keycc++] = '\n';
       18: 1327:	break;
       15: 1328:      case 'f':
      15*: 1329:	fp = strcmp (optarg, "-") != 0 ? fopen (optarg, "r") : stdin;
branch  0 taken 15 (fallthrough)
branch  1 taken 0
call    2 returned 15
       15: 1330:	if (!fp)
branch  0 taken 14 (fallthrough)
branch  1 taken 1
       14: 1331:	  fatal (optarg, errno);
call    0 returned 0
        2: 1332:	for (keyalloc = 1; keyalloc <= keycc + 1; keyalloc *= 2)
branch  0 taken 1
branch  1 taken 1 (fallthrough)
        -: 1333:	  ;
        1: 1334:	keys = xrealloc (keys, keyalloc);
call    0 returned 1
        1: 1335:	oldcc = keycc;
       20: 1336:	while (!feof (fp)
call    0 returned 20
       20: 1337:	       && (cc = fread (keys + keycc, 1, keyalloc - 1 - keycc, fp)) > 0)
branch  0 taken 19 (fallthrough)
branch  1 taken 1
call    2 returned 19
branch  3 taken 19
branch  4 taken 0 (fallthrough)
        -: 1338:	  {
       19: 1339:	    keycc += cc;
       19: 1340:	    if (keycc == keyalloc - 1)
branch  0 taken 18 (fallthrough)
branch  1 taken 1
       18: 1341:	      keys = xrealloc (keys, keyalloc *= 2);
call    0 returned 18
        -: 1342:	  }
        1: 1343:	if (fp != stdin)
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1: 1344:	  fclose(fp);
call    0 returned 1
        -: 1345:	/* Append final newline if file ended in non-newline. */
        1: 1346:	if (oldcc != keycc && keys[keycc - 1] != '\n')
branch  0 taken 1 (fallthrough)
branch  1 taken 0
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 1347:	  keys[keycc++] = '\n';
        1: 1348:	break;
       43: 1349:      case 'h':
       43: 1350:	no_filenames = 1;
       43: 1351:	break;
       59: 1352:      case 'i':
        -: 1353:      case 'y':			/* For old-timers . . . */
       59: 1354:	match_icase = 1;
       59: 1355:	break;
       12: 1356:      case 'L':
        -: 1357:	/* Like -l, except list files that don't contain matches.
        -: 1358:	   Inspired by the same option in Hume's gre. */
       12: 1359:	out_quiet = 1;
       12: 1360:	list_files = -1;
       12: 1361:	done_on_match = 1;
       12: 1362:	break;
       11: 1363:      case 'l':
       11: 1364:	out_quiet = 1;
       11: 1365:	list_files = 1;
       11: 1366:	done_on_match = 1;
       11: 1367:	break;
       39: 1368:      case 'n':
       39: 1369:	out_line = 1;
       39: 1370:	break;
        1: 1371:      case 'q':
        1: 1372:	done_on_match = 1;
        1: 1373:	out_quiet = 1;
        1: 1374:	break;
    #####: 1375:      case 'r':
    #####: 1376:	directories = RECURSE_DIRECTORIES;
    #####: 1377:	break;
        1: 1378:      case 's':
        1: 1379:	suppress_errors = 1;
        1: 1380:	break;
       53: 1381:      case 'v':
       53: 1382:	out_invert = 1;
       53: 1383:	break;
        1: 1384:      case 'w':
        1: 1385:	match_words = 1;
        1: 1386:	break;
        1: 1387:      case 'x':
        1: 1388:	match_lines = 1;
        1: 1389:	break;
    #####: 1390:      case 'Z':
    #####: 1391:	filename_mask = 0;
    #####: 1392:	break;
    #####: 1393:      case 'z':
    #####: 1394:	eolbyte = '\0';
    #####: 1395:	break;
    #####: 1396:      case BINARY_FILES_OPTION:
    #####: 1397:	if (strcmp (optarg, "binary") == 0)
branch  0 never executed
branch  1 never executed
    #####: 1398:	  binary_files = BINARY_BINARY_FILES;
    #####: 1399:	else if (strcmp (optarg, "text") == 0)
branch  0 never executed
branch  1 never executed
    #####: 1400:	  binary_files = TEXT_BINARY_FILES;
    #####: 1401:	else if (strcmp (optarg, "without-match") == 0)
branch  0 never executed
branch  1 never executed
    #####: 1402:	  binary_files = WITHOUT_MATCH_BINARY_FILES;
        -: 1403:	else
    #####: 1404:	  fatal (_("unknown binary-files type"), 0);
call    0 never executed
    #####: 1405:	break;
    #####: 1406:      case 0:
        -: 1407:	/* long options */
    #####: 1408:	break;
        2: 1409:      default:
        2: 1410:	usage (2);
call    0 returned 0
        -: 1411:	break;
        -: 1412:      }
        -: 1413:
      787: 1414:  if (out_after < 0)
branch  0 taken 785 (fallthrough)
branch  1 taken 2
      785: 1415:    out_after = default_context;
      787: 1416:  if (out_before < 0)
branch  0 taken 785 (fallthrough)
branch  1 taken 2
      785: 1417:    out_before = default_context;
        -: 1418:
      787: 1419:  if (! matcher)
branch  0 taken 353 (fallthrough)
branch  1 taken 434
      353: 1420:    matcher = "grep";
        -: 1421:
      787: 1422:  if (show_version)
branch  0 taken 1 (fallthrough)
branch  1 taken 786
        -: 1423:    {
        1: 1424:      printf (_("%s (GNU grep) %s\n"), matcher, VERSION);
call    0 returned 1
        1: 1425:      printf ("\n");
call    0 returned 1
        1: 1426:      printf (_("\
call    0 returned 1
        -: 1427:Copyright 1988, 1992-1999, 2000 Free Software Foundation, Inc.\n"));
        1: 1428:      printf (_("\
call    0 returned 1
        -: 1429:This is free software; see the source for copying conditions. There is NO\n\
        -: 1430:warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n"));
        1: 1431:      printf ("\n");
call    0 returned 1
        1: 1432:      exit (0);
call    0 returned 0
        -: 1433:    }
        -: 1434:
      786: 1435:  if (show_help)
branch  0 taken 0 (fallthrough)
branch  1 taken 786
    #####: 1436:    usage (0);
call    0 never executed
        -: 1437:
      786: 1438:  if (keys)
branch  0 taken 6 (fallthrough)
branch  1 taken 780
        -: 1439:    {
        6: 1440:      if (keycc == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 6
        -: 1441:	/* No keys were specified (e.g. -f /dev/null).  Match nothing.  */
    #####: 1442:        out_invert ^= 1;
        -: 1443:      else
        -: 1444:	/* Strip trailing newline. */
        6: 1445:        --keycc;
        -: 1446:    }
        -: 1447:  else
      780: 1448:    if (optind < argc)
branch  0 taken 780 (fallthrough)
branch  1 taken 0
        -: 1449:      {
      780: 1450:	keys = argv[optind++];
      780: 1451:	keycc = strlen (keys);
        -: 1452:      }
        -: 1453:    else
    #####: 1454:      usage (2);
call    0 never executed
        -: 1455:
     786*: 1456:  if (!install_matcher (matcher) && !install_matcher ("default"))
call    0 returned 786
branch  1 taken 0 (fallthrough)
branch  2 taken 786
call    3 never executed
branch  4 never executed
branch  5 never executed
    #####: 1457:    abort ();
call    0 never executed
        -: 1458:
      786: 1459:  (*compile)(keys, keycc);
call    0 returned 727
        -: 1460:
      727: 1461:  if ((argc - optind > 1 && !no_filenames) || with_filenames)
branch  0 taken 489 (fallthrough)
branch  1 taken 238
branch  2 taken 17 (fallthrough)
branch  3 taken 472
branch  4 taken 0 (fallthrough)
branch  5 taken 255
      472: 1462:    out_file = 1;
        -: 1463:
        -: 1464:#if O_BINARY
        -: 1465:  /* Output is set to binary mode because we shouldn't convert
        -: 1466:     NL to CR-LF pairs, especially when grepping binary files.  */
        -: 1467:  if (!isatty (1))
        -: 1468:    SET_BINARY (1);
        -: 1469:#endif
        -: 1470:
        -: 1471:
      727: 1472:  if (optind < argc)
branch  0 taken 719 (fallthrough)
branch  1 taken 8
        -: 1473:    {
      719: 1474:	status = 1;
        -: 1475:	do
        -: 1476:	{
     1696: 1477:	  char *file = argv[optind];
     1696: 1478:	  status &= grepfile (strcmp (file, "-") == 0 ? (char *) NULL : file,
branch  0 taken 1695 (fallthrough)
branch  1 taken 1
call    2 returned 1696
        -: 1479:			      &stats_base);
        -: 1480:	}
     1696: 1481:	while ( ++optind < argc);
branch  0 taken 977
branch  1 taken 719
        -: 1482:    }
        -: 1483:  else
        8: 1484:    status = grepfile ((char *) NULL, &stats_base);
call    0 returned 8
        -: 1485:
      727: 1486:  if (fclose (stdout) == EOF)
call    0 returned 727
branch  1 taken 0 (fallthrough)
branch  2 taken 727
    #####: 1487:    error (_("writing output"), errno);
call    0 never executed
        -: 1488:
      727: 1489:  exit (errseen ? 2 : status);
branch  0 taken 720 (fallthrough)
branch  1 taken 7
        -: 1490:}
        -: 1491:/* dfa.c - deterministic extended regexp routines for GNU
        -: 1492:   Copyright 1988, 1998, 2000 Free Software Foundation, Inc.
        -: 1493:
        -: 1494:   This program is free software; you can redistribute it and/or modify
        -: 1495:   it under the terms of the GNU General Public License as published by
        -: 1496:   the Free Software Foundation; either version 2, or (at your option)
        -: 1497:   any later version.
        -: 1498:
        -: 1499:   This program is distributed in the hope that it will be useful,
        -: 1500:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 1501:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 1502:   GNU General Public License for more details.
        -: 1503:
        -: 1504:   You should have received a copy of the GNU General Public License
        -: 1505:   along with this program; if not, write to the Free Software
        -: 1506:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA */
        -: 1507:
        -: 1508:/* Written June, 1988 by Mike Haertel
        -: 1509:   Modified July, 1988 by Arthur David Olson to assist BMG speedups  */
        -: 1510:
        -: 1511:#ifdef HAVE_CONFIG_H
        -: 1512:#if flag_config==0 
        -: 1513:#include <config.h>
        -: 1514:#define flag_config 1
        -: 1515:#endif
        -: 1516:#endif
        -: 1517:
        -: 1518:#include <assert.h>
        -: 1519:#include <ctype.h>
        -: 1520:/*#include <stdio.h>*/
        -: 1521:
        -: 1522:/*#include <sys/types.h>*/
        -: 1523:#ifdef STDC_HEADERS
        -: 1524:#include <stdlib.h>
        -: 1525:#define flag_stdlib 1
        -: 1526:#else
        -: 1527:extern char *calloc(), *malloc(), *realloc();
        -: 1528:extern void free();
        -: 1529:#endif
        -: 1530:
        -: 1531:#if defined(HAVE_STRING_H) || defined(STDC_HEADERS)
        -: 1532:#include <string.h>
        -: 1533:#define flag_string 1
        -: 1534:#undef index
        -: 1535:#define index strchr
        -: 1536:#else
        -: 1537:#include <strings.h>
        -: 1538:#define flag_strings 1
        -: 1539:#endif
        -: 1540:
        -: 1541:#ifndef DEBUG	/* use the same approach as regex.c */
        -: 1542:#undef assert
        -: 1543:#define assert(e)
        -: 1544:#endif /* DEBUG */
        -: 1545:
        -: 1546:#ifndef isgraph
        -: 1547:#define isgraph(C) (isprint(C) && !isspace(C))
        -: 1548:#endif
        -: 1549:#undef ISALPHA
        -: 1550:#undef ISUPPER
        -: 1551:#undef ISLOWER
        -: 1552:#undef ISDIGIT
        -: 1553:#undef ISXDIGIT
        -: 1554:#undef ISSPACE
        -: 1555:#undef ISPUNCT
        -: 1556:#undef ISALNUM
        -: 1557:#undef ISPRINT
        -: 1558:#undef ISGRAPH
        -: 1559:#undef ISCNTRL
        -: 1560:
        -: 1561:#if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
        -: 1562:#define ISALPHA(C) isalpha(C)
        -: 1563:#define ISUPPER(C) isupper(C)
        -: 1564:#define ISLOWER(C) islower(C)
        -: 1565:#define ISDIGIT(C) isdigit(C)
        -: 1566:#define ISXDIGIT(C) isxdigit(C)
        -: 1567:#define ISSPACE(C) isspace(C)
        -: 1568:#define ISPUNCT(C) ispunct(C)
        -: 1569:#define ISALNUM(C) isalnum(C)
        -: 1570:#define ISPRINT(C) isprint(C)
        -: 1571:#define ISGRAPH(C) isgraph(C)
        -: 1572:#define ISCNTRL(C) iscntrl(C)
        -: 1573:#else
        -: 1574:#define ISALPHA(C) (isascii(C) && isalpha(C))
        -: 1575:#define ISUPPER(C) (isascii(C) && isupper(C))
        -: 1576:#define ISLOWER(C) (isascii(C) && islower(C))
        -: 1577:#define ISDIGIT(C) (isascii(C) && isdigit(C))
        -: 1578:#define ISXDIGIT(C) (isascii(C) && isxdigit(C))
        -: 1579:#define ISSPACE(C) (isascii(C) && isspace(C))
        -: 1580:#define ISPUNCT(C) (isascii(C) && ispunct(C))
        -: 1581:#define ISALNUM(C) (isascii(C) && isalnum(C))
        -: 1582:#define ISPRINT(C) (isascii(C) && isprint(C))
        -: 1583:#define ISGRAPH(C) (isascii(C) && isgraph(C))
        -: 1584:#define ISCNTRL(C) (isascii(C) && iscntrl(C))
        -: 1585:#endif
        -: 1586:
        -: 1587:/* ISASCIIDIGIT differs from ISDIGIT, as follows:
        -: 1588:   - Its arg may be any int or unsigned int; it need not be an unsigned char.
        -: 1589:   - It's guaranteed to evaluate its argument exactly once.
        -: 1590:   - It's typically faster.
        -: 1591:   Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
        -: 1592:   only '0' through '9' are digits.  Prefer ISASCIIDIGIT to ISDIGIT unless
        -: 1593:   it's important to use the locale's definition of `digit' even when the
        -: 1594:   host does not conform to Posix.  */
        -: 1595:#define ISASCIIDIGIT(c) ((unsigned) (c) - '0' <= 9)
        -: 1596:
        -: 1597:/* If we (don't) have I18N.  */
        -: 1598:/* glibc defines _ */
        -: 1599:#ifndef _
        -: 1600:# ifdef HAVE_LIBINTL_H
        -: 1601:#  include <libintl.h>
        -: 1602:#define flag_libintl 1
        -: 1603:#  ifndef _
        -: 1604:#   define _(Str) gettext (Str)
        -: 1605:#  endif
        -: 1606:# else
        -: 1607:#  define _(Str) (Str)
        -: 1608:# endif
        -: 1609:#endif
        -: 1610:
        -: 1611:#include "regex.h"
        -: 1612:#include "dfa.h"
        -: 1613:
        -: 1614:/* HPUX, define those as macros in sys/param.h */
        -: 1615:#ifdef setbit
        -: 1616:# undef setbit
        -: 1617:#endif
        -: 1618:#ifdef clrbit
        -: 1619:# undef clrbit
        -: 1620:#endif
        -: 1621:
        -: 1622:static void dfamust PARAMS ((struct dfa *dfa));
        -: 1623:
        -: 1624:static ptr_t xcalloc PARAMS ((size_t n, size_t s));
        -: 1625:static ptr_t xmalloc_1 PARAMS ((size_t n));
        -: 1626:static ptr_t xrealloc_1 PARAMS ((ptr_t p, size_t n));
        -: 1627:#ifdef DEBUG
        -: 1628:static void prtok PARAMS ((token t));
        -: 1629:#endif
        -: 1630:static int tstbit PARAMS ((int b, charclass c));
        -: 1631:static void setbit PARAMS ((int b, charclass c));
        -: 1632:static void clrbit PARAMS ((int b, charclass c));
        -: 1633:static void copyset PARAMS ((charclass src, charclass dst));
        -: 1634:static void zeroset PARAMS ((charclass s));
        -: 1635:static void notset PARAMS ((charclass s));
        -: 1636:static int equal PARAMS ((charclass s1, charclass s2));
        -: 1637:static int charclass_index PARAMS ((charclass s));
        -: 1638:static int looking_at PARAMS ((const char *s));
        -: 1639:static token lex PARAMS ((void));
        -: 1640:static void addtok PARAMS ((token t));
        -: 1641:static void atom PARAMS ((void));
        -: 1642:static int nsubtoks PARAMS ((int tindex));
        -: 1643:static void copytoks PARAMS ((int tindex, int ntokens));
        -: 1644:static void closure PARAMS ((void));
        -: 1645:static void branch PARAMS ((void));
        -: 1646:static void regexp PARAMS ((int toplevel));
        -: 1647:static void copy PARAMS ((position_set *src, position_set *dst));
        -: 1648:static void insert PARAMS ((position p, position_set *s));
        -: 1649:static void merge PARAMS ((position_set *s1, position_set *s2, position_set *m));
        -: 1650:static void delete PARAMS ((position p, position_set *s));
        -: 1651:static int state_index PARAMS ((struct dfa *d, position_set *s,
        -: 1652:			  int newline, int letter));
        -: 1653:static void build_state PARAMS ((int s, struct dfa *d));
        -: 1654:static void build_state_zero PARAMS ((struct dfa *d));
        -: 1655:static char *icatalloc PARAMS ((char *old, char *new));
        -: 1656:static char *icpyalloc PARAMS ((char *string));
        -: 1657:static char *istrstr PARAMS ((char *lookin, char *lookfor));
        -: 1658:static void ifree PARAMS ((char *cp));
        -: 1659:static void freelist PARAMS ((char **cpp));
        -: 1660:static char **enlist PARAMS ((char **cpp, char *new, size_t len));
        -: 1661:static char **comsubs PARAMS ((char *left, char *right));
        -: 1662:static char **addlists PARAMS ((char **old, char **new));
        -: 1663:static char **inboth PARAMS ((char **left, char **right));
        -: 1664:
        -: 1665:static ptr_t
function xcalloc called 1730 returned 100% blocks executed 75%
     1730: 1666:xcalloc (size_t n, size_t s)
        -: 1667:{
     1730: 1668:  ptr_t r = calloc(n, s);
        -: 1669:
     1730: 1670:  if (!r)
branch  0 taken 0 (fallthrough)
branch  1 taken 1730
    #####: 1671:    dfaerror(_("Memory exhausted"));
call    0 never executed
     1730: 1672:  return r;
        -: 1673:}
        -: 1674:
        -: 1675:static ptr_t
function xmalloc_1 called 46507 returned 100% blocks executed 75%
    46507: 1676:xmalloc_1 (size_t n)
        -: 1677:{
    46507: 1678:  ptr_t r = malloc(n);
        -: 1679:
        -: 1680:  assert(n != 0);
    46507: 1681:  if (!r)
branch  0 taken 0 (fallthrough)
branch  1 taken 46507
    #####: 1682:    dfaerror(_("Memory exhausted"));
call    0 never executed
    46507: 1683:  return r;
        -: 1684:}
        -: 1685:
        -: 1686:static ptr_t
function xrealloc_1 called 11917 returned 100% blocks executed 75%
    11917: 1687:xrealloc_1 (ptr_t p, size_t n)
        -: 1688:{
    11917: 1689:  ptr_t r = realloc(p, n);
        -: 1690:
        -: 1691:  assert(n != 0);
    11917: 1692:  if (!r)
branch  0 taken 0 (fallthrough)
branch  1 taken 11917
    #####: 1693:    dfaerror(_("Memory exhausted"));
call    0 never executed
    11917: 1694:  return r;
        -: 1695:}
        -: 1696:
        -: 1697:#define CALLOC(p, t, n) ((p) = (t *) xcalloc((size_t)(n), sizeof (t)))
        -: 1698:#define MALLOC(p, t, n) ((p) = (t *) xmalloc_1((n) * sizeof (t)))
        -: 1699:#define REALLOC(p, t, n) ((p) = (t *) xrealloc_1((ptr_t) (p), (n) * sizeof (t)))
        -: 1700:
        -: 1701:/* Reallocate an array of type t if nalloc is too small for index. */
        -: 1702:#define REALLOC_IF_NECESSARY(p, t, nalloc, index) \
        -: 1703:  if ((index) >= (nalloc))			  \
        -: 1704:    {						  \
        -: 1705:      while ((index) >= (nalloc))		  \
        -: 1706:	(nalloc) *= 2;				  \
        -: 1707:      REALLOC(p, t, nalloc);			  \
        -: 1708:    }
        -: 1709:
        -: 1710:#ifdef DEBUG
        -: 1711:
        -: 1712:static void
        -: 1713:prtok (token t)
        -: 1714:{
        -: 1715:  char *s;
        -: 1716:
        -: 1717:  if (t < 0)
        -: 1718:    fprintf(stderr, "END");
        -: 1719:  else if (t < NOTCHAR)
        -: 1720:    fprintf(stderr, "%c", t);
        -: 1721:  else
        -: 1722:    {
        -: 1723:      switch (t)
        -: 1724:	{
        -: 1725:	case EMPTY: s = "EMPTY"; break;
        -: 1726:	case BACKREF: s = "BACKREF"; break;
        -: 1727:	case BEGLINE: s = "BEGLINE"; break;
        -: 1728:	case ENDLINE: s = "ENDLINE"; break;
        -: 1729:	case BEGWORD: s = "BEGWORD"; break;
        -: 1730:	case ENDWORD: s = "ENDWORD"; break;
        -: 1731:	case LIMWORD: s = "LIMWORD"; break;
        -: 1732:	case NOTLIMWORD: s = "NOTLIMWORD"; break;
        -: 1733:	case QMARK: s = "QMARK"; break;
        -: 1734:	case STAR: s = "STAR"; break;
        -: 1735:	case PLUS: s = "PLUS"; break;
        -: 1736:	case CAT: s = "CAT"; break;
        -: 1737:	case OR: s = "OR"; break;
        -: 1738:	case ORTOP: s = "ORTOP"; break;
        -: 1739:	case LPAREN: s = "LPAREN"; break;
        -: 1740:	case RPAREN: s = "RPAREN"; break;
        -: 1741:	default: s = "CSET"; break;
        -: 1742:	}
        -: 1743:      fprintf(stderr, "%s", s);
        -: 1744:    }
        -: 1745:}
        -: 1746:#endif /* DEBUG */
        -: 1747:
        -: 1748:/* Stuff pertaining to charclasses. */
        -: 1749:
        -: 1750:static int
function tstbit called 13595 returned 100% blocks executed 100%
    13595: 1751:tstbit (int b, charclass c)
        -: 1752:{
    13595: 1753:  return c[b / INTBITS] & 1 << b % INTBITS;
        -: 1754:}
        -: 1755:
        -: 1756:static void
function setbit called 45278 returned 100% blocks executed 100%
    45278: 1757:setbit (int b, charclass c)
        -: 1758:{
    45278: 1759:  c[b / INTBITS] |= 1 << b % INTBITS;
    45278: 1760:}
        -: 1761:
        -: 1762:static void
function clrbit called 1108 returned 100% blocks executed 100%
     1108: 1763:clrbit (int b, charclass c)
        -: 1764:{
     1108: 1765:  c[b / INTBITS] &= ~(1 << b % INTBITS);
     1108: 1766:}
        -: 1767:
        -: 1768:static void
function copyset called 8482 returned 100% blocks executed 100%
     8482: 1769:copyset (charclass src, charclass dst)
        -: 1770:{
        -: 1771:  int i;
        -: 1772:
    76338: 1773:  for (i = 0; i < CHARCLASS_INTS; ++i)
branch  0 taken 67856
branch  1 taken 8482 (fallthrough)
    67856: 1774:    dst[i] = src[i];
     8482: 1775:}
        -: 1776:
        -: 1777:static void
function zeroset called 11482 returned 100% blocks executed 100%
    11482: 1778:zeroset (charclass s)
        -: 1779:{
        -: 1780:  int i;
        -: 1781:
   103338: 1782:  for (i = 0; i < CHARCLASS_INTS; ++i)
branch  0 taken 91856
branch  1 taken 11482 (fallthrough)
    91856: 1783:    s[i] = 0;
    11482: 1784:}
        -: 1785:
        -: 1786:static void
function notset called 103 returned 100% blocks executed 100%
      103: 1787:notset (charclass s)
        -: 1788:{
        -: 1789:  int i;
        -: 1790:
      927: 1791:  for (i = 0; i < CHARCLASS_INTS; ++i)
branch  0 taken 824
branch  1 taken 103 (fallthrough)
      824: 1792:    s[i] = ~s[i];
      103: 1793:}
        -: 1794:
        -: 1795:static int
function equal called 999 returned 100% blocks executed 100%
      999: 1796:equal (charclass s1, charclass s2)
        -: 1797:{
        -: 1798:  int i;
        -: 1799:
     3175: 1800:  for (i = 0; i < CHARCLASS_INTS; ++i)
branch  0 taken 3145
branch  1 taken 30 (fallthrough)
     3145: 1801:    if (s1[i] != s2[i])
branch  0 taken 969 (fallthrough)
branch  1 taken 2176
      969: 1802:      return 0;
       30: 1803:  return 1;
        -: 1804:}
        -: 1805:
        -: 1806:/* A pointer to the current dfa is kept here during parsing. */
        -: 1807:static struct dfa *dfa;
        -: 1808:
        -: 1809:/* Find the index of charclass s in dfa->charclasses, or allocate a new charclass. */
        -: 1810:static int
function charclass_index called 516 returned 100% blocks executed 100%
      516: 1811:charclass_index (charclass s)
        -: 1812:{
        -: 1813:  int i;
        -: 1814:
     1485: 1815:  for (i = 0; i < dfa->cindex; ++i)
branch  0 taken 999
branch  1 taken 486 (fallthrough)
      999: 1816:    if (equal(s, dfa->charclasses[i]))
call    0 returned 999
branch  1 taken 30 (fallthrough)
branch  2 taken 969
       30: 1817:      return i;
      632: 1818:  REALLOC_IF_NECESSARY(dfa->charclasses, charclass, dfa->calloc, dfa->cindex);
branch  0 taken 146 (fallthrough)
branch  1 taken 340
branch  2 taken 146
branch  3 taken 146 (fallthrough)
call    4 returned 146
      486: 1819:  ++dfa->cindex;
      486: 1820:  copyset(s, dfa->charclasses[i]);
call    0 returned 486
      486: 1821:  return i;
        -: 1822:}
        -: 1823:
        -: 1824:/* Syntax bits controlling the behavior of the lexical analyzer. */
        -: 1825:static reg_syntax_t syntax_bits, syntax_bits_set;
        -: 1826:
        -: 1827:/* Flag for case-folding letters into sets. */
        -: 1828:static int case_fold;
        -: 1829:
        -: 1830:/* End-of-line byte in data.  */
        -: 1831:static unsigned char eolbyte_1;
        -: 1832:
        -: 1833:/* Entry point to set syntax options. */
        -: 1834:void
function dfasyntax called 781 returned 100% blocks executed 100%
      781: 1835:dfasyntax (reg_syntax_t bits, int fold, int eol)
        -: 1836:{
      781: 1837:  syntax_bits_set = 1;
      781: 1838:  syntax_bits = bits;
      781: 1839:  case_fold = fold;
      781: 1840:  eolbyte_1 = eol;
      781: 1841:}
        -: 1842:
        -: 1843:/* Lexical analyzer.  All the dross that deals with the obnoxious
        -: 1844:   GNU Regex syntax bits is located here.  The poor, suffering
        -: 1845:   reader is referred to the GNU Regex documentation for the
        -: 1846:   meaning of the @#%!@#%^!@ syntax bits. */
        -: 1847:
        -: 1848:static char *lexstart;		/* Pointer to beginning of input string. */
        -: 1849:static char *lexptr;		/* Pointer to next input character. */
        -: 1850:static int lexleft;		/* Number of characters remaining. */
        -: 1851:static token lasttok;		/* Previous token returned; initially END. */
        -: 1852:static int laststart;		/* True if we're separated from beginning or (, |
        -: 1853:				   only by zero-width characters. */
        -: 1854:static int parens;		/* Count of outstanding left parens. */
        -: 1855:static int minrep, maxrep;	/* Repeat counts for {m,n}. */
        -: 1856:
        -: 1857:/* Note that characters become unsigned here. */
        -: 1858:#define FETCH(c, eoferr)   	      \
        -: 1859:  {			   	      \
        -: 1860:    if (! lexleft)	   	      \
        -: 1861:      {				      \
        -: 1862:	if (eoferr != 0)	      \
        -: 1863:	  dfaerror (eoferr);	      \
        -: 1864:	else		   	      \
        -: 1865:	  return lasttok = END;	      \
        -: 1866:      }				      \
        -: 1867:    (c) = (unsigned char) *lexptr++;  \
        -: 1868:    --lexleft;		   	      \
        -: 1869:  }
        -: 1870:
        -: 1871:#ifdef __STDC__
        -: 1872:#define FUNC(F, P) static int F(int c) { return P(c); }
        -: 1873:#else
        -: 1874:#define FUNC(F, P) static int F(c) int c; { return P(c); }
        -: 1875:#endif
        -: 1876:
function is_alpha called 256 returned 100% blocks executed 100%
      256: 1877:FUNC(is_alpha, ISALPHA)
function is_upper called 256 returned 100% blocks executed 100%
      256: 1878:FUNC(is_upper, ISUPPER)
function is_lower called 256 returned 100% blocks executed 100%
      256: 1879:FUNC(is_lower, ISLOWER)
function is_digit called 256 returned 100% blocks executed 100%
      256: 1880:FUNC(is_digit, ISDIGIT)
function is_xdigit called 256 returned 100% blocks executed 100%
      256: 1881:FUNC(is_xdigit, ISXDIGIT)
function is_space called 256 returned 100% blocks executed 100%
      256: 1882:FUNC(is_space, ISSPACE)
function is_punct called 256 returned 100% blocks executed 100%
      256: 1883:FUNC(is_punct, ISPUNCT)
function is_alnum called 2816 returned 100% blocks executed 100%
     2816: 1884:FUNC(is_alnum, ISALNUM)
function is_print called 256 returned 100% blocks executed 100%
      256: 1885:FUNC(is_print, ISPRINT)
function is_graph called 256 returned 100% blocks executed 100%
      256: 1886:FUNC(is_graph, ISGRAPH)
function is_cntrl called 256 returned 100% blocks executed 100%
      256: 1887:FUNC(is_cntrl, ISCNTRL)
        -: 1888:
        -: 1889:static int
function is_blank called 0 returned 0% blocks executed 0%
    #####: 1890:is_blank (int c)
        -: 1891:{
    #####: 1892:   return (c == ' ' || c == '\t');
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 1893:}
        -: 1894:
        -: 1895:/* The following list maps the names of the Posix named character classes
        -: 1896:   to predicate functions that determine whether a given character is in
        -: 1897:   the class.  The leading [ has already been eaten by the lexical analyzer. */
        -: 1898:static struct {
        -: 1899:  const char *name;
        -: 1900:  int (*pred) PARAMS ((int));
        -: 1901:} prednames[] = {
        -: 1902:  { ":alpha:]", is_alpha },
        -: 1903:  { ":upper:]", is_upper },
        -: 1904:  { ":lower:]", is_lower },
        -: 1905:  { ":digit:]", is_digit },
        -: 1906:  { ":xdigit:]", is_xdigit },
        -: 1907:  { ":space:]", is_space },
        -: 1908:  { ":punct:]", is_punct },
        -: 1909:  { ":alnum:]", is_alnum },
        -: 1910:  { ":print:]", is_print },
        -: 1911:  { ":graph:]", is_graph },
        -: 1912:  { ":cntrl:]", is_cntrl },
        -: 1913:  { ":blank:]", is_blank },
        -: 1914:  { 0 }
        -: 1915:};
        -: 1916:
        -: 1917:/* Return non-zero if C is a `word-constituent' byte; zero otherwise.  */
        -: 1918:#define IS_WORD_CONSTITUENT(C) (ISALNUM(C) || (C) == '_')
        -: 1919:
        -: 1920:static int
function looking_at called 146 returned 100% blocks executed 75%
      146: 1921:looking_at (char const *s)
        -: 1922:{
        -: 1923:  size_t len;
        -: 1924:
      146: 1925:  len = strlen(s);
      146: 1926:  if (lexleft < len)
branch  0 taken 0 (fallthrough)
branch  1 taken 146
    #####: 1927:    return 0;
      146: 1928:  return strncmp(s, lexptr, len) == 0;
        -: 1929:}
        -: 1930:
        -: 1931:static token
function lex called 8019 returned 100% blocks executed 75%
     8019: 1932:lex (void)
        -: 1933:{
        -: 1934:  token c, c1, c2;
     8019: 1935:  int backslash = 0, invert;
        -: 1936:  charclass ccl;
        -: 1937:  int i;
        -: 1938:  char lo[2];
        -: 1939:  char hi[2];
        -: 1940:
        -: 1941:  /* Basic plan: We fetch a character.  If it's a backslash,
        -: 1942:     we set the backslash flag and go through the loop again.
        -: 1943:     On the plus side, this avoids having a duplicate of the
        -: 1944:     main switch inside the backslash case.  On the minus side,
        -: 1945:     it means that just about every case begins with
        -: 1946:     "if (backslash) ...".  */
     8970: 1947:  for (i = 0; i < 2; ++i)
branch  0 taken 8970
branch  1 taken 0 (fallthrough)
        -: 1948:    {
     8970: 1949:      FETCH(c, 0);
branch  0 taken 780 (fallthrough)
branch  1 taken 8190
     8190: 1950:      switch (c)
branch  0 taken 951
branch  1 taken 122
branch  2 taken 15
branch  3 taken 132
branch  4 taken 3
branch  5 taken 7
branch  6 taken 115
branch  7 taken 4
branch  8 taken 159
branch  9 taken 3
branch 10 taken 247
branch 11 taken 40
branch 12 taken 183
branch 13 taken 185
branch 14 taken 287
branch 15 taken 3
branch 16 taken 283
branch 17 taken 112
branch 18 taken 94
branch 19 taken 9
branch 20 taken 65
branch 21 taken 5171
        -: 1951:	{
      951: 1952:	case '\\':
      951: 1953:	  if (backslash)
branch  0 taken 0 (fallthrough)
branch  1 taken 951
    #####: 1954:	    goto normal_char;
      951: 1955:	  if (lexleft == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 951
    #####: 1956:	    dfaerror(_("Unfinished \\ escape"));
call    0 never executed
      951: 1957:	  backslash = 1;
      951: 1958:	  break;
        -: 1959:
      122: 1960:	case '^':
      122: 1961:	  if (backslash)
branch  0 taken 3 (fallthrough)
branch  1 taken 119
        3: 1962:	    goto normal_char;
      119: 1963:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
branch  0 taken 59 (fallthrough)
branch  1 taken 60
       59: 1964:	      || lasttok == END
branch  0 taken 28 (fallthrough)
branch  1 taken 31
       28: 1965:	      || lasttok == LPAREN
branch  0 taken 21 (fallthrough)
branch  1 taken 7
       21: 1966:	      || lasttok == OR)
branch  0 taken 20 (fallthrough)
branch  1 taken 1
      118: 1967:	    return lasttok = BEGLINE;
        1: 1968:	  goto normal_char;
        -: 1969:
       15: 1970:	case '$':
       15: 1971:	  if (backslash)
branch  0 taken 3 (fallthrough)
branch  1 taken 12
        3: 1972:	    goto normal_char;
       12: 1973:	  if (syntax_bits & RE_CONTEXT_INDEP_ANCHORS
branch  0 taken 11 (fallthrough)
branch  1 taken 1
       11: 1974:	      || lexleft == 0
branch  0 taken 6 (fallthrough)
branch  1 taken 5
      12*: 1975:	      || (syntax_bits & RE_NO_BK_PARENS
branch  0 taken 0 (fallthrough)
branch  1 taken 6
branch  2 never executed
branch  3 never executed
branch  4 taken 5 (fallthrough)
branch  5 taken 1
    #####: 1976:		  ? lexleft > 0 && *lexptr == ')'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        6: 1977:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == ')')
branch  0 taken 5 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 4
branch  4 taken 1 (fallthrough)
branch  5 taken 0
      10*: 1978:	      || (syntax_bits & RE_NO_BK_VBAR
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 never executed
branch  3 never executed
branch  4 taken 5 (fallthrough)
branch  5 taken 0
    #####: 1979:		  ? lexleft > 0 && *lexptr == '|'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
       5*: 1980:		  : lexleft > 1 && lexptr[0] == '\\' && lexptr[1] == '|')
branch  0 taken 4 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 4
branch  4 never executed
branch  5 never executed
        5: 1981:	      || ((syntax_bits & RE_NEWLINE_ALT)
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        5: 1982:	          && lexleft > 0 && *lexptr == '\n'))
branch  0 taken 5 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 5
        7: 1983:	    return lasttok = ENDLINE;
        5: 1984:	  goto normal_char;
        -: 1985:
      132: 1986:	case '1':
        -: 1987:	case '2':
        -: 1988:	case '3':
        -: 1989:	case '4':
        -: 1990:	case '5':
        -: 1991:	case '6':
        -: 1992:	case '7':
        -: 1993:	case '8':
        -: 1994:	case '9':
     132*: 1995:	  if (backslash && !(syntax_bits & RE_NO_BK_REFS))
branch  0 taken 0 (fallthrough)
branch  1 taken 132
branch  2 never executed
branch  3 never executed
        -: 1996:	    {
    #####: 1997:	      laststart = 0;
    #####: 1998:	      return lasttok = BACKREF;
        -: 1999:	    }
      132: 2000:	  goto normal_char;
        -: 2001:
        3: 2002:	case '`':
        3: 2003:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
branch  0 taken 3 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3: 2004:	    return lasttok = BEGLINE;	/* FIXME: should be beginning of string */
    #####: 2005:	  goto normal_char;
        -: 2006:
        7: 2007:	case '\'':
        7: 2008:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
branch  0 taken 3 (fallthrough)
branch  1 taken 4
branch  2 taken 3 (fallthrough)
branch  3 taken 0
        3: 2009:	    return lasttok = ENDLINE;	/* FIXME: should be end of string */
        4: 2010:	  goto normal_char;
        -: 2011:
      115: 2012:	case '<':
      115: 2013:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
branch  0 taken 114 (fallthrough)
branch  1 taken 1
branch  2 taken 114 (fallthrough)
branch  3 taken 0
      114: 2014:	    return lasttok = BEGWORD;
        1: 2015:	  goto normal_char;
        -: 2016:
        4: 2017:	case '>':
        4: 2018:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
branch  0 taken 1 (fallthrough)
branch  1 taken 3
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 2019:	    return lasttok = ENDWORD;
        3: 2020:	  goto normal_char;
        -: 2021:
      159: 2022:	case 'b':
      159: 2023:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
branch  0 taken 140 (fallthrough)
branch  1 taken 19
branch  2 taken 140 (fallthrough)
branch  3 taken 0
      140: 2024:	    return lasttok = LIMWORD;
       19: 2025:	  goto normal_char;
        -: 2026:
        3: 2027:	case 'B':
        3: 2028:	  if (backslash && !(syntax_bits & RE_NO_GNU_OPS))
branch  0 taken 1 (fallthrough)
branch  1 taken 2
branch  2 taken 1 (fallthrough)
branch  3 taken 0
        1: 2029:	    return lasttok = NOTLIMWORD;
        2: 2030:	  goto normal_char;
        -: 2031:
      247: 2032:	case '?':
      247: 2033:	  if (syntax_bits & RE_LIMITED_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 247
    #####: 2034:	    goto normal_char;
      247: 2035:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
branch  0 taken 72 (fallthrough)
branch  1 taken 175
       72: 2036:	    goto normal_char;
      175: 2037:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
branch  0 taken 87 (fallthrough)
branch  1 taken 88
branch  2 taken 1 (fallthrough)
branch  3 taken 86
        1: 2038:	    goto normal_char;
      174: 2039:	  return lasttok = QMARK;
        -: 2040:
       40: 2041:	case '*':
       40: 2042:	  if (backslash)
branch  0 taken 26 (fallthrough)
branch  1 taken 14
       26: 2043:	    goto normal_char;
       14: 2044:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
branch  0 taken 13 (fallthrough)
branch  1 taken 1
branch  2 taken 3 (fallthrough)
branch  3 taken 10
        3: 2045:	    goto normal_char;
       11: 2046:	  return lasttok = STAR;
        -: 2047:
      183: 2048:	case '+':
      183: 2049:	  if (syntax_bits & RE_LIMITED_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 183
    #####: 2050:	    goto normal_char;
      183: 2051:	  if (backslash != ((syntax_bits & RE_BK_PLUS_QM) != 0))
branch  0 taken 3 (fallthrough)
branch  1 taken 180
        3: 2052:	    goto normal_char;
      180: 2053:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
branch  0 taken 92 (fallthrough)
branch  1 taken 88
branch  2 taken 1 (fallthrough)
branch  3 taken 91
        1: 2054:	    goto normal_char;
      179: 2055:	  return lasttok = PLUS;
        -: 2056:
      185: 2057:	case '{':
      185: 2058:	  if (!(syntax_bits & RE_INTERVALS))
branch  0 taken 0 (fallthrough)
branch  1 taken 185
    #####: 2059:	    goto normal_char;
      185: 2060:	  if (backslash != ((syntax_bits & RE_NO_BK_BRACES) == 0))
branch  0 taken 3 (fallthrough)
branch  1 taken 182
        3: 2061:	    goto normal_char;
      182: 2062:	  if (!(syntax_bits & RE_CONTEXT_INDEP_OPS) && laststart)
branch  0 taken 91 (fallthrough)
branch  1 taken 91
branch  2 taken 1 (fallthrough)
branch  3 taken 90
        1: 2063:	    goto normal_char;
        -: 2064:
      181: 2065:	  if (syntax_bits & RE_NO_BK_BRACES)
branch  0 taken 91 (fallthrough)
branch  1 taken 90
        -: 2066:	    {
        -: 2067:	      /* Scan ahead for a valid interval; if it's not valid,
        -: 2068:		 treat it as a literal '{'.  */
       91: 2069:	      int lo = -1, hi = -1;
       91: 2070:	      char const *p = lexptr;
       91: 2071:	      char const *lim = p + lexleft;
      181: 2072:	      for (;  p != lim && ISASCIIDIGIT (*p);  p++)
branch  0 taken 181 (fallthrough)
branch  1 taken 0
branch  2 taken 90
branch  3 taken 91 (fallthrough)
      90*: 2073:		lo = (lo < 0 ? 0 : lo * 10) + *p - '0';
branch  0 taken 0 (fallthrough)
branch  1 taken 90
       91: 2074:	      if (p != lim && *p == ',')
branch  0 taken 91 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 88
        5: 2075:		while (++p != lim && ISASCIIDIGIT (*p))
branch  0 taken 5 (fallthrough)
branch  1 taken 0
branch  2 taken 2
branch  3 taken 3 (fallthrough)
       2*: 2076:		  hi = (hi < 0 ? 0 : hi * 10) + *p - '0';
branch  0 taken 0 (fallthrough)
branch  1 taken 2
        -: 2077:	      else
       88: 2078:		hi = lo;
       91: 2079:	      if (p == lim || *p != '}'
branch  0 taken 91 (fallthrough)
branch  1 taken 0
branch  2 taken 91 (fallthrough)
branch  3 taken 0
       91: 2080:		  || lo < 0 || RE_DUP_MAX < hi || (0 <= hi && hi < lo))
branch  0 taken 90 (fallthrough)
branch  1 taken 1
branch  2 taken 90 (fallthrough)
branch  3 taken 0
branch  4 taken 89 (fallthrough)
branch  5 taken 1
branch  6 taken 0 (fallthrough)
branch  7 taken 89
        1: 2081:		goto normal_char;
        -: 2082:	    }
        -: 2083:
      180: 2084:	  minrep = 0;
        -: 2085:	  /* Cases:
        -: 2086:	     {M} - exact count
        -: 2087:	     {M,} - minimum count, maximum is infinity
        -: 2088:	     {M,N} - M through N */
     180*: 2089:	  FETCH(c, _("unfinished repeat count"));
branch  0 taken 0 (fallthrough)
branch  1 taken 180
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2090:#ifndef FAULTY_F_KP_8
      180: 2091:	  if (ISASCIIDIGIT (c))
branch  0 taken 180 (fallthrough)
branch  1 taken 0
        -: 2092:	    {
      180: 2093:	      minrep = c - '0';
        -: 2094:	      for (;;)
        -: 2095:		{
     183*: 2096:		  FETCH(c, _("unfinished repeat count"));
branch  0 taken 0 (fallthrough)
branch  1 taken 183
branch  2 never executed
branch  3 never executed
call    4 never executed
      183: 2097:		  if (! ISASCIIDIGIT (c))
branch  0 taken 180 (fallthrough)
branch  1 taken 3
        -: 2098:#else
        -: 2099:	  if (! ISASCIIDIGIT (c))
        -: 2100:	    {
        -: 2101:	      minrep = c - '0';
        -: 2102:	      for (;;)
        -: 2103:		{
        -: 2104:		  FETCH(c, _("unfinished repeat count"));
        -: 2105:		  if (ISASCIIDIGIT (c))
        -: 2106:#endif
      180: 2107:		    break;
        3: 2108:		  minrep = 10 * minrep + c - '0';
        -: 2109:		}
        -: 2110:	    }
        -: 2111:	  else
    #####: 2112:	    dfaerror(_("malformed repeat count"));
call    0 never executed
      180: 2113:	  if (c == ',')
branch  0 taken 8 (fallthrough)
branch  1 taken 172
        -: 2114:	    {
       8*: 2115:	      FETCH (c, _("unfinished repeat count"));
branch  0 taken 0 (fallthrough)
branch  1 taken 8
branch  2 never executed
branch  3 never executed
call    4 never executed
        8: 2116:	      if (! ISASCIIDIGIT (c))
branch  0 taken 1 (fallthrough)
branch  1 taken 7
        1: 2117:		maxrep = -1;
        -: 2118:	      else
        -: 2119:		{
        7: 2120:		  maxrep = c - '0';
        -: 2121:		  for (;;)
        -: 2122:		    {
      10*: 2123:		      FETCH (c, _("unfinished repeat count"));
branch  0 taken 0 (fallthrough)
branch  1 taken 10
branch  2 never executed
branch  3 never executed
call    4 never executed
       10: 2124:		      if (! ISASCIIDIGIT (c))
branch  0 taken 7 (fallthrough)
branch  1 taken 3
        7: 2125:			break;
        3: 2126:		      maxrep = 10 * maxrep + c - '0';
        -: 2127:		    }
        7: 2128:		  if (0 <= maxrep && maxrep < minrep)
branch  0 taken 7 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 7
    #####: 2129:		    dfaerror (_("malformed repeat count"));
call    0 never executed
        -: 2130:		}
        -: 2131:	    }
        -: 2132:	  else
      172: 2133:	    maxrep = minrep;
      180: 2134:	  if (!(syntax_bits & RE_NO_BK_BRACES))
branch  0 taken 90 (fallthrough)
branch  1 taken 90
        -: 2135:	    {
       90: 2136:	      if (c != '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 90
    #####: 2137:		dfaerror(_("malformed repeat count"));
call    0 never executed
      90*: 2138:	      FETCH(c, _("unfinished repeat count"));
branch  0 taken 0 (fallthrough)
branch  1 taken 90
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2139:	    }
      180: 2140:	  if (c != '}')
branch  0 taken 0 (fallthrough)
branch  1 taken 180
    #####: 2141:	    dfaerror(_("malformed repeat count"));
call    0 never executed
      180: 2142:	  laststart = 0;
      180: 2143:	  return lasttok = REPMN;
        -: 2144:
      287: 2145:	case '|':
      287: 2146:	  if (syntax_bits & RE_LIMITED_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 287
    #####: 2147:	    goto normal_char;
      287: 2148:	  if (backslash != ((syntax_bits & RE_NO_BK_VBAR) == 0))
branch  0 taken 8 (fallthrough)
branch  1 taken 279
        8: 2149:	    goto normal_char;
      279: 2150:	  laststart = 1;
      279: 2151:	  return lasttok = OR;
        -: 2152:
        3: 2153:	case '\n':
        3: 2154:	  if (syntax_bits & RE_LIMITED_OPS
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 2155:	      || backslash
branch  0 taken 3 (fallthrough)
branch  1 taken 0
        3: 2156:	      || !(syntax_bits & RE_NEWLINE_ALT))
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 2157:	    goto normal_char;
        3: 2158:	  laststart = 1;
        3: 2159:	  return lasttok = OR;
        -: 2160:
      283: 2161:	case '(':
      283: 2162:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
branch  0 taken 173 (fallthrough)
branch  1 taken 110
      173: 2163:	    goto normal_char;
      110: 2164:	  ++parens;
      110: 2165:	  laststart = 1;
      110: 2166:	  return lasttok = LPAREN;
        -: 2167:
      112: 2168:	case ')':
      112: 2169:	  if (backslash != ((syntax_bits & RE_NO_BK_PARENS) == 0))
branch  0 taken 2 (fallthrough)
branch  1 taken 110
        2: 2170:	    goto normal_char;
     110*: 2171:	  if (parens == 0 && syntax_bits & RE_UNMATCHED_RIGHT_PAREN_ORD)
branch  0 taken 0 (fallthrough)
branch  1 taken 110
branch  2 never executed
branch  3 never executed
    #####: 2172:	    goto normal_char;
      110: 2173:	  --parens;
      110: 2174:	  laststart = 0;
      110: 2175:	  return lasttok = RPAREN;
        -: 2176:
       94: 2177:	case '.':
       94: 2178:	  if (backslash)
branch  0 taken 3 (fallthrough)
branch  1 taken 91
        3: 2179:	    goto normal_char;
       91: 2180:	  zeroset(ccl);
call    0 returned 91
       91: 2181:	  notset(ccl);
call    0 returned 91
       91: 2182:	  if (!(syntax_bits & RE_DOT_NEWLINE))
branch  0 taken 91 (fallthrough)
branch  1 taken 0
       91: 2183:	    clrbit(eolbyte_1, ccl);
call    0 returned 91
       91: 2184:	  if (syntax_bits & RE_DOT_NOT_NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 91
    #####: 2185:	    clrbit('\0', ccl);
call    0 never executed
       91: 2186:	  laststart = 0;
       91: 2187:	  return lasttok = CSET + charclass_index(ccl);
call    0 returned 91
        -: 2188:
        9: 2189:	case 'w':
        -: 2190:	case 'W':
        9: 2191:	  if (!backslash || (syntax_bits & RE_NO_GNU_OPS))
branch  0 taken 4 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 4
        5: 2192:	    goto normal_char;
        4: 2193:	  zeroset(ccl);
call    0 returned 4
     1028: 2194:	  for (c2 = 0; c2 < NOTCHAR; ++c2)
branch  0 taken 1024
branch  1 taken 4 (fallthrough)
     1024: 2195:	    if (IS_WORD_CONSTITUENT(c2))
branch  0 taken 776 (fallthrough)
branch  1 taken 248
branch  2 taken 4 (fallthrough)
branch  3 taken 772
      252: 2196:	      setbit(c2, ccl);
call    0 returned 252
        4: 2197:	  if (c == 'W')
branch  0 taken 3 (fallthrough)
branch  1 taken 1
        3: 2198:	    notset(ccl);
call    0 returned 3
        4: 2199:	  laststart = 0;
        4: 2200:	  return lasttok = CSET + charclass_index(ccl);
call    0 returned 4
        -: 2201:
       65: 2202:	case '[':
       65: 2203:	  if (backslash)
branch  0 taken 3 (fallthrough)
branch  1 taken 62
        3: 2204:	    goto normal_char;
       62: 2205:	  zeroset(ccl);
call    0 returned 62
      62*: 2206:	  FETCH(c, _("Unbalanced ["));
branch  0 taken 0 (fallthrough)
branch  1 taken 62
branch  2 never executed
branch  3 never executed
call    4 never executed
       62: 2207:	  if (c == '^')
branch  0 taken 9 (fallthrough)
branch  1 taken 53
        -: 2208:	    {
       9*: 2209:	      FETCH(c, _("Unbalanced ["));
branch  0 taken 0 (fallthrough)
branch  1 taken 9
branch  2 never executed
branch  3 never executed
call    4 never executed
        9: 2210:	      invert = 1;
        -: 2211:	    }
        -: 2212:	  else
       53: 2213:	    invert = 0;
        -: 2214:	  do
        -: 2215:	    {
        -: 2216:	      /* Nobody ever said this had to be fast. :-)
        -: 2217:		 Note that if we're looking at some other [:...:]
        -: 2218:		 construct, we just treat it as a bunch of ordinary
        -: 2219:		 characters.  We can do this because we assume
        -: 2220:		 regex has checked for syntax errors before
        -: 2221:		 dfa is ever called. */
      105: 2222:	      if (c == '[' && (syntax_bits & RE_CHAR_CLASSES))
branch  0 taken 21 (fallthrough)
branch  1 taken 84
branch  2 taken 21 (fallthrough)
branch  3 taken 0
      146: 2223:		for (c1 = 0; prednames[c1].name; ++c1)
branch  0 taken 146
branch  1 taken 0 (fallthrough)
      146: 2224:		  if (looking_at(prednames[c1].name))
call    0 returned 146
branch  1 taken 21 (fallthrough)
branch  2 taken 125
        -: 2225:		    {
       21: 2226:			int (*pred)() = prednames[c1].pred;
       21: 2227:			if (case_fold
branch  0 taken 0 (fallthrough)
branch  1 taken 21
    #####: 2228:			    && (pred == is_upper || pred == is_lower))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 2229:				pred = is_alpha;
        -: 2230:
     5397: 2231:		      for (c2 = 0; c2 < NOTCHAR; ++c2)
branch  0 taken 5376
branch  1 taken 21 (fallthrough)
     5376: 2232:			if ((*pred)(c2))
call    0 returned 5376
branch  1 taken 1078 (fallthrough)
branch  2 taken 4298
     1078: 2233:			  setbit(c2, ccl);
call    0 returned 1078
       21: 2234:		      lexptr += strlen(prednames[c1].name);
       21: 2235:		      lexleft -= strlen(prednames[c1].name);
      21*: 2236:		      FETCH(c1, _("Unbalanced ["));
branch  0 taken 0 (fallthrough)
branch  1 taken 21
branch  2 never executed
branch  3 never executed
call    4 never executed
       21: 2237:		      goto skip;
        -: 2238:		    }
      84*: 2239:	      if (c == '\\' && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
branch  0 taken 0 (fallthrough)
branch  1 taken 84
branch  2 never executed
branch  3 never executed
    #####: 2240:		FETCH(c, _("Unbalanced ["));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
      84*: 2241:	      FETCH(c1, _("Unbalanced ["));
branch  0 taken 0 (fallthrough)
branch  1 taken 84
branch  2 never executed
branch  3 never executed
call    4 never executed
       84: 2242:	      if (c1 == '-')
branch  0 taken 20 (fallthrough)
branch  1 taken 64
        -: 2243:		{
      20*: 2244:		  FETCH(c2, _("Unbalanced ["));
branch  0 taken 0 (fallthrough)
branch  1 taken 20
branch  2 never executed
branch  3 never executed
call    4 never executed
       20: 2245:		  if (c2 == ']')
branch  0 taken 4 (fallthrough)
branch  1 taken 16
        -: 2246:		    {
        -: 2247:		      /* In the case [x-], the - is an ordinary hyphen,
        -: 2248:			 which is left in c1, the lookahead character. */
        4: 2249:		      --lexptr;
        4: 2250:		      ++lexleft;
        4: 2251:		      c2 = c;
        -: 2252:		    }
        -: 2253:		  else
        -: 2254:		    {
       16: 2255:		      if (c2 == '\\'
branch  0 taken 0 (fallthrough)
branch  1 taken 16
    #####: 2256:			  && (syntax_bits & RE_BACKSLASH_ESCAPE_IN_LISTS))
branch  0 never executed
branch  1 never executed
    #####: 2257:			FETCH(c2, _("Unbalanced ["));
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
      16*: 2258:		      FETCH(c1, _("Unbalanced ["));
branch  0 taken 0 (fallthrough)
branch  1 taken 16
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2259:		    }
        -: 2260:		}
        -: 2261:	      else
       64: 2262:		c2 = c;
        -: 2263:
       84: 2264:	      lo[0] = c;  lo[1] = '\0';
       84: 2265:	      hi[0] = c2; hi[1] = '\0';
    21588: 2266:	      for (c = 0; c < NOTCHAR; c++)
branch  0 taken 21504
branch  1 taken 84 (fallthrough)
        -: 2267:		{
        -: 2268:		  char ch[2];
    21504: 2269:		  ch[0] = c;  ch[1] = '\0';
        -: 2270:                  #ifndef FAULTY_F_DG_3
    21504: 2271:		  if (strcoll (lo, ch) <= 0 && strcoll (ch, hi) <= 0)
branch  0 taken 3918 (fallthrough)
branch  1 taken 17586
branch  2 taken 482 (fallthrough)
branch  3 taken 3436
        -: 2272:                  #else
        -: 2273:		  if (strcoll (ch, lo) <= 0 && strcoll (hi, ch) <= 0)
        -: 2274:                  #endif
        -: 2275:		    {
      482: 2276:		      setbit (c, ccl);
call    0 returned 482
      482: 2277:		      if (case_fold)
branch  0 taken 97 (fallthrough)
branch  1 taken 385
        -: 2278:			{
       97: 2279:			  if (ISUPPER (c))
branch  0 taken 47 (fallthrough)
branch  1 taken 50
       47: 2280:			    setbit (tolower (c), ccl);
call    0 returned 47
       50: 2281:			  else if (ISLOWER (c))
branch  0 taken 47 (fallthrough)
branch  1 taken 3
       47: 2282:			    setbit (toupper (c), ccl);
call    0 returned 47
        -: 2283:			}
        -: 2284:		    }
        -: 2285:		}
        -: 2286:
       84: 2287:	    skip:
        -: 2288:	      ;
        -: 2289:	    }
      105: 2290:	  while ((c = c1) != ']');
branch  0 taken 43
branch  1 taken 62 (fallthrough)
       62: 2291:	  if (invert)
branch  0 taken 9 (fallthrough)
branch  1 taken 53
        -: 2292:	    {
        9: 2293:	      notset(ccl);
call    0 returned 9
        9: 2294:	      if (syntax_bits & RE_HAT_LISTS_NOT_NEWLINE)
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9: 2295:		clrbit(eolbyte_1, ccl);
call    0 returned 9
        -: 2296:	    }
       62: 2297:	  laststart = 0;
       62: 2298:	  return lasttok = CSET + charclass_index(ccl);
call    0 returned 62
        -: 2299:
        -: 2300:	default:
     5649: 2301:	normal_char:
     5649: 2302:	  laststart = 0;
     5649: 2303:	  if (case_fold && ISALPHA(c))
branch  0 taken 369 (fallthrough)
branch  1 taken 5280
branch  2 taken 359 (fallthrough)
branch  3 taken 10
        -: 2304:	    {
      359: 2305:	      zeroset(ccl);
call    0 returned 359
      359: 2306:	      setbit(c, ccl);
call    0 returned 359
      359: 2307:	      if (isupper(c))
branch  0 taken 24 (fallthrough)
branch  1 taken 335
       24: 2308:		setbit(tolower(c), ccl);
call    0 returned 24
        -: 2309:	      else
      335: 2310:		setbit(toupper(c), ccl);
call    0 returned 335
      359: 2311:	      return lasttok = CSET + charclass_index(ccl);
call    0 returned 359
        -: 2312:	    }
     5290: 2313:	  return c;
        -: 2314:	}
        -: 2315:    }
        -: 2316:
        -: 2317:  /* The above loop should consume at most a backslash
        -: 2318:     and some other character. */
    #####: 2319:  abort();
call    0 never executed
        -: 2320:  return END;	/* keeps pedantic compilers happy. */
        -: 2321:}
        -: 2322:
        -: 2323:/* Recursive descent parser for regular expressions. */
        -: 2324:
        -: 2325:static token tok;		/* Lookahead token. */
        -: 2326:static int depth;		/* Current depth of a hypothetical stack
        -: 2327:				   holding deferred productions.  This is
        -: 2328:				   used to determine the depth that will be
        -: 2329:				   required of the real stack later on in
        -: 2330:				   dfaanalyze(). */
        -: 2331:
        -: 2332:/* Add the given token to the parse tree, maintaining the depth count and
        -: 2333:   updating the maximum depth if necessary. */
        -: 2334:static void
function addtok called 13764 returned 100% blocks executed 100%
    13764: 2335:addtok (token t)
        -: 2336:{
    16841: 2337:  REALLOC_IF_NECESSARY(dfa->tokens, token, dfa->talloc, dfa->tindex);
branch  0 taken 3077 (fallthrough)
branch  1 taken 10687
branch  2 taken 3077
branch  3 taken 3077 (fallthrough)
call    4 returned 3077
    13764: 2338:  dfa->tokens[dfa->tindex++] = t;
        -: 2339:
    13764: 2340:  switch (t)
branch  0 taken 378
branch  1 taken 6303
branch  2 taken 7011
branch  3 taken 72
        -: 2341:    {
      378: 2342:    case QMARK:
        -: 2343:    case STAR:
        -: 2344:    case PLUS:
      378: 2345:      break;
        -: 2346:
     6303: 2347:    case CAT:
        -: 2348:    case OR:
        -: 2349:    case ORTOP:
     6303: 2350:      --depth;
     6303: 2351:      break;
        -: 2352:
     7011: 2353:    default:
     7011: 2354:      ++dfa->nleaves;
     7083: 2355:    case EMPTY:
     7083: 2356:      ++depth;
     7083: 2357:      break;
        -: 2358:    }
    13764: 2359:  if (depth > dfa->depth)
branch  0 taken 1868 (fallthrough)
branch  1 taken 11896
     1868: 2360:    dfa->depth = depth;
    13764: 2361:}
        -: 2362:
        -: 2363:/* The grammar understood by the parser is as follows.
        -: 2364:
        -: 2365:   regexp:
        -: 2366:     regexp OR branch
        -: 2367:     branch
        -: 2368:
        -: 2369:   branch:
        -: 2370:     branch closure
        -: 2371:     closure
        -: 2372:
        -: 2373:   closure:
        -: 2374:     closure QMARK
        -: 2375:     closure STAR
        -: 2376:     closure PLUS
        -: 2377:     atom
        -: 2378:
        -: 2379:   atom:
        -: 2380:     <normal character>
        -: 2381:     CSET
        -: 2382:     BACKREF
        -: 2383:     BEGLINE
        -: 2384:     ENDLINE
        -: 2385:     BEGWORD
        -: 2386:     ENDWORD
        -: 2387:     LIMWORD
        -: 2388:     NOTLIMWORD
        -: 2389:     <empty>
        -: 2390:
        -: 2391:   The parser builds a parse tree in postfix form in an array of tokens. */
        -: 2392:
        -: 2393:static void
function atom called 6375 returned 100% blocks executed 95%
     6375: 2394:atom (void)
        -: 2395:{
     6375: 2396:  if ((tok >= 0 && tok < NOTCHAR) || tok >= CSET || tok == BACKREF
branch  0 taken 6366 (fallthrough)
branch  1 taken 9
branch  2 taken 1076 (fallthrough)
branch  3 taken 5290
branch  4 taken 569 (fallthrough)
branch  5 taken 516
branch  6 taken 569 (fallthrough)
branch  7 taken 0
      569: 2397:      || tok == BEGLINE || tok == ENDLINE || tok == BEGWORD
branch  0 taken 448 (fallthrough)
branch  1 taken 121
branch  2 taken 438 (fallthrough)
branch  3 taken 10
branch  4 taken 324 (fallthrough)
branch  5 taken 114
      324: 2398:      || tok == ENDWORD || tok == LIMWORD || tok == NOTLIMWORD)
branch  0 taken 323 (fallthrough)
branch  1 taken 1
branch  2 taken 183 (fallthrough)
branch  3 taken 140
branch  4 taken 1 (fallthrough)
branch  5 taken 182
        -: 2399:    {
     6193: 2400:      addtok(tok);
call    0 returned 6193
     6193: 2401:      tok = lex();
call    0 returned 6193
        -: 2402:    }
      182: 2403:  else if (tok == LPAREN)
branch  0 taken 110 (fallthrough)
branch  1 taken 72
        -: 2404:    {
      110: 2405:      tok = lex();
call    0 returned 110
      110: 2406:      regexp(0);
call    0 returned 110
      110: 2407:      if (tok != RPAREN)
branch  0 taken 0 (fallthrough)
branch  1 taken 110
    #####: 2408:	dfaerror(_("Unbalanced ("));
call    0 never executed
      110: 2409:      tok = lex();
call    0 returned 110
        -: 2410:    }
        -: 2411:  else
       72: 2412:    addtok(EMPTY);
call    0 returned 72
     6375: 2413:}
        -: 2414:
        -: 2415:/* Return the number of tokens in the given subexpression. */
        -: 2416:static int
function nsubtoks called 255 returned 100% blocks executed 100%
      255: 2417:nsubtoks (int tindex)
        -: 2418:{
        -: 2419:  int ntoks1;
        -: 2420:
      255: 2421:  switch (dfa->tokens[tindex - 1])
branch  0 taken 213
branch  1 taken 9
branch  2 taken 33
        -: 2422:    {
      213: 2423:    default:
      213: 2424:      return 1;
        9: 2425:    case QMARK:
        -: 2426:    case STAR:
        -: 2427:    case PLUS:
        9: 2428:      return 1 + nsubtoks(tindex - 1);
call    0 returned 9
       33: 2429:    case CAT:
        -: 2430:    case OR:
        -: 2431:    case ORTOP:
       33: 2432:      ntoks1 = nsubtoks(tindex - 1);
call    0 returned 33
       33: 2433:      return 1 + ntoks1 + nsubtoks(tindex - 1 - ntoks1);
call    0 returned 33
        -: 2434:    }
        -: 2435:}
        -: 2436:
        -: 2437:/* Copy the given subexpression to the top of the tree. */
        -: 2438:static void
function copytoks called 38 returned 100% blocks executed 100%
       38: 2439:copytoks (int tindex, int ntokens)
        -: 2440:{
        -: 2441:  int i;
        -: 2442:
       76: 2443:  for (i = 0; i < ntokens; ++i)
branch  0 taken 38
branch  1 taken 38 (fallthrough)
       38: 2444:    addtok(dfa->tokens[tindex + i]);
call    0 returned 38
       38: 2445:}
        -: 2446:
        -: 2447:static void
function closure called 6375 returned 100% blocks executed 100%
     6375: 2448:closure (void)
        -: 2449:{
        -: 2450:  int tindex, ntokens, i;
        -: 2451:
     6375: 2452:  atom();
call    0 returned 6375
     6919: 2453:  while (tok == QMARK || tok == STAR || tok == PLUS || tok == REPMN)
branch  0 taken 174
branch  1 taken 6745 (fallthrough)
branch  2 taken 11
branch  3 taken 6734 (fallthrough)
branch  4 taken 179
branch  5 taken 6555 (fallthrough)
branch  6 taken 180
branch  7 taken 6375 (fallthrough)
      544: 2454:    if (tok == REPMN)
branch  0 taken 180 (fallthrough)
branch  1 taken 364
        -: 2455:      {
      180: 2456:	ntokens = nsubtoks(dfa->tindex);
call    0 returned 180
      180: 2457:	tindex = dfa->tindex - ntokens;
      180: 2458:	if (maxrep < 0)
branch  0 taken 1 (fallthrough)
branch  1 taken 179
        1: 2459:	  addtok(PLUS);
call    0 returned 1
      180: 2460:	if (minrep == 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 177
        3: 2461:	  addtok(QMARK);
call    0 returned 3
      208: 2462:	for (i = 1; i < minrep; ++i)
branch  0 taken 28
branch  1 taken 180 (fallthrough)
        -: 2463:	  {
       28: 2464:	    copytoks(tindex, ntokens);
call    0 returned 28
       28: 2465:	    addtok(CAT);
call    0 returned 28
        -: 2466:	  }
      190: 2467:	for (; i < maxrep; ++i)
branch  0 taken 10
branch  1 taken 180 (fallthrough)
        -: 2468:	  {
       10: 2469:	    copytoks(tindex, ntokens);
call    0 returned 10
       10: 2470:	    addtok(QMARK);
call    0 returned 10
       10: 2471:	    addtok(CAT);
call    0 returned 10
        -: 2472:	  }
      180: 2473:	tok = lex();
call    0 returned 180
        -: 2474:      }
        -: 2475:    else
        -: 2476:      {
      364: 2477:	addtok(tok);
call    0 returned 364
      364: 2478:	tok = lex();
call    0 returned 364
        -: 2479:      }
     6375: 2480:}
        -: 2481:
        -: 2482:static void
function branch called 1172 returned 100% blocks executed 100%
     1172: 2483:branch (void)
        -: 2484:{
     1172: 2485:  closure();
call    0 returned 1172
     6375: 2486:  while (tok != RPAREN && tok != OR && tok >= 0)
branch  0 taken 6265 (fallthrough)
branch  1 taken 110
branch  2 taken 5983 (fallthrough)
branch  3 taken 282
branch  4 taken 5203
branch  5 taken 780 (fallthrough)
        -: 2487:    {
     5203: 2488:      closure();
call    0 returned 5203
     5203: 2489:      addtok(CAT);
call    0 returned 5203
        -: 2490:    }
     1172: 2491:}
        -: 2492:
        -: 2493:static void
function regexp called 890 returned 100% blocks executed 100%
      890: 2494:regexp (int toplevel)
        -: 2495:{
      890: 2496:  branch();
call    0 returned 890
     1172: 2497:  while (tok == OR)
branch  0 taken 282
branch  1 taken 890 (fallthrough)
        -: 2498:    {
      282: 2499:      tok = lex();
call    0 returned 282
      282: 2500:      branch();
call    0 returned 282
      282: 2501:      if (toplevel)
branch  0 taken 239 (fallthrough)
branch  1 taken 43
      239: 2502:	addtok(ORTOP);
call    0 returned 239
        -: 2503:      else
       43: 2504:	addtok(OR);
call    0 returned 43
        -: 2505:    }
      890: 2506:}
        -: 2507:
        -: 2508:/* Main entry point for the parser.  S is a string to be parsed, len is the
        -: 2509:   length of the string, so s can include NUL characters.  D is a pointer to
        -: 2510:   the struct dfa to parse into. */
        -: 2511:void
function dfaparse called 780 returned 100% blocks executed 73%
      780: 2512:dfaparse (char *s, size_t len, struct dfa *d)
        -: 2513:{
      780: 2514:  dfa = d;
      780: 2515:  lexstart = lexptr = s;
      780: 2516:  lexleft = len;
      780: 2517:  lasttok = END;
      780: 2518:  laststart = 1;
      780: 2519:  parens = 0;
        -: 2520:
      780: 2521:  if (! syntax_bits_set)
branch  0 taken 0 (fallthrough)
branch  1 taken 780
    #####: 2522:    dfaerror(_("No syntax specified"));
call    0 never executed
        -: 2523:
      780: 2524:  tok = lex();
call    0 returned 780
      780: 2525:  depth = d->depth;
        -: 2526:
      780: 2527:  regexp(1);
call    0 returned 780
        -: 2528:
      780: 2529:  if (tok != END)
branch  0 taken 0 (fallthrough)
branch  1 taken 780
    #####: 2530:    dfaerror(_("Unbalanced )"));
call    0 never executed
        -: 2531:
      780: 2532:  addtok(END - d->nregexps);
call    0 returned 780
      780: 2533:  addtok(CAT);
call    0 returned 780
        -: 2534:
      780: 2535:  if (d->nregexps)
branch  0 taken 0 (fallthrough)
branch  1 taken 780
    #####: 2536:    addtok(ORTOP);
call    0 never executed
        -: 2537:
      780: 2538:  ++d->nregexps;
      780: 2539:}
        -: 2540:
        -: 2541:/* Some primitives for operating on sets of positions. */
        -: 2542:
        -: 2543:/* Copy one set to another; the destination must be large enough. */
        -: 2544:static void
function copy called 28335 returned 100% blocks executed 100%
    28335: 2545:copy (position_set *src, position_set *dst)
        -: 2546:{
        -: 2547:  int i;
        -: 2548:
    68736: 2549:  for (i = 0; i < src->nelem; ++i)
branch  0 taken 40401
branch  1 taken 28335 (fallthrough)
    40401: 2550:    dst->elems[i] = src->elems[i];
    28335: 2551:  dst->nelem = src->nelem;
    28335: 2552:}
        -: 2553:
        -: 2554:/* Insert a position in a set.  Position sets are maintained in sorted
        -: 2555:   order according to index.  If position already exists in the set with
        -: 2556:   the same index then their constraints are logically or'd together.
        -: 2557:   S->elems must point to an array large enough to hold the resulting set. */
        -: 2558:static void
function insert called 24771 returned 100% blocks executed 100%
    24771: 2559:insert (position p, position_set *s)
    24311: 2560:{
        -: 2561:  int i;
        -: 2562:  position t1, t2;
        -: 2563:
    49082: 2564:  for (i = 0; i < s->nelem && p.index < s->elems[i].index; ++i)
branch  0 taken 27936 (fallthrough)
branch  1 taken 21146
branch  2 taken 24311
branch  3 taken 3625 (fallthrough)
    24311: 2565:    continue;
    24771: 2566:  if (i < s->nelem && p.index == s->elems[i].index)
branch  0 taken 3625 (fallthrough)
branch  1 taken 21146
branch  2 taken 704 (fallthrough)
branch  3 taken 2921
      704: 2567:    s->elems[i].constraint |= p.constraint;
        -: 2568:  else
        -: 2569:    {
    24067: 2570:      t1 = p;
    24067: 2571:      ++s->nelem;
    51247: 2572:      while (i < s->nelem)
branch  0 taken 27180
branch  1 taken 24067 (fallthrough)
        -: 2573:	{
    27180: 2574:	  t2 = s->elems[i];
    27180: 2575:	  s->elems[i++] = t1;
    27180: 2576:	  t1 = t2;
        -: 2577:	}
        -: 2578:    }
    24771: 2579:}
        -: 2580:
        -: 2581:/* Merge two sets of positions into a third.  The result is exactly as if
        -: 2582:   the positions of both sets were inserted into an initially empty set. */
        -: 2583:static void
function merge called 6172 returned 100% blocks executed 93%
     6172: 2584:merge (position_set *s1, position_set *s2, position_set *m)
        -: 2585:{
     6172: 2586:  int i = 0, j = 0;
        -: 2587:
     6172: 2588:  m->nelem = 0;
     6485: 2589:  while (i < s1->nelem && j < s2->nelem)
branch  0 taken 6172 (fallthrough)
branch  1 taken 313
branch  2 taken 313
branch  3 taken 5859 (fallthrough)
      313: 2590:    if (s1->elems[i].index > s2->elems[j].index)
branch  0 taken 312 (fallthrough)
branch  1 taken 1
      312: 2591:      m->elems[m->nelem++] = s1->elems[i++];
        1: 2592:    else if (s1->elems[i].index < s2->elems[j].index)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####: 2593:      m->elems[m->nelem++] = s2->elems[j++];
        -: 2594:    else
        -: 2595:      {
        1: 2596:	m->elems[m->nelem] = s1->elems[i++];
        1: 2597:	m->elems[m->nelem++].constraint |= s2->elems[j++].constraint;
        -: 2598:      }
    12032: 2599:  while (i < s1->nelem)
branch  0 taken 5860
branch  1 taken 6172 (fallthrough)
     5860: 2600:    m->elems[m->nelem++] = s1->elems[i++];
     6503: 2601:  while (j < s2->nelem)
branch  0 taken 331
branch  1 taken 6172 (fallthrough)
      331: 2602:    m->elems[m->nelem++] = s2->elems[j++];
     6172: 2603:}
        -: 2604:
        -: 2605:/* Delete a position from a set. */
        -: 2606:static void
function delete called 390 returned 100% blocks executed 100%
      390: 2607:delete (position p, position_set *s)
        -: 2608:{
        -: 2609:  int i;
        -: 2610:
      534: 2611:  for (i = 0; i < s->nelem; ++i)
branch  0 taken 534
branch  1 taken 0 (fallthrough)
      534: 2612:    if (p.index == s->elems[i].index)
branch  0 taken 390 (fallthrough)
branch  1 taken 144
      390: 2613:      break;
      390: 2614:  if (i < s->nelem)
branch  0 taken 390 (fallthrough)
branch  1 taken 0
      501: 2615:    for (--s->nelem; i < s->nelem; ++i)
branch  0 taken 111
branch  1 taken 390 (fallthrough)
      111: 2616:      s->elems[i] = s->elems[i + 1];
      390: 2617:}
        -: 2618:
        -: 2619:/* Find the index of the state corresponding to the given position set with
        -: 2620:   the given preceding context, or create a new state if there is no such
        -: 2621:   state.  Newline and letter tell whether we got here on a newline or
        -: 2622:   letter, respectively. */
        -: 2623:static int
function state_index called 16111 returned 100% blocks executed 91%
    16111: 2624:state_index (struct dfa *d, position_set *s, int newline, int letter)
        -: 2625:{
    16111: 2626:  int hash = 0;
        -: 2627:  int constraint;
        -: 2628:  int i, j;
        -: 2629:
    16111: 2630:  newline = newline ? 1 : 0;
    16111: 2631:  letter = letter ? 1 : 0;
        -: 2632:
    55883: 2633:  for (i = 0; i < s->nelem; ++i)
branch  0 taken 39772
branch  1 taken 16111 (fallthrough)
    39772: 2634:    hash ^= s->elems[i].index + s->elems[i].constraint;
        -: 2635:
        -: 2636:  /* Try to find a state that exactly matches the proposed one. */
    64615: 2637:  for (i = 0; i < d->sindex; ++i)
branch  0 taken 59213
branch  1 taken 5402 (fallthrough)
        -: 2638:    {
    59213: 2639:      if (hash != d->states[i].hash || s->nelem != d->states[i].elems.nelem
branch  0 taken 15006 (fallthrough)
branch  1 taken 44207
branch  2 taken 15002 (fallthrough)
branch  3 taken 4
    15002: 2640:	  || newline != d->states[i].newline || letter != d->states[i].letter)
branch  0 taken 14202 (fallthrough)
branch  1 taken 800
branch  2 taken 3362 (fallthrough)
branch  3 taken 10840
    48373: 2641:	continue;
    35596: 2642:      for (j = 0; j < s->nelem; ++j)
branch  0 taken 24887
branch  1 taken 10709 (fallthrough)
    24887: 2643:	if (s->elems[j].constraint
    24887: 2644:	    != d->states[i].elems.elems[j].constraint
branch  0 taken 24879 (fallthrough)
branch  1 taken 8
    24879: 2645:	    || s->elems[j].index != d->states[i].elems.elems[j].index)
branch  0 taken 24756 (fallthrough)
branch  1 taken 123
        -: 2646:	  break;
    10840: 2647:      if (j == s->nelem)
branch  0 taken 10709 (fallthrough)
branch  1 taken 131
    10709: 2648:	return i;
        -: 2649:    }
        -: 2650:
        -: 2651:  /* We'll have to create a new state. */
     7121: 2652:  REALLOC_IF_NECESSARY(d->states, dfa_state, d->salloc, d->sindex);
branch  0 taken 1719 (fallthrough)
branch  1 taken 3683
branch  2 taken 1719
branch  3 taken 1719 (fallthrough)
call    4 returned 1719
     5402: 2653:  d->states[i].hash = hash;
     5402: 2654:  MALLOC(d->states[i].elems.elems, position, s->nelem);
call    0 returned 5402
     5402: 2655:  copy(s, &d->states[i].elems);
call    0 returned 5402
     5402: 2656:  d->states[i].newline = newline;
     5402: 2657:  d->states[i].letter = letter;
     5402: 2658:  d->states[i].backref = 0;
     5402: 2659:  d->states[i].constraint = 0;
     5402: 2660:  d->states[i].first_end = 0;
    20418: 2661:  for (j = 0; j < s->nelem; ++j)
branch  0 taken 15016
branch  1 taken 5402 (fallthrough)
    15016: 2662:    if (d->tokens[s->elems[j].index] < 0)
branch  0 taken 771 (fallthrough)
branch  1 taken 14245
        -: 2663:      {
      771: 2664:	constraint = s->elems[j].constraint;
      771: 2665:	if (SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 768
branch  2 taken 759 (fallthrough)
branch  3 taken 12
branch  4 taken 179 (fallthrough)
branch  5 taken 580
branch  6 taken 37 (fallthrough)
branch  7 taken 722
      49*: 2666:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 0, letter, 1)
branch  0 taken 0 (fallthrough)
branch  1 taken 49
branch  2 taken 37 (fallthrough)
branch  3 taken 12
branch  4 taken 1 (fallthrough)
branch  5 taken 36
branch  6 taken 1 (fallthrough)
branch  7 taken 36
      13*: 2667:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 13
branch  2 taken 9 (fallthrough)
branch  3 taken 4
branch  4 taken 0 (fallthrough)
branch  5 taken 9
branch  6 taken 1 (fallthrough)
branch  7 taken 8
       5*: 2668:	    || SUCCEEDS_IN_CONTEXT(constraint, newline, 1, letter, 1))
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 taken 1 (fallthrough)
branch  3 taken 4
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 0 (fallthrough)
branch  7 taken 1
      766: 2669:	  d->states[i].constraint |= constraint;
      771: 2670:	if (! d->states[i].first_end)
branch  0 taken 771 (fallthrough)
branch  1 taken 0
      771: 2671:	  d->states[i].first_end = d->tokens[s->elems[j].index];
        -: 2672:      }
    14245: 2673:    else if (d->tokens[s->elems[j].index] == BACKREF)
branch  0 taken 0 (fallthrough)
branch  1 taken 14245
        -: 2674:      {
    #####: 2675:	d->states[i].constraint = NO_CONSTRAINT;
    #####: 2676:	d->states[i].backref = 1;
        -: 2677:      }
        -: 2678:
     5402: 2679:  ++d->sindex;
        -: 2680:
     5402: 2681:  return i;
        -: 2682:}
        -: 2683:
        -: 2684:/* Find the epsilon closure of a set of positions.  If any position of the set
        -: 2685:   contains a symbol that matches the empty string in some context, replace
        -: 2686:   that position with the elements of its follow labeled with an appropriate
        -: 2687:   constraint.  Repeat exhaustively until no funny positions are left.
        -: 2688:   S->elems must be large enough to hold the result. */
        -: 2689:static void
function epsclosure called 6916 returned 100% blocks executed 96%
     6916: 2690:epsclosure (position_set *s, struct dfa *d)
        -: 2691:{
        -: 2692:  int i, j;
        -: 2693:  int *visited;
        -: 2694:  position p, old;
        -: 2695:
     6916: 2696:  MALLOC(visited, int, d->tindex);
call    0 returned 6916
   189596: 2697:  for (i = 0; i < d->tindex; ++i)
branch  0 taken 182680
branch  1 taken 6916 (fallthrough)
   182680: 2698:    visited[i] = 0;
        -: 2699:
    14281: 2700:  for (i = 0; i < s->nelem; ++i)
branch  0 taken 7365
branch  1 taken 6916 (fallthrough)
     7365: 2701:    if (d->tokens[s->elems[i].index] >= NOTCHAR
branch  0 taken 923 (fallthrough)
branch  1 taken 6442
      923: 2702:	&& d->tokens[s->elems[i].index] != BACKREF
branch  0 taken 923 (fallthrough)
branch  1 taken 0
      923: 2703:	&& d->tokens[s->elems[i].index] < CSET)
branch  0 taken 390 (fallthrough)
branch  1 taken 533
        -: 2704:      {
      390: 2705:	old = s->elems[i];
      390: 2706:	p.constraint = old.constraint;
      390: 2707:	delete(s->elems[i], s);
call    0 returned 390
      390: 2708:	if (visited[old.index])
branch  0 taken 3 (fallthrough)
branch  1 taken 387
        -: 2709:	  {
        3: 2710:	    --i;
        3: 2711:	    continue;
        -: 2712:	  }
      387: 2713:	visited[old.index] = 1;
      387: 2714:	switch (d->tokens[old.index])
branch  0 taken 121
branch  1 taken 10
branch  2 taken 114
branch  3 taken 1
branch  4 taken 140
branch  5 taken 1
branch  6 taken 0
        -: 2715:	  {
      121: 2716:	  case BEGLINE:
      121: 2717:	    p.constraint &= BEGLINE_CONSTRAINT;
      121: 2718:	    break;
       10: 2719:	  case ENDLINE:
       10: 2720:	    p.constraint &= ENDLINE_CONSTRAINT;
       10: 2721:	    break;
      114: 2722:	  case BEGWORD:
      114: 2723:	    p.constraint &= BEGWORD_CONSTRAINT;
      114: 2724:	    break;
        1: 2725:	  case ENDWORD:
        1: 2726:	    p.constraint &= ENDWORD_CONSTRAINT;
        1: 2727:	    break;
      140: 2728:	  case LIMWORD:
      140: 2729:	    p.constraint &= LIMWORD_CONSTRAINT;
      140: 2730:	    break;
        1: 2731:	  case NOTLIMWORD:
        1: 2732:	    p.constraint &= NOTLIMWORD_CONSTRAINT;
        1: 2733:	    break;
    #####: 2734:	  default:
    #####: 2735:	    break;
        -: 2736:	  }
      777: 2737:	for (j = 0; j < d->follows[old.index].nelem; ++j)
branch  0 taken 390
branch  1 taken 387 (fallthrough)
        -: 2738:	  {
      390: 2739:	    p.index = d->follows[old.index].elems[j].index;
      390: 2740:	    insert(p, s);
call    0 returned 390
        -: 2741:	  }
        -: 2742:	/* Force rescan to start at the beginning. */
      387: 2743:	i = -1;
        -: 2744:      }
        -: 2745:
     6916: 2746:  free(visited);
     6916: 2747:}
        -: 2748:
        -: 2749:/* Perform bottom-up analysis on the parse tree, computing various functions.
        -: 2750:   Note that at this point, we're pretending constructs like \< are real
        -: 2751:   characters rather than constraints on what can follow them.
        -: 2752:
        -: 2753:   Nullable:  A node is nullable if it is at the root of a regexp that can
        -: 2754:   match the empty string.
        -: 2755:   *  EMPTY leaves are nullable.
        -: 2756:   * No other leaf is nullable.
        -: 2757:   * A QMARK or STAR node is nullable.
        -: 2758:   * A PLUS node is nullable if its argument is nullable.
        -: 2759:   * A CAT node is nullable if both its arguments are nullable.
        -: 2760:   * An OR node is nullable if either argument is nullable.
        -: 2761:
        -: 2762:   Firstpos:  The firstpos of a node is the set of positions (nonempty leaves)
        -: 2763:   that could correspond to the first character of a string matching the
        -: 2764:   regexp rooted at the given node.
        -: 2765:   * EMPTY leaves have empty firstpos.
        -: 2766:   * The firstpos of a nonempty leaf is that leaf itself.
        -: 2767:   * The firstpos of a QMARK, STAR, or PLUS node is the firstpos of its
        -: 2768:     argument.
        -: 2769:   * The firstpos of a CAT node is the firstpos of the left argument, union
        -: 2770:     the firstpos of the right if the left argument is nullable.
        -: 2771:   * The firstpos of an OR node is the union of firstpos of each argument.
        -: 2772:
        -: 2773:   Lastpos:  The lastpos of a node is the set of positions that could
        -: 2774:   correspond to the last character of a string matching the regexp at
        -: 2775:   the given node.
        -: 2776:   * EMPTY leaves have empty lastpos.
        -: 2777:   * The lastpos of a nonempty leaf is that leaf itself.
        -: 2778:   * The lastpos of a QMARK, STAR, or PLUS node is the lastpos of its
        -: 2779:     argument.
        -: 2780:   * The lastpos of a CAT node is the lastpos of its right argument, union
        -: 2781:     the lastpos of the left if the right argument is nullable.
        -: 2782:   * The lastpos of an OR node is the union of the lastpos of each argument.
        -: 2783:
        -: 2784:   Follow:  The follow of a position is the set of positions that could
        -: 2785:   correspond to the character following a character matching the node in
        -: 2786:   a string matching the regexp.  At this point we consider special symbols
        -: 2787:   that match the empty string in some context to be just normal characters.
        -: 2788:   Later, if we find that a special symbol is in a follow set, we will
        -: 2789:   replace it with the elements of its follow, labeled with an appropriate
        -: 2790:   constraint.
        -: 2791:   * Every node in the firstpos of the argument of a STAR or PLUS node is in
        -: 2792:     the follow of every node in the lastpos.
        -: 2793:   * Every node in the firstpos of the second argument of a CAT node is in
        -: 2794:     the follow of every node in the lastpos of the first argument.
        -: 2795:
        -: 2796:   Because of the postfix representation of the parse tree, the depth-first
        -: 2797:   analysis is conveniently done by a linear scan with the aid of a stack.
        -: 2798:   Sets are stored as arrays of the elements, obeying a stack-like allocation
        -: 2799:   scheme; the number of elements in each set deeper in the stack can be
        -: 2800:   used to determine the address of a particular set's array. */
        -: 2801:void
function dfaanalyze called 722 returned 100% blocks executed 91%
      722: 2802:dfaanalyze (struct dfa *d, int searchflag)
        -: 2803:{
        -: 2804:  int *nullable;		/* Nullable stack. */
        -: 2805:  int *nfirstpos;		/* Element count stack for firstpos sets. */
        -: 2806:  position *firstpos;		/* Array where firstpos elements are stored. */
        -: 2807:  int *nlastpos;		/* Element count stack for lastpos sets. */
        -: 2808:  position *lastpos;		/* Array where lastpos elements are stored. */
        -: 2809:  int *nalloc;			/* Sizes of arrays allocated to follow sets. */
        -: 2810:  position_set tmp;		/* Temporary set for merging sets. */
        -: 2811:  position_set merged;		/* Result of merging sets. */
        -: 2812:  int wants_newline;		/* True if some position wants newline info. */
        -: 2813:  int *o_nullable;
        -: 2814:  int *o_nfirst, *o_nlast;
        -: 2815:  position *o_firstpos, *o_lastpos;
        -: 2816:  int i, j;
        -: 2817:  position *pos;
        -: 2818:
        -: 2819:#ifdef DEBUG
        -: 2820:  fprintf(stderr, "dfaanalyze:\n");
        -: 2821:  for (i = 0; i < d->tindex; ++i)
        -: 2822:    {
        -: 2823:      fprintf(stderr, " %d:", i);
        -: 2824:      prtok(d->tokens[i]);
        -: 2825:    }
        -: 2826:  putc('\n', stderr);
        -: 2827:#endif
        -: 2828:
      722: 2829:  d->searchflag = searchflag;
        -: 2830:
      722: 2831:  MALLOC(nullable, int, d->depth);
call    0 returned 722
      722: 2832:  o_nullable = nullable;
      722: 2833:  MALLOC(nfirstpos, int, d->depth);
call    0 returned 722
      722: 2834:  o_nfirst = nfirstpos;
      722: 2835:  MALLOC(firstpos, position, d->nleaves);
call    0 returned 722
      722: 2836:  o_firstpos = firstpos, firstpos += d->nleaves;
      722: 2837:  MALLOC(nlastpos, int, d->depth);
call    0 returned 722
      722: 2838:  o_nlast = nlastpos;
      722: 2839:  MALLOC(lastpos, position, d->nleaves);
call    0 returned 722
      722: 2840:  o_lastpos = lastpos, lastpos += d->nleaves;
      722: 2841:  MALLOC(nalloc, int, d->tindex);
call    0 returned 722
    13684: 2842:  for (i = 0; i < d->tindex; ++i)
branch  0 taken 12962
branch  1 taken 722 (fallthrough)
    12962: 2843:    nalloc[i] = 0;
      722: 2844:  MALLOC(merged.elems, position, d->nleaves);
call    0 returned 722
        -: 2845:
      722: 2846:  CALLOC(d->follows, position_set, d->tindex);
call    0 returned 722
        -: 2847:
    13684: 2848:  for (i = 0; i < d->tindex; ++i)
branch  0 taken 12962
branch  1 taken 722 (fallthrough)
        -: 2849:#ifdef DEBUG
        -: 2850:    {				/* Nonsyntactic #ifdef goo... */
        -: 2851:#endif
    12962: 2852:    switch (d->tokens[i])
branch  0 taken 72
branch  1 taken 191
branch  2 taken 187
branch  3 taken 5649
branch  4 taken 282
branch  5 taken 6581
        -: 2853:      {
       72: 2854:      case EMPTY:
        -: 2855:	/* The empty set is nullable. */
       72: 2856:	*nullable++ = 1;
        -: 2857:
        -: 2858:	/* The firstpos and lastpos of the empty leaf are both empty. */
       72: 2859:	*nfirstpos++ = *nlastpos++ = 0;
       72: 2860:	break;
        -: 2861:
      191: 2862:      case STAR:
        -: 2863:      case PLUS:
        -: 2864:	/* Every element in the firstpos of the argument is in the follow
        -: 2865:	   of every element in the lastpos. */
      191: 2866:	tmp.nelem = nfirstpos[-1];
      191: 2867:	tmp.elems = firstpos;
      191: 2868:	pos = lastpos;
      362: 2869:	for (j = 0; j < nlastpos[-1]; ++j)
branch  0 taken 171
branch  1 taken 191 (fallthrough)
        -: 2870:	  {
      171: 2871:	    merge(&tmp, &d->follows[pos[j].index], &merged);
call    0 returned 171
     171*: 2872:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
branch  0 taken 0 (fallthrough)
branch  1 taken 171
branch  2 never executed
branch  3 never executed
call    4 never executed
        -: 2873:				 nalloc[pos[j].index], merged.nelem - 1);
      171: 2874:	    copy(&merged, &d->follows[pos[j].index]);
call    0 returned 171
        -: 2875:	  }
        -: 2876:
        -: 2877:      case QMARK:
        -: 2878:	/* A QMARK or STAR node is automatically nullable. */
      378: 2879:	if (d->tokens[i] != PLUS)
branch  0 taken 198 (fallthrough)
branch  1 taken 180
      198: 2880:	  nullable[-1] = 1;
      378: 2881:	break;
        -: 2882:
     5649: 2883:      case CAT:
        -: 2884:	/* Every element in the firstpos of the second argument is in the
        -: 2885:	   follow of every element in the lastpos of the first argument. */
     5649: 2886:	tmp.nelem = nfirstpos[-1];
     5649: 2887:	tmp.elems = firstpos;
     5649: 2888:	pos = lastpos + nlastpos[-1];
    11650: 2889:	for (j = 0; j < nlastpos[-2]; ++j)
branch  0 taken 6001
branch  1 taken 5649 (fallthrough)
        -: 2890:	  {
     6001: 2891:	    merge(&tmp, &d->follows[pos[j].index], &merged);
call    0 returned 6001
     6312: 2892:	    REALLOC_IF_NECESSARY(d->follows[pos[j].index].elems, position,
branch  0 taken 311 (fallthrough)
branch  1 taken 5690
branch  2 taken 311
branch  3 taken 311 (fallthrough)
call    4 returned 311
        -: 2893:				 nalloc[pos[j].index], merged.nelem - 1);
     6001: 2894:	    copy(&merged, &d->follows[pos[j].index]);
call    0 returned 6001
        -: 2895:	  }
        -: 2896:
        -: 2897:	/* The firstpos of a CAT node is the firstpos of the first argument,
        -: 2898:	   union that of the second argument if the first is nullable. */
     5649: 2899:	if (nullable[-2])
branch  0 taken 123 (fallthrough)
branch  1 taken 5526
      123: 2900:	  nfirstpos[-2] += nfirstpos[-1];
        -: 2901:	else
     5526: 2902:	  firstpos += nfirstpos[-1];
     5649: 2903:	--nfirstpos;
        -: 2904:
        -: 2905:	/* The lastpos of a CAT node is the lastpos of the second argument,
        -: 2906:	   union that of the first argument if the second is nullable. */
     5649: 2907:	if (nullable[-1])
branch  0 taken 127 (fallthrough)
branch  1 taken 5522
      127: 2908:	  nlastpos[-2] += nlastpos[-1];
        -: 2909:	else
        -: 2910:	  {
     5522: 2911:	    pos = lastpos + nlastpos[-2];
    11046: 2912:	    for (j = nlastpos[-1] - 1; j >= 0; --j)
branch  0 taken 5524
branch  1 taken 5522 (fallthrough)
     5524: 2913:	      pos[j] = lastpos[j];
     5522: 2914:	    lastpos += nlastpos[-2];
     5522: 2915:	    nlastpos[-2] = nlastpos[-1];
        -: 2916:	  }
     5649: 2917:	--nlastpos;
        -: 2918:
        -: 2919:	/* A CAT node is nullable if both arguments are nullable. */
    5649*: 2920:	nullable[-2] = nullable[-1] && nullable[-2];
branch  0 taken 127 (fallthrough)
branch  1 taken 5522
branch  2 taken 0 (fallthrough)
branch  3 taken 127
     5649: 2921:	--nullable;
     5649: 2922:	break;
        -: 2923:
      282: 2924:      case OR:
        -: 2925:      case ORTOP:
        -: 2926:	/* The firstpos is the union of the firstpos of each argument. */
      282: 2927:	nfirstpos[-2] += nfirstpos[-1];
      282: 2928:	--nfirstpos;
        -: 2929:
        -: 2930:	/* The lastpos is the union of the lastpos of each argument. */
      282: 2931:	nlastpos[-2] += nlastpos[-1];
      282: 2932:	--nlastpos;
        -: 2933:
        -: 2934:	/* An OR node is nullable if either argument is nullable. */
      282: 2935:	nullable[-2] = nullable[-1] || nullable[-2];
branch  0 taken 275 (fallthrough)
branch  1 taken 7
branch  2 taken 3 (fallthrough)
branch  3 taken 272
      282: 2936:	--nullable;
      282: 2937:	break;
        -: 2938:
     6581: 2939:      default:
        -: 2940:	/* Anything else is a nonempty position.  (Note that special
        -: 2941:	   constructs like \< are treated as nonempty strings here;
        -: 2942:	   an "epsilon closure" effectively makes them nullable later.
        -: 2943:	   Backreferences have to get a real position so we can detect
        -: 2944:	   transitions on them later.  But they are nullable. */
     6581: 2945:	*nullable++ = d->tokens[i] == BACKREF;
        -: 2946:
        -: 2947:	/* This position is in its own firstpos and lastpos. */
     6581: 2948:	*nfirstpos++ = *nlastpos++ = 1;
     6581: 2949:	--firstpos, --lastpos;
     6581: 2950:	firstpos->index = lastpos->index = i;
     6581: 2951:	firstpos->constraint = lastpos->constraint = NO_CONSTRAINT;
        -: 2952:
        -: 2953:	/* Allocate the follow set for this position. */
     6581: 2954:	nalloc[i] = 1;
     6581: 2955:	MALLOC(d->follows[i].elems, position, nalloc[i]);
call    0 returned 6581
     6581: 2956:	break;
        -: 2957:      }
        -: 2958:#ifdef DEBUG
        -: 2959:    /* ... balance the above nonsyntactic #ifdef goo... */
        -: 2960:      fprintf(stderr, "node %d:", i);
        -: 2961:      prtok(d->tokens[i]);
        -: 2962:      putc('\n', stderr);
        -: 2963:      fprintf(stderr, nullable[-1] ? " nullable: yes\n" : " nullable: no\n");
        -: 2964:      fprintf(stderr, " firstpos:");
        -: 2965:      for (j = nfirstpos[-1] - 1; j >= 0; --j)
        -: 2966:	{
        -: 2967:	  fprintf(stderr, " %d:", firstpos[j].index);
        -: 2968:	  prtok(d->tokens[firstpos[j].index]);
        -: 2969:	}
        -: 2970:      fprintf(stderr, "\n lastpos:");
        -: 2971:      for (j = nlastpos[-1] - 1; j >= 0; --j)
        -: 2972:	{
        -: 2973:	  fprintf(stderr, " %d:", lastpos[j].index);
        -: 2974:	  prtok(d->tokens[lastpos[j].index]);
        -: 2975:	}
        -: 2976:      putc('\n', stderr);
        -: 2977:    }
        -: 2978:#endif
        -: 2979:
        -: 2980:  /* For each follow set that is the follow set of a real position, replace
        -: 2981:     it with its epsilon closure. */
    13684: 2982:  for (i = 0; i < d->tindex; ++i)
branch  0 taken 12962
branch  1 taken 722 (fallthrough)
    12962: 2983:    if (d->tokens[i] < NOTCHAR || d->tokens[i] == BACKREF
branch  0 taken 7282 (fallthrough)
branch  1 taken 5680
branch  2 taken 7282 (fallthrough)
branch  3 taken 0
     7282: 2984:	|| d->tokens[i] >= CSET)
branch  0 taken 514 (fallthrough)
branch  1 taken 6768
        -: 2985:      {
        -: 2986:#ifdef DEBUG
        -: 2987:	fprintf(stderr, "follows(%d:", i);
        -: 2988:	prtok(d->tokens[i]);
        -: 2989:	fprintf(stderr, "):");
        -: 2990:	for (j = d->follows[i].nelem - 1; j >= 0; --j)
        -: 2991:	  {
        -: 2992:	    fprintf(stderr, " %d:", d->follows[i].elems[j].index);
        -: 2993:	    prtok(d->tokens[d->follows[i].elems[j].index]);
        -: 2994:	  }
        -: 2995:	putc('\n', stderr);
        -: 2996:#endif
     6194: 2997:	copy(&d->follows[i], &merged);
call    0 returned 6194
     6194: 2998:	epsclosure(&merged, d);
call    0 returned 6194
     6194: 2999:	if (d->follows[i].nelem < merged.nelem)
branch  0 taken 0 (fallthrough)
branch  1 taken 6194
    #####: 3000:	  REALLOC(d->follows[i].elems, position, merged.nelem);
call    0 never executed
     6194: 3001:	copy(&merged, &d->follows[i]);
call    0 returned 6194
        -: 3002:      }
        -: 3003:
        -: 3004:  /* Get the epsilon closure of the firstpos of the regexp.  The result will
        -: 3005:     be the set of positions of state 0. */
      722: 3006:  merged.nelem = 0;
     1776: 3007:  for (i = 0; i < nfirstpos[-1]; ++i)
branch  0 taken 1054
branch  1 taken 722 (fallthrough)
     1054: 3008:    insert(firstpos[i], &merged);
call    0 returned 1054
      722: 3009:  epsclosure(&merged, d);
call    0 returned 722
        -: 3010:
        -: 3011:  /* Check if any of the positions of state 0 will want newline context. */
      722: 3012:  wants_newline = 0;
     1775: 3013:  for (i = 0; i < merged.nelem; ++i)
branch  0 taken 1053
branch  1 taken 722 (fallthrough)
     1053: 3014:    if (PREV_NEWLINE_DEPENDENT(merged.elems[i].constraint))
branch  0 taken 120 (fallthrough)
branch  1 taken 933
      120: 3015:      wants_newline = 1;
        -: 3016:
        -: 3017:  /* Build the initial state. */
      722: 3018:  d->salloc = 1;
      722: 3019:  d->sindex = 0;
      722: 3020:  MALLOC(d->states, dfa_state, d->salloc);
call    0 returned 722
      722: 3021:  state_index(d, &merged, wants_newline, 0);
call    0 returned 722
        -: 3022:
      722: 3023:  free(o_nullable);
      722: 3024:  free(o_nfirst);
      722: 3025:  free(o_firstpos);
      722: 3026:  free(o_nlast);
      722: 3027:  free(o_lastpos);
      722: 3028:  free(nalloc);
      722: 3029:  free(merged.elems);
      722: 3030:}
        -: 3031:
        -: 3032:/* Find, for each character, the transition out of state s of d, and store
        -: 3033:   it in the appropriate slot of trans.
        -: 3034:
        -: 3035:   We divide the positions of s into groups (positions can appear in more
        -: 3036:   than one group).  Each group is labeled with a set of characters that
        -: 3037:   every position in the group matches (taking into account, if necessary,
        -: 3038:   preceding context information of s).  For each group, find the union
        -: 3039:   of the its elements' follows.  This set is the set of positions of the
        -: 3040:   new state.  For each character in the group's label, set the transition
        -: 3041:   on this character to be to a state corresponding to the set's positions,
        -: 3042:   and its associated backward context information, if necessary.
        -: 3043:
        -: 3044:   If we are building a searching matcher, we include the positions of state
        -: 3045:   0 in every state.
        -: 3046:
        -: 3047:   The collection of groups is constructed by building an equivalence-class
        -: 3048:   partition of the positions of s.
        -: 3049:
        -: 3050:   For each position, find the set of characters C that it matches.  Eliminate
        -: 3051:   any characters from C that fail on grounds of backward context.
        -: 3052:
        -: 3053:   Search through the groups, looking for a group whose label L has nonempty
        -: 3054:   intersection with C.  If L - C is nonempty, create a new group labeled
        -: 3055:   L - C and having the same positions as the current group, and set L to
        -: 3056:   the intersection of L and C.  Insert the position in this group, set
        -: 3057:   C = C - L, and resume scanning.
        -: 3058:
        -: 3059:   If after comparing with every group there are characters remaining in C,
        -: 3060:   create a new group labeled with the characters of C and insert this
        -: 3061:   position in that group. */
        -: 3062:void
function dfastate called 4041 returned 100% blocks executed 97%
     4041: 3063:dfastate (int s, struct dfa *d, int trans[])
        -: 3064:{
        -: 3065:  position_set grps[NOTCHAR];	/* As many as will ever be needed. */
        -: 3066:  charclass labels[NOTCHAR];	/* Labels corresponding to the groups. */
     4041: 3067:  int ngrps = 0;		/* Number of groups actually used. */
        -: 3068:  position pos;			/* Current position being considered. */
        -: 3069:  charclass matches;		/* Set of matching characters. */
        -: 3070:  int matchesf;			/* True if matches is nonempty. */
        -: 3071:  charclass intersect;		/* Intersection with some label set. */
        -: 3072:  int intersectf;		/* True if intersect is nonempty. */
        -: 3073:  charclass leftovers;		/* Stuff in the label that didn't match. */
        -: 3074:  int leftoversf;		/* True if leftovers is nonempty. */
        -: 3075:  static charclass letters;	/* Set of characters considered letters. */
        -: 3076:  static charclass newline;	/* Set of characters that aren't newline. */
        -: 3077:  position_set follows;		/* Union of the follows of some group. */
        -: 3078:  position_set tmp;		/* Temporary space for merging sets. */
        -: 3079:  int state;			/* New state. */
        -: 3080:  int wants_newline;		/* New state wants to know newline context. */
        -: 3081:  int state_newline;		/* New state on a newline transition. */
        -: 3082:  int wants_letter;		/* New state wants to know letter context. */
        -: 3083:  int state_letter;		/* New state on a letter transition. */
        -: 3084:  static int initialized;	/* Flag for static initialization. */
        -: 3085:  int i, j, k;
        -: 3086:
        -: 3087:  /* Initialize the set of letters, if necessary. */
     4041: 3088:  if (! initialized)
branch  0 taken 504 (fallthrough)
branch  1 taken 3537
        -: 3089:    {
      504: 3090:      initialized = 1;
   129528: 3091:      for (i = 0; i < NOTCHAR; ++i)
branch  0 taken 129024
branch  1 taken 504 (fallthrough)
   129024: 3092:	if (IS_WORD_CONSTITUENT(i))
branch  0 taken 97776 (fallthrough)
branch  1 taken 31248
branch  2 taken 504 (fallthrough)
branch  3 taken 97272
    31752: 3093:	  setbit(i, letters);
call    0 returned 31752
      504: 3094:      setbit(eolbyte_1, newline);
call    0 returned 504
        -: 3095:    }
        -: 3096:
     4041: 3097:  zeroset(matches);
call    0 returned 4041
        -: 3098:
    15395: 3099:  for (i = 0; i < d->states[s].elems.nelem; ++i)
branch  0 taken 11354
branch  1 taken 4041 (fallthrough)
        -: 3100:    {
    11354: 3101:      pos = d->states[s].elems.elems[i];
    11354: 3102:      if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR)
branch  0 taken 10805 (fallthrough)
branch  1 taken 549
branch  2 taken 10398 (fallthrough)
branch  3 taken 407
    10398: 3103:	setbit(d->tokens[pos.index], matches);
call    0 returned 10398
      956: 3104:      else if (d->tokens[pos.index] >= CSET)
branch  0 taken 407 (fallthrough)
branch  1 taken 549
      407: 3105:	copyset(d->charclasses[d->tokens[pos.index] - CSET], matches);
call    0 returned 407
        -: 3106:      else
      549: 3107:	continue;
        -: 3108:
        -: 3109:      /* Some characters may need to be eliminated from matches because
        -: 3110:	 they fail in the current context. */
    10805: 3111:      if (pos.constraint != 0xFF)
branch  0 taken 3295 (fallthrough)
branch  1 taken 7510
        -: 3112:	{
     3295: 3113:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
branch  0 taken 117 (fallthrough)
branch  1 taken 3178
branch  2 taken 1008 (fallthrough)
branch  3 taken 2287
        -: 3114:					 d->states[s].newline, 1))
     1008: 3115:	    clrbit(eolbyte_1, matches);
call    0 returned 1008
     3295: 3116:	  if (! MATCHES_NEWLINE_CONTEXT(pos.constraint,
branch  0 taken 117 (fallthrough)
branch  1 taken 3178
branch  2 taken 1009 (fallthrough)
branch  3 taken 2286
        -: 3117:					 d->states[s].newline, 0))
     9081: 3118:	    for (j = 0; j < CHARCLASS_INTS; ++j)
branch  0 taken 8072
branch  1 taken 1009 (fallthrough)
     8072: 3119:	      matches[j] &= newline[j];
     3295: 3120:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
branch  0 taken 1577 (fallthrough)
branch  1 taken 1718
branch  2 taken 1577 (fallthrough)
branch  3 taken 1718
        -: 3121:					d->states[s].letter, 1))
    14193: 3122:	    for (j = 0; j < CHARCLASS_INTS; ++j)
branch  0 taken 12616
branch  1 taken 1577 (fallthrough)
    12616: 3123:	      matches[j] &= ~letters[j];
     3295: 3124:	  if (! MATCHES_LETTER_CONTEXT(pos.constraint,
branch  0 taken 1577 (fallthrough)
branch  1 taken 1718
branch  2 taken 1405 (fallthrough)
branch  3 taken 1890
        -: 3125:					d->states[s].letter, 0))
    12645: 3126:	    for (j = 0; j < CHARCLASS_INTS; ++j)
branch  0 taken 11240
branch  1 taken 1405 (fallthrough)
    11240: 3127:	      matches[j] &= letters[j];
        -: 3128:
        -: 3129:	  /* If there are no characters left, there's no point in going on. */
    26108: 3130:	  for (j = 0; j < CHARCLASS_INTS && !matches[j]; ++j)
branch  0 taken 23522 (fallthrough)
branch  1 taken 2586
branch  2 taken 22813
branch  3 taken 709 (fallthrough)
    22813: 3131:	    continue;
     3295: 3132:	  if (j == CHARCLASS_INTS)
branch  0 taken 2586 (fallthrough)
branch  1 taken 709
     2586: 3133:	    continue;
        -: 3134:	}
        -: 3135:
    13558: 3136:      for (j = 0; j < ngrps; ++j)
branch  0 taken 6633
branch  1 taken 6925 (fallthrough)
        -: 3137:	{
        -: 3138:	  /* If matches contains a single character only, and the current
        -: 3139:	     group's label doesn't contain that character, go on to the
        -: 3140:	     next group. */
     6633: 3141:	  if (d->tokens[pos.index] >= 0 && d->tokens[pos.index] < NOTCHAR
branch  0 taken 6633 (fallthrough)
branch  1 taken 0
branch  2 taken 6338 (fallthrough)
branch  3 taken 295
     6338: 3142:	      && !tstbit(d->tokens[pos.index], labels[j]))
call    0 returned 6338
branch  1 taken 5046 (fallthrough)
branch  2 taken 1292
     5046: 3143:	    continue;
        -: 3144:
        -: 3145:	  /* Check if this group's label has a nonempty intersection with
        -: 3146:	     matches. */
     1587: 3147:	  intersectf = 0;
    14283: 3148:	  for (k = 0; k < CHARCLASS_INTS; ++k)
branch  0 taken 12696
branch  1 taken 1587 (fallthrough)
    12696: 3149:	    (intersect[k] = matches[k] & labels[j][k]) ? (intersectf = 1) : 0;
branch  0 taken 1459 (fallthrough)
branch  1 taken 11237
     1587: 3150:	  if (! intersectf)
branch  0 taken 135 (fallthrough)
branch  1 taken 1452
      135: 3151:	    continue;
        -: 3152:
        -: 3153:	  /* It does; now find the set differences both ways. */
     1452: 3154:	  leftoversf = matchesf = 0;
    13068: 3155:	  for (k = 0; k < CHARCLASS_INTS; ++k)
branch  0 taken 11616
branch  1 taken 1452 (fallthrough)
        -: 3156:	    {
        -: 3157:	      /* Even an optimizing compiler can't know this for sure. */
    11616: 3158:	      int match = matches[k], label = labels[j][k];
        -: 3159:
    11616: 3160:	      (leftovers[k] = ~match & label) ? (leftoversf = 1) : 0;
branch  0 taken 2636 (fallthrough)
branch  1 taken 8980
    11616: 3161:	      (matches[k] = match & ~label) ? (matchesf = 1) : 0;
branch  0 taken 1264 (fallthrough)
branch  1 taken 10352
        -: 3162:	    }
        -: 3163:
        -: 3164:	  /* If there were leftovers, create a new group labeled with them. */
     1452: 3165:	  if (leftoversf)
branch  0 taken 332 (fallthrough)
branch  1 taken 1120
        -: 3166:	    {
      332: 3167:	      copyset(leftovers, labels[ngrps]);
call    0 returned 332
      332: 3168:	      copyset(intersect, labels[j]);
call    0 returned 332
      332: 3169:	      MALLOC(grps[ngrps].elems, position, d->nleaves);
call    0 returned 332
      332: 3170:	      copy(&grps[j], &grps[ngrps]);
call    0 returned 332
      332: 3171:	      ++ngrps;
        -: 3172:	    }
        -: 3173:
        -: 3174:	  /* Put the position in the current group.  Note that there is no
        -: 3175:	     reason to call insert() here. */
     1452: 3176:	  grps[j].elems[grps[j].nelem++] = pos;
        -: 3177:
        -: 3178:	  /* If every character matching the current position has been
        -: 3179:	     accounted for, we're done. */
     1452: 3180:	  if (! matchesf)
branch  0 taken 1294 (fallthrough)
branch  1 taken 158
     1294: 3181:	    break;
        -: 3182:	}
        -: 3183:
        -: 3184:      /* If we've passed the last group, and there are still characters
        -: 3185:	 unaccounted for, then we'll have to create a new group. */
     8219: 3186:      if (j == ngrps)
branch  0 taken 6925 (fallthrough)
branch  1 taken 1294
        -: 3187:	{
     6925: 3188:	  copyset(matches, labels[ngrps]);
call    0 returned 6925
     6925: 3189:	  zeroset(matches);
call    0 returned 6925
     6925: 3190:	  MALLOC(grps[ngrps].elems, position, d->nleaves);
call    0 returned 6925
     6925: 3191:	  grps[ngrps].nelem = 1;
     6925: 3192:	  grps[ngrps].elems[0] = pos;
     6925: 3193:	  ++ngrps;
        -: 3194:	}
        -: 3195:    }
        -: 3196:
     4041: 3197:  MALLOC(follows.elems, position, d->nleaves);
call    0 returned 4041
     4041: 3198:  MALLOC(tmp.elems, position, d->nleaves);
call    0 returned 4041
        -: 3199:
        -: 3200:  /* If we are a searching matcher, the default transition is to a state
        -: 3201:     containing the positions of state 0, otherwise the default transition
        -: 3202:     is to fail miserably. */
     4041: 3203:  if (d->searchflag)
branch  0 taken 4041 (fallthrough)
branch  1 taken 0
        -: 3204:    {
     4041: 3205:      wants_newline = 0;
     4041: 3206:      wants_letter = 0;
    11027: 3207:      for (i = 0; i < d->states[0].elems.nelem; ++i)
branch  0 taken 6986
branch  1 taken 4041 (fallthrough)
        -: 3208:	{
     6986: 3209:	  if (PREV_NEWLINE_DEPENDENT(d->states[0].elems.elems[i].constraint))
branch  0 taken 1130 (fallthrough)
branch  1 taken 5856
     1130: 3210:	    wants_newline = 1;
     6986: 3211:	  if (PREV_LETTER_DEPENDENT(d->states[0].elems.elems[i].constraint))
branch  0 taken 2169 (fallthrough)
branch  1 taken 4817
     2169: 3212:	    wants_letter = 1;
        -: 3213:	}
     4041: 3214:      copy(&d->states[0].elems, &follows);
call    0 returned 4041
     4041: 3215:      state = state_index(d, &follows, 0, 0);
call    0 returned 4041
     4041: 3216:      if (wants_newline)
branch  0 taken 800 (fallthrough)
branch  1 taken 3241
      800: 3217:	state_newline = state_index(d, &follows, 1, 0);
call    0 returned 800
        -: 3218:      else
     3241: 3219:	state_newline = state;
     4041: 3220:      if (wants_letter)
branch  0 taken 1557 (fallthrough)
branch  1 taken 2484
     1557: 3221:	state_letter = state_index(d, &follows, 0, 1);
call    0 returned 1557
        -: 3222:      else
     2484: 3223:	state_letter = state;
  1038537: 3224:      for (i = 0; i < NOTCHAR; ++i)
branch  0 taken 1034496
branch  1 taken 4041 (fallthrough)
  1034496: 3225:	trans[i] = (IS_WORD_CONSTITUENT(i)) ? state_letter : state;
branch  0 taken 783954 (fallthrough)
branch  1 taken 250542
branch  2 taken 4041 (fallthrough)
branch  3 taken 779913
     4041: 3226:      trans[eolbyte_1] = state_newline;
        -: 3227:    }
        -: 3228:  else
    #####: 3229:    for (i = 0; i < NOTCHAR; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3230:      trans[i] = -1;
        -: 3231:
    11298: 3232:  for (i = 0; i < ngrps; ++i)
branch  0 taken 7257
branch  1 taken 4041 (fallthrough)
        -: 3233:    {
     7257: 3234:      follows.nelem = 0;
        -: 3235:
        -: 3236:      /* Find the union of the follows of the positions of the group.
        -: 3237:	 This is a hideously inefficient loop.  Fix it someday. */
    15966: 3238:      for (j = 0; j < grps[i].nelem; ++j)
branch  0 taken 8709
branch  1 taken 7257 (fallthrough)
    18227: 3239:	for (k = 0; k < d->follows[grps[i].elems[j].index].nelem; ++k)
branch  0 taken 9518
branch  1 taken 8709 (fallthrough)
     9518: 3240:	  insert(d->follows[grps[i].elems[j].index].elems[k], &follows);
call    0 returned 9518
        -: 3241:
        -: 3242:      /* If we are building a searching matcher, throw in the positions
        -: 3243:	 of state 0 as well. */
     7257: 3244:      if (d->searchflag)
branch  0 taken 7257 (fallthrough)
branch  1 taken 0
    21066: 3245:	for (j = 0; j < d->states[0].elems.nelem; ++j)
branch  0 taken 13809
branch  1 taken 7257 (fallthrough)
    13809: 3246:	  insert(d->states[0].elems.elems[j], &follows);
call    0 returned 13809
        -: 3247:
        -: 3248:      /* Find out if the new state will want any context information. */
     7257: 3249:      wants_newline = 0;
     7257: 3250:      if (tstbit(eolbyte_1, labels[i]))
call    0 returned 7257
branch  1 taken 37 (fallthrough)
branch  2 taken 7220
      144: 3251:	for (j = 0; j < follows.nelem; ++j)
branch  0 taken 107
branch  1 taken 37 (fallthrough)
      107: 3252:	  if (PREV_NEWLINE_DEPENDENT(follows.elems[j].constraint))
branch  0 taken 0 (fallthrough)
branch  1 taken 107
    #####: 3253:	    wants_newline = 1;
        -: 3254:
     7257: 3255:      wants_letter = 0;
    33925: 3256:      for (j = 0; j < CHARCLASS_INTS; ++j)
branch  0 taken 32679
branch  1 taken 1246 (fallthrough)
    32679: 3257:	if (labels[i][j] & letters[j])
branch  0 taken 6011 (fallthrough)
branch  1 taken 26668
     6011: 3258:	  break;
     7257: 3259:      if (j < CHARCLASS_INTS)
branch  0 taken 6011 (fallthrough)
branch  1 taken 1246
    24625: 3260:	for (j = 0; j < follows.nelem; ++j)
branch  0 taken 18614
branch  1 taken 6011 (fallthrough)
    18614: 3261:	  if (PREV_LETTER_DEPENDENT(follows.elems[j].constraint))
branch  0 taken 2358 (fallthrough)
branch  1 taken 16256
     2358: 3262:	    wants_letter = 1;
        -: 3263:
        -: 3264:      /* Find the state(s) corresponding to the union of the follows. */
     7257: 3265:      state = state_index(d, &follows, 0, 0);
call    0 returned 7257
     7257: 3266:      if (wants_newline)
branch  0 taken 0 (fallthrough)
branch  1 taken 7257
    #####: 3267:	state_newline = state_index(d, &follows, 1, 0);
call    0 never executed
        -: 3268:      else
     7257: 3269:	state_newline = state;
     7257: 3270:      if (wants_letter)
branch  0 taken 1734 (fallthrough)
branch  1 taken 5523
     1734: 3271:	state_letter = state_index(d, &follows, 0, 1);
call    0 returned 1734
        -: 3272:      else
     5523: 3273:	state_letter = state;
        -: 3274:
        -: 3275:      /* Set the transitions for each character in the current label. */
    65313: 3276:      for (j = 0; j < CHARCLASS_INTS; ++j)
branch  0 taken 58056
branch  1 taken 7257 (fallthrough)
  1915848: 3277:	for (k = 0; k < INTBITS; ++k)
branch  0 taken 1857792
branch  1 taken 58056 (fallthrough)
  1857792: 3278:	  if (labels[i][j] & 1 << k)
branch  0 taken 72969 (fallthrough)
branch  1 taken 1784823
        -: 3279:	    {
    72969: 3280:	      int c = j * INTBITS + k;
        -: 3281:
    72969: 3282:	      if (c == eolbyte_1)
branch  0 taken 37 (fallthrough)
branch  1 taken 72932
       37: 3283:		trans[c] = state_newline;
    72932: 3284:	      else if (IS_WORD_CONSTITUENT(c))
branch  0 taken 54105 (fallthrough)
branch  1 taken 18827
branch  2 taken 242 (fallthrough)
branch  3 taken 53863
    19069: 3285:		trans[c] = state_letter;
    53863: 3286:	      else if (c < NOTCHAR)
branch  0 taken 53863 (fallthrough)
branch  1 taken 0
    53863: 3287:		trans[c] = state;
        -: 3288:	    }
        -: 3289:    }
        -: 3290:
    11298: 3291:  for (i = 0; i < ngrps; ++i)
branch  0 taken 7257
branch  1 taken 4041 (fallthrough)
     7257: 3292:    free(grps[i].elems);
     4041: 3293:  free(follows.elems);
     4041: 3294:  free(tmp.elems);
     4041: 3295:}
        -: 3296:
        -: 3297:/* Some routines for manipulating a compiled dfa's transition tables.
        -: 3298:   Each state may or may not have a transition table; if it does, and it
        -: 3299:   is a non-accepting state, then d->trans[state] points to its table.
        -: 3300:   If it is an accepting state then d->fails[state] points to its table.
        -: 3301:   If it has no table at all, then d->trans[state] is NULL.
        -: 3302:   TODO: Improve this comment, get rid of the unnecessary redundancy. */
        -: 3303:
        -: 3304:static void
function build_state called 4041 returned 100% blocks executed 86%
     4041: 3305:build_state (int s, struct dfa *d)
        -: 3306:{
        -: 3307:  int *trans;			/* The new transition table. */
        -: 3308:  int i;
        -: 3309:
        -: 3310:  /* Set an upper limit on the number of transition tables that will ever
        -: 3311:     exist at once.  1024 is arbitrary.  The idea is that the frequently
        -: 3312:     used transition tables will be quickly rebuilt, whereas the ones that
        -: 3313:     were only needed once or twice will be cleared away. */
     4041: 3314:  if (d->trcount >= 1024)
branch  0 taken 0 (fallthrough)
branch  1 taken 4041
        -: 3315:    {
    #####: 3316:      for (i = 0; i < d->tralloc; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3317:	if (d->trans[i])
branch  0 never executed
branch  1 never executed
        -: 3318:	  {
    #####: 3319:	    free((ptr_t) d->trans[i]);
    #####: 3320:	    d->trans[i] = NULL;
        -: 3321:	  }
    #####: 3322:	else if (d->fails[i])
branch  0 never executed
branch  1 never executed
        -: 3323:	  {
    #####: 3324:	    free((ptr_t) d->fails[i]);
    #####: 3325:	    d->fails[i] = NULL;
        -: 3326:	  }
    #####: 3327:      d->trcount = 0;
        -: 3328:    }
        -: 3329:
     4041: 3330:  ++d->trcount;
        -: 3331:
        -: 3332:  /* Set up the success bits for this state. */
     4041: 3333:  d->success[s] = 0;
     4041: 3334:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 1, d->states[s].letter, 0,
branch  0 taken 84 (fallthrough)
branch  1 taken 3957
branch  2 taken 548 (fallthrough)
branch  3 taken 3493
branch  4 taken 178 (fallthrough)
branch  5 taken 370
branch  6 taken 546 (fallthrough)
branch  7 taken 2
        -: 3335:      s, *d))
      546: 3336:    d->success[s] |= 4;
     4041: 3337:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 1,
branch  0 taken 84 (fallthrough)
branch  1 taken 3957
branch  2 taken 540 (fallthrough)
branch  3 taken 3501
branch  4 taken 178 (fallthrough)
branch  5 taken 362
branch  6 taken 505 (fallthrough)
branch  7 taken 35
        -: 3338:      s, *d))
      505: 3339:    d->success[s] |= 2;
     4041: 3340:  if (ACCEPTS_IN_CONTEXT(d->states[s].newline, 0, d->states[s].letter, 0,
branch  0 taken 84 (fallthrough)
branch  1 taken 3957
branch  2 taken 540 (fallthrough)
branch  3 taken 3501
branch  4 taken 178 (fallthrough)
branch  5 taken 362
branch  6 taken 538 (fallthrough)
branch  7 taken 2
        -: 3341:      s, *d))
      538: 3342:    d->success[s] |= 1;
        -: 3343:
     4041: 3344:  MALLOC(trans, int, NOTCHAR);
call    0 returned 4041
     4041: 3345:  dfastate(s, d, trans);
call    0 returned 4041
        -: 3346:
        -: 3347:  /* Now go through the new transition table, and make sure that the trans
        -: 3348:     and fail arrays are allocated large enough to hold a pointer for the
        -: 3349:     largest state mentioned in the table. */
  1038537: 3350:  for (i = 0; i < NOTCHAR; ++i)
branch  0 taken 1034496
branch  1 taken 4041 (fallthrough)
  1034496: 3351:    if (trans[i] >= d->tralloc)
branch  0 taken 1666 (fallthrough)
branch  1 taken 1032830
        -: 3352:      {
     1666: 3353:	int oldalloc = d->tralloc;
        -: 3354:
     3382: 3355:	while (trans[i] >= d->tralloc)
branch  0 taken 1716
branch  1 taken 1666 (fallthrough)
     1716: 3356:	  d->tralloc *= 2;
     1666: 3357:	REALLOC(d->realtrans, int *, d->tralloc + 1);
call    0 returned 1666
     1666: 3358:	d->trans = d->realtrans + 1;
     1666: 3359:	REALLOC(d->fails, int *, d->tralloc);
call    0 returned 1666
     1666: 3360:	REALLOC(d->success, int, d->tralloc);
call    0 returned 1666
     1666: 3361:	REALLOC(d->newlines, int, d->tralloc);
call    0 returned 1666
     8267: 3362:	while (oldalloc < d->tralloc)
branch  0 taken 6601
branch  1 taken 1666 (fallthrough)
        -: 3363:	  {
     6601: 3364:	    d->trans[oldalloc] = NULL;
     6601: 3365:	    d->fails[oldalloc++] = NULL;
        -: 3366:	  }
        -: 3367:      }
        -: 3368:
        -: 3369:  /* Keep the newline transition in a special place so we can use it as
        -: 3370:     a sentinel. */
     4041: 3371:  d->newlines[s] = trans[eolbyte_1];
     4041: 3372:  trans[eolbyte_1] = -1;
        -: 3373:
     4041: 3374:  if (ACCEPTING(s, *d))
branch  0 taken 548 (fallthrough)
branch  1 taken 3493
      548: 3375:    d->fails[s] = trans;
        -: 3376:  else
     3493: 3377:    d->trans[s] = trans;
     4041: 3378:}
        -: 3379:
        -: 3380:static void
function build_state_zero called 504 returned 100% blocks executed 100%
      504: 3381:build_state_zero (struct dfa *d)
        -: 3382:{
      504: 3383:  d->tralloc = 1;
      504: 3384:  d->trcount = 0;
      504: 3385:  CALLOC(d->realtrans, int *, d->tralloc + 1);
call    0 returned 504
      504: 3386:  d->trans = d->realtrans + 1;
      504: 3387:  CALLOC(d->fails, int *, d->tralloc);
call    0 returned 504
      504: 3388:  MALLOC(d->success, int, d->tralloc);
call    0 returned 504
      504: 3389:  MALLOC(d->newlines, int, d->tralloc);
call    0 returned 504
      504: 3390:  build_state(0, d);
call    0 returned 504
      504: 3391:}
        -: 3392:
        -: 3393:/* Search through a buffer looking for a match to the given struct dfa.
        -: 3394:   Find the first occurrence of a string matching the regexp in the buffer,
        -: 3395:   and the shortest possible version thereof.  Return a pointer to the first
        -: 3396:   character after the match, or NULL if none is found.  Begin points to
        -: 3397:   the beginning of the buffer, and end points to the first character after
        -: 3398:   its end.  We store a newline in *end to act as a sentinel, so end had
        -: 3399:   better point somewhere valid.  Newline is a flag indicating whether to
        -: 3400:   allow newlines to be in the matching string.  If count is non-
        -: 3401:   NULL it points to a place we're supposed to increment every time we
        -: 3402:   see a newline.  Finally, if backref is non-NULL it points to a place
        -: 3403:   where we're supposed to store a 1 if backreferencing happened and the
        -: 3404:   match needs to be verified by a backtracking matcher.  Otherwise
        -: 3405:   we store a 0 in *backref. */
        -: 3406:char *
function dfaexec called 731641 returned 100% blocks executed 90%
   731641: 3407:dfaexec (struct dfa *d, char *begin, char *end,
        -: 3408:	 int newline, int *count, int *backref)
        -: 3409:{
        -: 3410:  register int s, s1, tmp;	/* Current state. */
        -: 3411:  register unsigned char *p;	/* Current input character. */
        -: 3412:  register int **trans, *t;	/* Copy of d->trans so it can be optimized
        -: 3413:				   into a register. */
   731641: 3414:  register unsigned char eol = eolbyte_1;	/* Likewise for eolbyte.  */
        -: 3415:  static int sbit[NOTCHAR];	/* Table for anding with d->success. */
        -: 3416:  static int sbit_init;
        -: 3417:
   731641: 3418:  if (! sbit_init)
branch  0 taken 504 (fallthrough)
branch  1 taken 731137
        -: 3419:    {
        -: 3420:      int i;
        -: 3421:
      504: 3422:      sbit_init = 1;
   129528: 3423:      for (i = 0; i < NOTCHAR; ++i)
branch  0 taken 129024
branch  1 taken 504 (fallthrough)
   129024: 3424:	sbit[i] = (IS_WORD_CONSTITUENT(i)) ? 2 : 1;
branch  0 taken 97776 (fallthrough)
branch  1 taken 31248
branch  2 taken 504 (fallthrough)
branch  3 taken 97272
      504: 3425:      sbit[eol] = 4;
        -: 3426:    }
        -: 3427:
   731641: 3428:  if (! d->tralloc)
branch  0 taken 504 (fallthrough)
branch  1 taken 731137
      504: 3429:    build_state_zero(d);
call    0 returned 504
        -: 3430:
   731641: 3431:  s = s1 = 0;
   731641: 3432:  p = (unsigned char *) begin;
   731641: 3433:  trans = d->trans;
   731641: 3434:  *end = eol;
        -: 3435:
        -: 3436:  for (;;)
        -: 3437:    {
 18251958: 3438:      while ((t = trans[s]) != 0) { /* hand-optimized loop */
branch  0 taken 16757156
branch  1 taken 1494802 (fallthrough)
 16757156: 3439:	s1 = t[*p++];
 16757156: 3440:        if ((t = trans[s1]) == 0) {
branch  0 taken 753364 (fallthrough)
branch  1 taken 16003792
   753364: 3441:           tmp = s ; s = s1 ; s1 = tmp ; /* swap */
   753364: 3442:           break;
        -: 3443:        }
 16003792: 3444:	s = t[*p++];
        -: 3445:      }
        -: 3446:
  2248166: 3447:      if (s >= 0 && p <= (unsigned char *) end && d->fails[s])
branch  0 taken 1204294 (fallthrough)
branch  1 taken 1043872
branch  2 taken 1204294 (fallthrough)
branch  3 taken 0
branch  4 taken 1200757 (fallthrough)
branch  5 taken 3537
        -: 3448:	{
  1200757: 3449:	  if (d->success[s] & sbit[*p])
branch  0 taken 528523 (fallthrough)
branch  1 taken 672234
        -: 3450:	    {
   528523: 3451:	      if (backref)
branch  0 taken 528523 (fallthrough)
branch  1 taken 0
   528523: 3452:		*backref = (d->states[s].backref != 0);
   528523: 3453:	      return (char *) p;
        -: 3454:	    }
        -: 3455:
   672234: 3456:	  s1 = s;
   672234: 3457:	  s = d->fails[s][*p++];
   672234: 3458:	  continue;
        -: 3459:	}
        -: 3460:
        -: 3461:      /* If the previous character was a newline, count it. */
 1047409*: 3462:      if (count && (char *) p <= end && p[-1] == eol)
branch  0 taken 0 (fallthrough)
branch  1 taken 1047409
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 3463:	++*count;
        -: 3464:
        -: 3465:      /* Check if we've run off the end of the buffer. */
  1047409: 3466:      if ((char *) p > end)
branch  0 taken 203118 (fallthrough)
branch  1 taken 844291
   203118: 3467:	return NULL;
        -: 3468:
   844291: 3469:      if (s >= 0)
branch  0 taken 3537 (fallthrough)
branch  1 taken 840754
        -: 3470:	{
     3537: 3471:	  build_state(s, d);
call    0 returned 3537
     3537: 3472:	  trans = d->trans;
     3537: 3473:	  continue;
        -: 3474:	}
        -: 3475:
  840754*: 3476:      if (p[-1] == eol && newline)
branch  0 taken 840754 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 840754
        -: 3477:	{
    #####: 3478:	  s = d->newlines[s1];
    #####: 3479:	  continue;
        -: 3480:	}
        -: 3481:
   840754: 3482:      s = 0;
        -: 3483:    }
        -: 3484:}
        -: 3485:
        -: 3486:/* Initialize the components of a dfa that the other routines don't
        -: 3487:   initialize for themselves. */
        -: 3488:void
function dfainit called 722 returned 100% blocks executed 100%
      722: 3489:dfainit (struct dfa *d)
        -: 3490:{
      722: 3491:  d->calloc = 1;
      722: 3492:  MALLOC(d->charclasses, charclass, d->calloc);
call    0 returned 722
      722: 3493:  d->cindex = 0;
        -: 3494:
      722: 3495:  d->talloc = 1;
      722: 3496:  MALLOC(d->tokens, token, d->talloc);
call    0 returned 722
      722: 3497:  d->tindex = d->depth = d->nleaves = d->nregexps = 0;
        -: 3498:
      722: 3499:  d->searchflag = 0;
      722: 3500:  d->tralloc = 0;
        -: 3501:
      722: 3502:  d->musts = 0;
      722: 3503:}
        -: 3504:
        -: 3505:/* Parse and analyze a single string of the given length. */
        -: 3506:void
function dfacomp called 722 returned 100% blocks executed 95%
      722: 3507:dfacomp (char *s, size_t len, struct dfa *d, int searchflag)
        -: 3508:{
      722: 3509:  if (case_fold)	/* dummy folding in service of dfamust() */
branch  0 taken 58 (fallthrough)
branch  1 taken 664
        -: 3510:    {
        -: 3511:      char *lcopy;
        -: 3512:      int i;
        -: 3513:
       58: 3514:      lcopy = malloc(len);
       58: 3515:      if (!lcopy)
branch  0 taken 0 (fallthrough)
branch  1 taken 58
    #####: 3516:	dfaerror(_("out of memory"));
call    0 never executed
        -: 3517:
        -: 3518:      /* This is a kludge. */
       58: 3519:      case_fold = 0;
      444: 3520:      for (i = 0; i < len; ++i)
branch  0 taken 386
branch  1 taken 58 (fallthrough)
      386: 3521:	if (ISUPPER ((unsigned char) s[i]))
branch  0 taken 27 (fallthrough)
branch  1 taken 359
       27: 3522:	  lcopy[i] = tolower ((unsigned char) s[i]);
        -: 3523:	else
      359: 3524:	  lcopy[i] = s[i];
        -: 3525:
       58: 3526:      dfainit(d);
call    0 returned 58
       58: 3527:      dfaparse(lcopy, len, d);
call    0 returned 58
       58: 3528:      free(lcopy);
       58: 3529:      dfamust(d);
call    0 returned 58
       58: 3530:      d->cindex = d->tindex = d->depth = d->nleaves = d->nregexps = 0;
       58: 3531:      case_fold = 1;
       58: 3532:      dfaparse(s, len, d);
call    0 returned 58
       58: 3533:      dfaanalyze(d, searchflag);
call    0 returned 58
        -: 3534:    }
        -: 3535:  else
        -: 3536:    {
      664: 3537:        dfainit(d);
call    0 returned 664
      664: 3538:        dfaparse(s, len, d);
call    0 returned 664
      664: 3539:	dfamust(d);
call    0 returned 664
      664: 3540:        dfaanalyze(d, searchflag);
call    0 returned 664
        -: 3541:    }
      722: 3542:}
        -: 3543:
        -: 3544:/* Free the storage held by the components of a dfa. */
        -: 3545:void
function dfafree called 0 returned 0% blocks executed 0%
    #####: 3546:dfafree (struct dfa *d)
        -: 3547:{
        -: 3548:  int i;
        -: 3549:  struct dfamust *dm, *ndm;
        -: 3550:
    #####: 3551:  free((ptr_t) d->charclasses);
    #####: 3552:  free((ptr_t) d->tokens);
    #####: 3553:  for (i = 0; i < d->sindex; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3554:    free((ptr_t) d->states[i].elems.elems);
    #####: 3555:  free((ptr_t) d->states);
    #####: 3556:  for (i = 0; i < d->tindex; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3557:    if (d->follows[i].elems)
branch  0 never executed
branch  1 never executed
    #####: 3558:      free((ptr_t) d->follows[i].elems);
    #####: 3559:  free((ptr_t) d->follows);
    #####: 3560:  for (i = 0; i < d->tralloc; ++i)
branch  0 never executed
branch  1 never executed
    #####: 3561:    if (d->trans[i])
branch  0 never executed
branch  1 never executed
    #####: 3562:      free((ptr_t) d->trans[i]);
    #####: 3563:    else if (d->fails[i])
branch  0 never executed
branch  1 never executed
    #####: 3564:      free((ptr_t) d->fails[i]);
    #####: 3565:  if (d->realtrans) free((ptr_t) d->realtrans);
branch  0 never executed
branch  1 never executed
    #####: 3566:  if (d->fails) free((ptr_t) d->fails);
branch  0 never executed
branch  1 never executed
    #####: 3567:  if (d->newlines) free((ptr_t) d->newlines);
branch  0 never executed
branch  1 never executed
    #####: 3568:  if (d->success) free((ptr_t) d->success);
branch  0 never executed
branch  1 never executed
    #####: 3569:  for (dm = d->musts; dm; dm = ndm)
branch  0 never executed
branch  1 never executed
        -: 3570:    {
    #####: 3571:      ndm = dm->next;
    #####: 3572:      free(dm->must);
    #####: 3573:      free((ptr_t) dm);
        -: 3574:    }
    #####: 3575:}
        -: 3576:
        -: 3577:/* Having found the postfix representation of the regular expression,
        -: 3578:   try to find a long sequence of characters that must appear in any line
        -: 3579:   containing the r.e.
        -: 3580:   Finding a "longest" sequence is beyond the scope here;
        -: 3581:   we take an easy way out and hope for the best.
        -: 3582:   (Take "(ab|a)b"--please.)
        -: 3583:
        -: 3584:   We do a bottom-up calculation of sequences of characters that must appear
        -: 3585:   in matches of r.e.'s represented by trees rooted at the nodes of the postfix
        -: 3586:   representation:
        -: 3587:	sequences that must appear at the left of the match ("left")
        -: 3588:	sequences that must appear at the right of the match ("right")
        -: 3589:	lists of sequences that must appear somewhere in the match ("in")
        -: 3590:	sequences that must constitute the match ("is")
        -: 3591:
        -: 3592:   When we get to the root of the tree, we use one of the longest of its
        -: 3593:   calculated "in" sequences as our answer.  The sequence we find is returned in
        -: 3594:   d->must (where "d" is the single argument passed to "dfamust");
        -: 3595:   the length of the sequence is returned in d->mustn.
        -: 3596:
        -: 3597:   The sequences calculated for the various types of node (in pseudo ANSI c)
        -: 3598:   are shown below.  "p" is the operand of unary operators (and the left-hand
        -: 3599:   operand of binary operators); "q" is the right-hand operand of binary
        -: 3600:   operators.
        -: 3601:
        -: 3602:   "ZERO" means "a zero-length sequence" below.
        -: 3603:
        -: 3604:	Type	left		right		is		in
        -: 3605:	----	----		-----		--		--
        -: 3606:	char c	# c		# c		# c		# c
        -: 3607:
        -: 3608:	CSET	ZERO		ZERO		ZERO		ZERO
        -: 3609:
        -: 3610:	STAR	ZERO		ZERO		ZERO		ZERO
        -: 3611:
        -: 3612:	QMARK	ZERO		ZERO		ZERO		ZERO
        -: 3613:
        -: 3614:	PLUS	p->left		p->right	ZERO		p->in
        -: 3615:
        -: 3616:	CAT	(p->is==ZERO)?	(q->is==ZERO)?	(p->is!=ZERO &&	p->in plus
        -: 3617:		p->left :	q->right :	q->is!=ZERO) ?	q->in plus
        -: 3618:		p->is##q->left	p->right##q->is	p->is##q->is :	p->right##q->left
        -: 3619:						ZERO
        -: 3620:
        -: 3621:	OR	longest common	longest common	(do p->is and	substrings common to
        -: 3622:		leading		trailing	q->is have same	p->in and q->in
        -: 3623:		(sub)sequence	(sub)sequence	length and
        -: 3624:		of p->left	of p->right	content) ?
        -: 3625:		and q->left	and q->right	p->is : NULL
        -: 3626:
        -: 3627:   If there's anything else we recognize in the tree, all four sequences get set
        -: 3628:   to zero-length sequences.  If there's something we don't recognize in the tree,
        -: 3629:   we just return a zero-length sequence.
        -: 3630:
        -: 3631:   Break ties in favor of infrequent letters (choosing 'zzz' in preference to
        -: 3632:   'aaa')?
        -: 3633:
        -: 3634:   And. . .is it here or someplace that we might ponder "optimizations" such as
        -: 3635:	egrep 'psi|epsilon'	->	egrep 'psi'
        -: 3636:	egrep 'pepsi|epsilon'	->	egrep 'epsi'
        -: 3637:					(Yes, we now find "epsi" as a "string
        -: 3638:					that must occur", but we might also
        -: 3639:					simplify the *entire* r.e. being sought)
        -: 3640:	grep '[c]'		->	grep 'c'
        -: 3641:	grep '(ab|a)b'		->	grep 'ab'
        -: 3642:	grep 'ab*'		->	grep 'a'
        -: 3643:	grep 'a*b'		->	grep 'b'
        -: 3644:
        -: 3645:   There are several issues:
        -: 3646:
        -: 3647:   Is optimization easy (enough)?
        -: 3648:
        -: 3649:   Does optimization actually accomplish anything,
        -: 3650:   or is the automaton you get from "psi|epsilon" (for example)
        -: 3651:   the same as the one you get from "psi" (for example)?
        -: 3652:
        -: 3653:   Are optimizable r.e.'s likely to be used in real-life situations
        -: 3654:   (something like 'ab*' is probably unlikely; something like is
        -: 3655:   'psi|epsilon' is likelier)? */
        -: 3656:
        -: 3657:static char *
function icatalloc called 31613 returned 100% blocks executed 94%
    31613: 3658:icatalloc (char *old, char *new)
        -: 3659:{
        -: 3660:  char *result;
        -: 3661:  size_t oldsize, newsize;
        -: 3662:
   31613*: 3663:  newsize = (new == NULL) ? 0 : strlen(new);
branch  0 taken 31613 (fallthrough)
branch  1 taken 0
    31613: 3664:  if (old == NULL)
branch  0 taken 18960 (fallthrough)
branch  1 taken 12653
    18960: 3665:    oldsize = 0;
    12653: 3666:  else if (newsize == 0)
branch  0 taken 390 (fallthrough)
branch  1 taken 12263
      390: 3667:    return old;
    12263: 3668:  else	oldsize = strlen(old);
    31223: 3669:  if (old == NULL)
branch  0 taken 18960 (fallthrough)
branch  1 taken 12263
    18960: 3670:    result = (char *) malloc(newsize + 1);
        -: 3671:  else
    12263: 3672:    result = (char *) realloc((void *) old, oldsize + newsize + 1);
    31223: 3673:  if (result != NULL && new != NULL)
branch  0 taken 31223 (fallthrough)
branch  1 taken 0
branch  2 taken 31223 (fallthrough)
branch  3 taken 0
    31223: 3674:    (void) strcpy(result + oldsize, new);
    31223: 3675:  return result;
        -: 3676:}
        -: 3677:
        -: 3678:static char *
function icpyalloc called 18960 returned 100% blocks executed 100%
    18960: 3679:icpyalloc (char *string)
        -: 3680:{
    18960: 3681:  return icatalloc((char *) NULL, string);
call    0 returned 18960
        -: 3682:}
        -: 3683:
        -: 3684:static char *
function istrstr called 25874 returned 100% blocks executed 100%
    25874: 3685:istrstr (char *lookin, char *lookfor)
        -: 3686:{
        -: 3687:  char *cp;
        -: 3688:  size_t len;
        -: 3689:
    25874: 3690:  len = strlen(lookfor);
    85329: 3691:  for (cp = lookin; *cp != '\0'; ++cp)
branch  0 taken 67824
branch  1 taken 17505 (fallthrough)
    67824: 3692:    if (strncmp(cp, lookfor, len) == 0)
branch  0 taken 8369 (fallthrough)
branch  1 taken 59455
     8369: 3693:      return cp;
    17505: 3694:  return NULL;
        -: 3695:}
        -: 3696:
        -: 3697:static void
function ifree called 54736 returned 100% blocks executed 100%
    54736: 3698:ifree (char *cp)
        -: 3699:{
    54736: 3700:  if (cp != NULL)
branch  0 taken 54736 (fallthrough)
branch  1 taken 0
    54736: 3701:    free(cp);
    54736: 3702:}
        -: 3703:
        -: 3704:static void
function freelist called 20632 returned 100% blocks executed 83%
    20632: 3705:freelist (char **cpp)
        -: 3706:{
        -: 3707:  int i;
        -: 3708:
    20632: 3709:  if (cpp == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 20632
    #####: 3710:    return;
    27263: 3711:  for (i = 0; cpp[i] != NULL; ++i)
branch  0 taken 6631
branch  1 taken 20632 (fallthrough)
        -: 3712:    {
     6631: 3713:      free(cpp[i]);
     6631: 3714:      cpp[i] = NULL;
        -: 3715:    }
        -: 3716:}
        -: 3717:
        -: 3718:static char **
function enlist called 15000 returned 100% blocks executed 83%
    15000: 3719:enlist (char **cpp, char *new, size_t len)
        -: 3720:{
        -: 3721:  int i, j;
        -: 3722:
    15000: 3723:  if (cpp == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 15000
    #####: 3724:    return NULL;
    15000: 3725:  if ((new = icpyalloc(new)) == NULL)
call    0 returned 15000
branch  1 taken 0 (fallthrough)
branch  2 taken 15000
        -: 3726:    {
    #####: 3727:      freelist(cpp);
call    0 never executed
    #####: 3728:      return NULL;
        -: 3729:    }
    15000: 3730:  new[len] = '\0';
        -: 3731:  /* Is there already something in the list that's new (or longer)? */
    27534: 3732:  for (i = 0; cpp[i] != NULL; ++i)
branch  0 taken 13341
branch  1 taken 14193 (fallthrough)
    13341: 3733:    if (istrstr(cpp[i], new) != NULL)
call    0 returned 13341
branch  1 taken 807 (fallthrough)
branch  2 taken 12534
        -: 3734:      {
      807: 3735:	free(new);
      807: 3736:	return cpp;
        -: 3737:      }
        -: 3738:  /* Eliminate any obsoleted strings. */
    14193: 3739:  j = 0;
    22766: 3740:  while (cpp[j] != NULL)
branch  0 taken 12533
branch  1 taken 10233 (fallthrough)
    12533: 3741:    if (istrstr(new, cpp[j]) == NULL)
call    0 returned 12533
branch  1 taken 4971 (fallthrough)
branch  2 taken 7562
     4971: 3742:      ++j;
        -: 3743:    else
        -: 3744:      {
     7562: 3745:	free(cpp[j]);
     7562: 3746:	if (--i == j)
branch  0 taken 3960 (fallthrough)
branch  1 taken 3602
     3960: 3747:	  break;
     3602: 3748:	cpp[j] = cpp[i];
     3602: 3749:	cpp[i] = NULL;
        -: 3750:      }
        -: 3751:  /* Add the new string. */
    14193: 3752:  cpp = (char **) realloc((char *) cpp, (i + 2) * sizeof *cpp);
    14193: 3753:  if (cpp == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 14193
    #####: 3754:    return NULL;
    14193: 3755:  cpp[i] = new;
    14193: 3756:  cpp[i + 1] = NULL;
    14193: 3757:  return cpp;
        -: 3758:}
        -: 3759:
        -: 3760:/* Given pointers to two strings, return a pointer to an allocated
        -: 3761:   list of their distinct common substrings. Return NULL if something
        -: 3762:   seems wild. */
        -: 3763:static char **
function comsubs called 537 returned 100% blocks executed 88%
      537: 3764:comsubs (char *left, char *right)
      853: 3765:{
        -: 3766:  char **cpp;
        -: 3767:  char *lcp;
        -: 3768:  char *rcp;
        -: 3769:  size_t i, len;
        -: 3770:
      537: 3771:  if (left == NULL || right == NULL)
branch  0 taken 537 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 537
    #####: 3772:    return NULL;
      537: 3773:  cpp = (char **) malloc(sizeof *cpp);
      537: 3774:  if (cpp == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 537
    #####: 3775:    return NULL;
      537: 3776:  cpp[0] = NULL;
     2474: 3777:  for (lcp = left; *lcp != '\0'; ++lcp)
branch  0 taken 1937
branch  1 taken 537 (fallthrough)
        -: 3778:    {
     1937: 3779:      len = 0;
     1937: 3780:      rcp = index(right, *lcp);
     2699: 3781:      while (rcp != NULL)
branch  0 taken 762
branch  1 taken 1937 (fallthrough)
        -: 3782:	{
     1615: 3783:	  for (i = 1; lcp[i] != '\0' && lcp[i] == rcp[i]; ++i)
branch  0 taken 1247 (fallthrough)
branch  1 taken 368
branch  2 taken 853
branch  3 taken 394 (fallthrough)
      853: 3784:	    continue;
      762: 3785:	  if (i > len)
branch  0 taken 762 (fallthrough)
branch  1 taken 0
      762: 3786:	    len = i;
      762: 3787:	  rcp = index(rcp + 1, *lcp);
        -: 3788:	}
     1937: 3789:      if (len == 0)
branch  0 taken 1175 (fallthrough)
branch  1 taken 762
     1175: 3790:	continue;
      762: 3791:      if ((cpp = enlist(cpp, lcp, len)) == NULL)
call    0 returned 762
branch  1 taken 0 (fallthrough)
branch  2 taken 762
    #####: 3792:	break;
        -: 3793:    }
      537: 3794:  return cpp;
        -: 3795:}
        -: 3796:
        -: 3797:static char **
function addlists called 5464 returned 100% blocks executed 82%
     5464: 3798:addlists (char **old, char **new)
        -: 3799:{
        -: 3800:  int i;
        -: 3801:
     5464: 3802:  if (old == NULL || new == NULL)
branch  0 taken 5464 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 5464
    #####: 3803:    return NULL;
    10425: 3804:  for (i = 0; new[i] != NULL; ++i)
branch  0 taken 4961
branch  1 taken 5464 (fallthrough)
        -: 3805:    {
     4961: 3806:      old = enlist(old, new[i], strlen(new[i]));
call    0 returned 4961
     4961: 3807:      if (old == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 4961
    #####: 3808:	break;
        -: 3809:    }
     5464: 3810:  return old;
        -: 3811:}
        -: 3812:
        -: 3813:/* Given two lists of substrings, return a new list giving substrings
        -: 3814:   common to both. */
        -: 3815:static char **
function inboth called 282 returned 100% blocks executed 76%
      282: 3816:inboth (char **left, char **right)
        -: 3817:{
        -: 3818:  char **both;
        -: 3819:  char **temp;
        -: 3820:  int lnum, rnum;
        -: 3821:
      282: 3822:  if (left == NULL || right == NULL)
branch  0 taken 282 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 282
    #####: 3823:    return NULL;
      282: 3824:  both = (char **) malloc(sizeof *both);
      282: 3825:  if (both == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 282
    #####: 3826:    return NULL;
      282: 3827:  both[0] = NULL;
      675: 3828:  for (lnum = 0; left[lnum] != NULL; ++lnum)
branch  0 taken 393
branch  1 taken 282 (fallthrough)
        -: 3829:    {
      930: 3830:      for (rnum = 0; right[rnum] != NULL; ++rnum)
branch  0 taken 537
branch  1 taken 393 (fallthrough)
        -: 3831:	{
      537: 3832:	  temp = comsubs(left[lnum], right[rnum]);
call    0 returned 537
      537: 3833:	  if (temp == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 537
        -: 3834:	    {
    #####: 3835:	      freelist(both);
call    0 never executed
    #####: 3836:	      return NULL;
        -: 3837:	    }
      537: 3838:	  both = addlists(both, temp);
call    0 returned 537
      537: 3839:	  freelist(temp);
call    0 returned 537
      537: 3840:	  free(temp);
      537: 3841:	  if (both == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 537
    #####: 3842:	    return NULL;
        -: 3843:	}
        -: 3844:    }
      282: 3845:  return both;
        -: 3846:}
        -: 3847:
        -: 3848:typedef struct
        -: 3849:{
        -: 3850:  char **in;
        -: 3851:  char *left;
        -: 3852:  char *right;
        -: 3853:  char *is;
        -: 3854:} must;
        -: 3855:
        -: 3856:static void
function resetmust called 6129 returned 100% blocks executed 100%
     6129: 3857:resetmust (must *mp)
        -: 3858:{
     6129: 3859:  mp->left[0] = mp->right[0] = mp->is[0] = '\0';
     6129: 3860:  freelist(mp->in);
call    0 returned 6129
     6129: 3861:}
        -: 3862:
        -: 3863:static void
function dfamust called 722 returned 100% blocks executed 82%
      722: 3864:dfamust (struct dfa *dfa)
        -: 3865:{
        -: 3866:  must *musts;
        -: 3867:  must *mp;
        -: 3868:  char *result;
        -: 3869:  int ri;
        -: 3870:  int i;
        -: 3871:  int exact;
        -: 3872:  token t;
        -: 3873:  static must must0;
        -: 3874:  struct dfamust *dm;
        -: 3875:  static char empty_string[] = "";
        -: 3876:
      722: 3877:  result = empty_string;
      722: 3878:  exact = 0;
      722: 3879:  musts = (must *) malloc((dfa->tindex + 1) * sizeof *musts);
      722: 3880:  if (musts == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 722
    #####: 3881:    return;
      722: 3882:  mp = musts;
    14406: 3883:  for (i = 0; i <= dfa->tindex; ++i)
branch  0 taken 13684
branch  1 taken 722 (fallthrough)
    13684: 3884:    mp[i] = must0;
    14406: 3885:  for (i = 0; i <= dfa->tindex; ++i)
branch  0 taken 13684
branch  1 taken 722 (fallthrough)
        -: 3886:    {
    13684: 3887:      mp[i].in = (char **) malloc(sizeof *mp[i].in);
    13684: 3888:      mp[i].left = malloc(2);
    13684: 3889:      mp[i].right = malloc(2);
    13684: 3890:      mp[i].is = malloc(2);
    13684: 3891:      if (mp[i].in == NULL || mp[i].left == NULL ||
branch  0 taken 13684 (fallthrough)
branch  1 taken 0
branch  2 taken 13684 (fallthrough)
branch  3 taken 0
    13684: 3892:	  mp[i].right == NULL || mp[i].is == NULL)
branch  0 taken 13684 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 13684
    #####: 3893:	goto done;
    13684: 3894:      mp[i].left[0] = mp[i].right[0] = mp[i].is[0] = '\0';
    13684: 3895:      mp[i].in[0] = NULL;
        -: 3896:    }
        -: 3897:#ifdef DEBUG
        -: 3898:  fprintf(stderr, "dfamust:\n");
        -: 3899:  for (i = 0; i < dfa->tindex; ++i)
        -: 3900:    {
        -: 3901:      fprintf(stderr, " %d:", i);
        -: 3902:      prtok(dfa->tokens[i]);
        -: 3903:    }
        -: 3904:  putc('\n', stderr);
        -: 3905:#endif
    12240: 3906:  for (ri = 0; ri < dfa->tindex; ++ri)
branch  0 taken 12240
branch  1 taken 0 (fallthrough)
        -: 3907:    {
    12240: 3908:      switch (t = dfa->tokens[ri])
branch  0 taken 0
branch  1 taken 459
branch  2 taken 198
branch  3 taken 282
branch  4 taken 180
branch  5 taken 722
branch  6 taken 4927
branch  7 taken 5472
        -: 3909:	{
    #####: 3910:	case LPAREN:
        -: 3911:	case RPAREN:
    #####: 3912:	  goto done;		/* "cannot happen" */
      459: 3913:	case EMPTY:
        -: 3914:	case BEGLINE:
        -: 3915:	case ENDLINE:
        -: 3916:	case BEGWORD:
        -: 3917:	case ENDWORD:
        -: 3918:	case LIMWORD:
        -: 3919:	case NOTLIMWORD:
        -: 3920:	case BACKREF:
      459: 3921:	  resetmust(mp);
call    0 returned 459
      459: 3922:	  break;
      198: 3923:	case STAR:
        -: 3924:	case QMARK:
      198: 3925:	  if (mp <= musts)
branch  0 taken 0 (fallthrough)
branch  1 taken 198
    #####: 3926:	    goto done;		/* "cannot happen" */
      198: 3927:	  --mp;
      198: 3928:	  resetmust(mp);
call    0 returned 198
      198: 3929:	  break;
      282: 3930:	case OR:
        -: 3931:	case ORTOP:
      282: 3932:	  if (mp < &musts[2])
branch  0 taken 0 (fallthrough)
branch  1 taken 282
    #####: 3933:	    goto done;		/* "cannot happen" */
        -: 3934:	  {
        -: 3935:	    char **new;
        -: 3936:	    must *lmp;
        -: 3937:	    must *rmp;
        -: 3938:	    int j, ln, rn, n;
        -: 3939:
      282: 3940:	    rmp = --mp;
      282: 3941:	    lmp = --mp;
        -: 3942:	    /* Guaranteed to be.  Unlikely, but. . . */
      282: 3943:	    if (strcmp(lmp->is, rmp->is) != 0)
branch  0 taken 121 (fallthrough)
branch  1 taken 161
      121: 3944:	      lmp->is[0] = '\0';
        -: 3945:	    /* Left side--easy */
      282: 3946:	    i = 0;
      282: 3947:	    while (lmp->left[i] != '\0' && lmp->left[i] == rmp->left[i])
branch  0 taken 130 (fallthrough)
branch  1 taken 152
branch  2 taken 0
branch  3 taken 130 (fallthrough)
    #####: 3948:	      ++i;
      282: 3949:	    lmp->left[i] = '\0';
        -: 3950:	    /* Right side */
      282: 3951:	    ln = strlen(lmp->right);
      282: 3952:	    rn = strlen(rmp->right);
      282: 3953:	    n = ln;
      282: 3954:	    if (n > rn)
branch  0 taken 136 (fallthrough)
branch  1 taken 146
      136: 3955:	      n = rn;
      331: 3956:	    for (i = 0; i < n; ++i)
branch  0 taken 263
branch  1 taken 68 (fallthrough)
      263: 3957:	      if (lmp->right[ln - i - 1] != rmp->right[rn - i - 1])
branch  0 taken 214 (fallthrough)
branch  1 taken 49
      214: 3958:		break;
      331: 3959:	    for (j = 0; j < i; ++j)
branch  0 taken 49
branch  1 taken 282 (fallthrough)
       49: 3960:	      lmp->right[j] = lmp->right[(ln - i) + j];
      282: 3961:	    lmp->right[j] = '\0';
      282: 3962:	    new = inboth(lmp->in, rmp->in);
call    0 returned 282
      282: 3963:	    if (new == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 282
    #####: 3964:	      goto done;
      282: 3965:	    freelist(lmp->in);
call    0 returned 282
      282: 3966:	    free((char *) lmp->in);
      282: 3967:	    lmp->in = new;
        -: 3968:	  }
      282: 3969:	  break;
      180: 3970:	case PLUS:
      180: 3971:	  if (mp <= musts)
branch  0 taken 0 (fallthrough)
branch  1 taken 180
    #####: 3972:	    goto done;		/* "cannot happen" */
      180: 3973:	  --mp;
      180: 3974:	  mp->is[0] = '\0';
      180: 3975:	  break;
      722: 3976:	case END:
      722: 3977:	  if (mp != &musts[1])
branch  0 taken 0 (fallthrough)
branch  1 taken 722
    #####: 3978:	    goto done;		/* "cannot happen" */
     1461: 3979:	  for (i = 0; musts[0].in[i] != NULL; ++i)
branch  0 taken 739
branch  1 taken 722 (fallthrough)
      739: 3980:	    if (strlen(musts[0].in[i]) > strlen(result))
branch  0 taken 681 (fallthrough)
branch  1 taken 58
      681: 3981:	      result = musts[0].in[i];
      722: 3982:	  if (strcmp(result, musts[0].is) == 0)
branch  0 taken 337 (fallthrough)
branch  1 taken 385
      337: 3983:	    exact = 1;
      722: 3984:	  goto done;
     4927: 3985:	case CAT:
     4927: 3986:	  if (mp < &musts[2])
branch  0 taken 0 (fallthrough)
branch  1 taken 4927
    #####: 3987:	    goto done;		/* "cannot happen" */
        -: 3988:	  {
        -: 3989:	    must *lmp;
        -: 3990:	    must *rmp;
        -: 3991:
     4927: 3992:	    rmp = --mp;
     4927: 3993:	    lmp = --mp;
        -: 3994:	    /* In.  Everything in left, plus everything in
        -: 3995:	       right, plus catenation of
        -: 3996:	       left's right and right's left. */
     4927: 3997:	    lmp->in = addlists(lmp->in, rmp->in);
call    0 returned 4927
     4927: 3998:	    if (lmp->in == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 4927
    #####: 3999:	      goto done;
     4927: 4000:	    if (lmp->right[0] != '\0' &&
branch  0 taken 4253 (fallthrough)
branch  1 taken 674
     4253: 4001:		rmp->left[0] != '\0')
branch  0 taken 3960 (fallthrough)
branch  1 taken 293
        -: 4002:	      {
        -: 4003:		char *tp;
        -: 4004:
     3960: 4005:		tp = icpyalloc(lmp->right);
call    0 returned 3960
     3960: 4006:		if (tp == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 3960
    #####: 4007:		  goto done;
     3960: 4008:		tp = icatalloc(tp, rmp->left);
call    0 returned 3960
     3960: 4009:		if (tp == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 3960
    #####: 4010:		  goto done;
     3960: 4011:		lmp->in = enlist(lmp->in, tp,
call    0 returned 3960
        -: 4012:				 strlen(tp));
     3960: 4013:		free(tp);
     3960: 4014:		if (lmp->in == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 3960
    #####: 4015:		  goto done;
        -: 4016:	      }
        -: 4017:	    /* Left-hand */
     4927: 4018:	    if (lmp->is[0] != '\0')
branch  0 taken 1953 (fallthrough)
branch  1 taken 2974
        -: 4019:	      {
     1953: 4020:		lmp->left = icatalloc(lmp->left,
call    0 returned 1953
        -: 4021:				      rmp->left);
     1953: 4022:		if (lmp->left == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1953
    #####: 4023:		  goto done;
        -: 4024:	      }
        -: 4025:	    /* Right-hand */
     4927: 4026:	    if (rmp->is[0] == '\0')
branch  0 taken 437 (fallthrough)
branch  1 taken 4490
      437: 4027:	      lmp->right[0] = '\0';
     4927: 4028:	    lmp->right = icatalloc(lmp->right, rmp->right);
call    0 returned 4927
     4927: 4029:	    if (lmp->right == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 4927
    #####: 4030:	      goto done;
        -: 4031:	    /* Guaranteed to be */
     4927: 4032:	    if (lmp->is[0] != '\0' && rmp->is[0] != '\0')
branch  0 taken 1953 (fallthrough)
branch  1 taken 2974
branch  2 taken 1813 (fallthrough)
branch  3 taken 140
        -: 4033:	      {
     1813: 4034:		lmp->is = icatalloc(lmp->is, rmp->is);
call    0 returned 1813
     1813: 4035:		if (lmp->is == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 1813
    #####: 4036:		  goto done;
        -: 4037:	      }
        -: 4038:	    else
     3114: 4039:	      lmp->is[0] = '\0';
        -: 4040:	  }
     4927: 4041:	  break;
     5472: 4042:	default:
     5472: 4043:	  if (t < END)
branch  0 taken 0 (fallthrough)
branch  1 taken 5472
        -: 4044:	    {
        -: 4045:	      /* "cannot happen" */
    #####: 4046:	      goto done;
        -: 4047:	    }
     5472: 4048:	  else if (t == '\0')
branch  0 taken 0 (fallthrough)
branch  1 taken 5472
        -: 4049:	    {
        -: 4050:	      /* not on *my* shift */
    #####: 4051:	      goto done;
        -: 4052:	    }
     5472: 4053:	  else if (t >= CSET)
branch  0 taken 155 (fallthrough)
branch  1 taken 5317
        -: 4054:	    {
        -: 4055:	      /* easy enough */
      155: 4056:	      resetmust(mp);
call    0 returned 155
        -: 4057:	    }
        -: 4058:	  else
        -: 4059:	    {
        -: 4060:	      /* plain character */
     5317: 4061:	      resetmust(mp);
call    0 returned 5317
     5317: 4062:	      mp->is[0] = mp->left[0] = mp->right[0] = t;
     5317: 4063:	      mp->is[1] = mp->left[1] = mp->right[1] = '\0';
     5317: 4064:	      mp->in = enlist(mp->in, mp->is, (size_t)1);
call    0 returned 5317
     5317: 4065:	      if (mp->in == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 5317
    #####: 4066:		goto done;
        -: 4067:	    }
     5472: 4068:	  break;
        -: 4069:	}
        -: 4070:#ifdef DEBUG
        -: 4071:      fprintf(stderr, " node: %d:", ri);
        -: 4072:      prtok(dfa->tokens[ri]);
        -: 4073:      fprintf(stderr, "\n  in:");
        -: 4074:      for (i = 0; mp->in[i]; ++i)
        -: 4075:	fprintf(stderr, " \"%s\"", mp->in[i]);
        -: 4076:      fprintf(stderr, "\n  is: \"%s\"\n", mp->is);
        -: 4077:      fprintf(stderr, "  left: \"%s\"\n", mp->left);
        -: 4078:      fprintf(stderr, "  right: \"%s\"\n", mp->right);
        -: 4079:#endif
    11518: 4080:      ++mp;
        -: 4081:    }
    #####: 4082: done:
      722: 4083:  if (strlen(result))
branch  0 taken 593 (fallthrough)
branch  1 taken 129
        -: 4084:    {
      593: 4085:      dm = (struct dfamust *) malloc(sizeof (struct dfamust));
      593: 4086:      dm->exact = exact;
      593: 4087:      dm->must = malloc(strlen(result) + 1);
      593: 4088:      strcpy(dm->must, result);
      593: 4089:      dm->next = dfa->musts;
      593: 4090:      dfa->musts = dm;
        -: 4091:    }
      722: 4092:  mp = musts;
    14406: 4093:  for (i = 0; i <= dfa->tindex; ++i)
branch  0 taken 13684
branch  1 taken 722 (fallthrough)
        -: 4094:    {
    13684: 4095:      freelist(mp[i].in);
call    0 returned 13684
    13684: 4096:      ifree((char *) mp[i].in);
call    0 returned 13684
    13684: 4097:      ifree(mp[i].left);
call    0 returned 13684
    13684: 4098:      ifree(mp[i].right);
call    0 returned 13684
    13684: 4099:      ifree(mp[i].is);
call    0 returned 13684
        -: 4100:    }
      722: 4101:  free((char *) mp);
        -: 4102:}
        -: 4103:/* kwset.c - search for any of a set of keywords.
        -: 4104:   Copyright 1989, 1998, 2000 Free Software Foundation, Inc.
        -: 4105:
        -: 4106:   This program is free software; you can redistribute it and/or modify
        -: 4107:   it under the terms of the GNU General Public License as published by
        -: 4108:   the Free Software Foundation; either version 2, or (at your option)
        -: 4109:   any later version.
        -: 4110:
        -: 4111:   This program is distributed in the hope that it will be useful,
        -: 4112:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4113:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 4114:   GNU General Public License for more details.
        -: 4115:
        -: 4116:   You should have received a copy of the GNU General Public License
        -: 4117:   along with this program; if not, write to the Free Software
        -: 4118:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
        -: 4119:   02111-1307, USA.  */
        -: 4120:
        -: 4121:/* Written August 1989 by Mike Haertel.
        -: 4122:   The author may be reached (Email) at the address mike@ai.mit.edu,
        -: 4123:   or (US mail) as Mike Haertel c/o Free Software Foundation. */
        -: 4124:
        -: 4125:/* The algorithm implemented by these routines bears a startling resemblence
        -: 4126:   to one discovered by Beate Commentz-Walter, although it is not identical.
        -: 4127:   See "A String Matching Algorithm Fast on the Average," Technical Report,
        -: 4128:   IBM-Germany, Scientific Center Heidelberg, Tiergartenstrasse 15, D-6900
        -: 4129:   Heidelberg, Germany.  See also Aho, A.V., and M. Corasick, "Efficient
        -: 4130:   String Matching:  An Aid to Bibliographic Search," CACM June 1975,
        -: 4131:   Vol. 18, No. 6, which describes the failure function used below. */
        -: 4132:
        -: 4133:#ifdef HAVE_CONFIG_H
        -: 4134:#if flag_config==0
        -: 4135:# include <config.h>
        -: 4136:#define flag_config 1
        -: 4137:#endif
        -: 4138:#endif
        -: 4139:/*#include <sys/types.h>*/
        -: 4140:/*#include "system.h"*/
        -: 4141:#include "kwset.h"
        -: 4142:#include "obstack.h"
        -: 4143:
        -: 4144:#ifdef GREP
        -: 4145:extern char *xmalloc();
        -: 4146:# undef malloc
        -: 4147:# define malloc xmalloc
        -: 4148:#endif
        -: 4149:
        -: 4150:#define NCHAR (UCHAR_MAX + 1)
        -: 4151:#define obstack_chunk_alloc malloc
        -: 4152:#define obstack_chunk_free free
        -: 4153:
        -: 4154:/* Balanced tree of edges and labels leaving a given trie node. */
        -: 4155:struct tree
        -: 4156:{
        -: 4157:  struct tree *llink;		/* Left link; MUST be first field. */
        -: 4158:  struct tree *rlink;		/* Right link (to larger labels). */
        -: 4159:  struct trie *trie;		/* Trie node pointed to by this edge. */
        -: 4160:  unsigned char label;		/* Label on this edge. */
        -: 4161:  char balance;			/* Difference in depths of subtrees. */
        -: 4162:};
        -: 4163:
        -: 4164:/* Node of a trie representing a set of reversed keywords. */
        -: 4165:struct trie
        -: 4166:{
        -: 4167:  unsigned int accepting;	/* Word index of accepted word, or zero. */
        -: 4168:  struct tree *links;		/* Tree of edges leaving this node. */
        -: 4169:  struct trie *parent;		/* Parent of this node. */
        -: 4170:  struct trie *next;		/* List of all trie nodes in level order. */
        -: 4171:  struct trie *fail;		/* Aho-Corasick failure function. */
        -: 4172:  int depth;			/* Depth of this node from the root. */
        -: 4173:  int shift;			/* Shift function for search failures. */
        -: 4174:  int maxshift;			/* Max shift of self and descendents. */
        -: 4175:};
        -: 4176:
        -: 4177:/* Structure returned opaquely to the caller, containing everything. */
        -: 4178:struct kwset
        -: 4179:{
        -: 4180:  struct obstack obstack;	/* Obstack for node allocation. */
        -: 4181:  int words;			/* Number of words in the trie. */
        -: 4182:  struct trie *trie;		/* The trie itself. */
        -: 4183:  int mind;			/* Minimum depth of an accepting node. */
        -: 4184:  int maxd;			/* Maximum depth of any node. */
        -: 4185:  unsigned char delta[NCHAR];	/* Delta table for rapid search. */
        -: 4186:  struct trie *next[NCHAR];	/* Table of children of the root. */
        -: 4187:  char *target;			/* Target string if there's only one. */
        -: 4188:  int mind2;			/* Used in Boyer-Moore search for one string. */
        -: 4189:  char *trans;			/* Character translation table. */
        -: 4190:};
        -: 4191:
        -: 4192:/* prototypes */
        -: 4193:static void enqueue PARAMS((struct tree *, struct trie **));
        -: 4194:static void treefails PARAMS((register struct tree *, struct trie *, struct trie *));
        -: 4195:static void treedelta PARAMS((register struct tree *,register unsigned int, unsigned char *));
        -: 4196:static int  hasevery PARAMS((register struct tree *, register struct tree *));
        -: 4197:static void treenext PARAMS((struct tree *, struct trie **));
        -: 4198:static char * bmexec PARAMS((kwset_t, char *, size_t));
        -: 4199:static char * cwexec PARAMS((kwset_t, char *, size_t, struct kwsmatch *));
        -: 4200:
        -: 4201:/* Allocate and initialize a keyword set object, returning an opaque
        -: 4202:   pointer to it.  Return NULL if memory is not available. */
        -: 4203:kwset_t
function kwsalloc called 598 returned 100% blocks executed 60%
      598: 4204:kwsalloc (char *trans)
        -: 4205:{
        -: 4206:  struct kwset *kwset;
        -: 4207:
      598: 4208:  kwset = (struct kwset *) malloc(sizeof (struct kwset));
call    0 returned 598
      598: 4209:  if (!kwset)
branch  0 taken 0 (fallthrough)
branch  1 taken 598
    #####: 4210:    return 0;
        -: 4211:
      598: 4212:  obstack_init(&kwset->obstack);
call    0 returned 598
      598: 4213:  kwset->words = 0;
        -: 4214:  kwset->trie
     598*: 4215:    = (struct trie *) obstack_alloc(&kwset->obstack, sizeof (struct trie));
branch  0 taken 0 (fallthrough)
branch  1 taken 598
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 598
branch  5 taken 0 (fallthrough)
branch  6 taken 598
      598: 4216:  if (!kwset->trie)
branch  0 taken 0 (fallthrough)
branch  1 taken 598
        -: 4217:    {
    #####: 4218:      kwsfree((kwset_t) kwset);
call    0 never executed
    #####: 4219:      return 0;
        -: 4220:    }
      598: 4221:  kwset->trie->accepting = 0;
      598: 4222:  kwset->trie->links = 0;
      598: 4223:  kwset->trie->parent = 0;
      598: 4224:  kwset->trie->next = 0;
      598: 4225:  kwset->trie->fail = 0;
      598: 4226:  kwset->trie->depth = 0;
      598: 4227:  kwset->trie->shift = 0;
      598: 4228:  kwset->mind = INT_MAX;
      598: 4229:  kwset->maxd = -1;
      598: 4230:  kwset->target = 0;
      598: 4231:  kwset->trans = trans;
        -: 4232:
      598: 4233:  return (kwset_t) kwset;
        -: 4234:}
        -: 4235:
        -: 4236:/* Add the given string to the contents of the keyword set.  Return NULL
        -: 4237:   for success, an error message otherwise. */
        -: 4238:char *
function kwsincr called 598 returned 100% blocks executed 43%
      598: 4239:kwsincr (kwset_t kws, char *text, size_t len)
        -: 4240:{
        -: 4241:  struct kwset *kwset;
        -: 4242:  register struct trie *trie;
        -: 4243:  register unsigned char label;
        -: 4244:  register struct tree *link;
        -: 4245:  register int depth;
        -: 4246:  struct tree *links[12];
        -: 4247:  enum { L, R } dirs[12];
        -: 4248:  struct tree *t, *r, *l, *rl, *lr;
        -: 4249:
      598: 4250:  kwset = (struct kwset *) kws;
      598: 4251:  trie = kwset->trie;
      598: 4252:  text += len;
        -: 4253:
        -: 4254:  /* Descend the trie (built of reversed keywords) character-by-character,
        -: 4255:     installing new nodes when necessary. */
     3420: 4256:  while (len--)
branch  0 taken 2822
branch  1 taken 598 (fallthrough)
        -: 4257:    {
     2822: 4258:      label = kwset->trans ? kwset->trans[(unsigned char) *--text] : *--text;
branch  0 taken 369 (fallthrough)
branch  1 taken 2453
        -: 4259:
        -: 4260:      /* Descend the tree of outgoing links for this trie node,
        -: 4261:	 looking for the current character and keeping track
        -: 4262:	 of the path followed. */
     2822: 4263:      link = trie->links;
     2822: 4264:      links[0] = (struct tree *) &trie->links;
     2822: 4265:      dirs[0] = L;
     2822: 4266:      depth = 1;
        -: 4267:
    2822*: 4268:      while (link && label != link->label)
branch  0 taken 0 (fallthrough)
branch  1 taken 2822
branch  2 never executed
branch  3 never executed
        -: 4269:	{
    #####: 4270:	  links[depth] = link;
    #####: 4271:	  if (label < link->label)
branch  0 never executed
branch  1 never executed
    #####: 4272:	    dirs[depth++] = L, link = link->llink;
        -: 4273:	  else
    #####: 4274:	    dirs[depth++] = R, link = link->rlink;
        -: 4275:	}
        -: 4276:
        -: 4277:      /* The current character doesn't have an outgoing link at
        -: 4278:	 this trie node, so build a new trie node and install
        -: 4279:	 a link in the current trie node's tree. */
     2822: 4280:      if (!link)
branch  0 taken 2822 (fallthrough)
branch  1 taken 0
        -: 4281:	{
    2822*: 4282:	  link = (struct tree *) obstack_alloc(&kwset->obstack,
branch  0 taken 0 (fallthrough)
branch  1 taken 2822
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 2822
branch  5 taken 0 (fallthrough)
branch  6 taken 2822
        -: 4283:					       sizeof (struct tree));
     2822: 4284:	  if (!link)
branch  0 taken 0 (fallthrough)
branch  1 taken 2822
    #####: 4285:	    return _("memory exhausted");
     2822: 4286:	  link->llink = 0;
     2822: 4287:	  link->rlink = 0;
    2822*: 4288:	  link->trie = (struct trie *) obstack_alloc(&kwset->obstack,
branch  0 taken 3 (fallthrough)
branch  1 taken 2819
call    2 returned 3
branch  3 taken 0 (fallthrough)
branch  4 taken 2822
branch  5 taken 0 (fallthrough)
branch  6 taken 2822
        -: 4289:						     sizeof (struct trie));
     2822: 4290:	  if (!link->trie)
branch  0 taken 0 (fallthrough)
branch  1 taken 2822
    #####: 4291:	    return _("memory exhausted");
     2822: 4292:	  link->trie->accepting = 0;
     2822: 4293:	  link->trie->links = 0;
     2822: 4294:	  link->trie->parent = trie;
     2822: 4295:	  link->trie->next = 0;
     2822: 4296:	  link->trie->fail = 0;
     2822: 4297:	  link->trie->depth = trie->depth + 1;
     2822: 4298:	  link->trie->shift = 0;
     2822: 4299:	  link->label = label;
     2822: 4300:	  link->balance = 0;
        -: 4301:
        -: 4302:	  /* Install the new tree node in its parent. */
     2822: 4303:	  if (dirs[--depth] == L)
branch  0 taken 2822 (fallthrough)
branch  1 taken 0
     2822: 4304:	    links[depth]->llink = link;
        -: 4305:	  else
    #####: 4306:	    links[depth]->rlink = link;
        -: 4307:
        -: 4308:	  /* Back up the tree fixing the balance flags. */
    2822*: 4309:	  while (depth && !links[depth]->balance)
branch  0 taken 0 (fallthrough)
branch  1 taken 2822
branch  2 never executed
branch  3 never executed
        -: 4310:	    {
    #####: 4311:	      if (dirs[depth] == L)
branch  0 never executed
branch  1 never executed
    #####: 4312:		--links[depth]->balance;
        -: 4313:	      else
    #####: 4314:		++links[depth]->balance;
    #####: 4315:	      --depth;
        -: 4316:	    }
        -: 4317:
        -: 4318:	  /* Rebalance the tree by pointer rotations if necessary. */
    2822*: 4319:	  if (depth && ((dirs[depth] == L && --links[depth]->balance)
branch  0 taken 0 (fallthrough)
branch  1 taken 2822
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 4320:			|| (dirs[depth] == R && ++links[depth]->balance)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4321:	    {
    #####: 4322:	      switch (links[depth]->balance)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 4323:		{
    #####: 4324:		case (char) -2:
    #####: 4325:		  switch (dirs[depth + 1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 4326:		    {
    #####: 4327:		    case L:
    #####: 4328:		      r = links[depth], t = r->llink, rl = t->rlink;
    #####: 4329:		      t->rlink = r, r->llink = rl;
    #####: 4330:		      t->balance = r->balance = 0;
    #####: 4331:		      break;
    #####: 4332:		    case R:
    #####: 4333:		      r = links[depth], l = r->llink, t = l->rlink;
    #####: 4334:		      rl = t->rlink, lr = t->llink;
    #####: 4335:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
    #####: 4336:		      l->balance = t->balance != 1 ? 0 : -1;
branch  0 never executed
branch  1 never executed
    #####: 4337:		      r->balance = t->balance != (char) -1 ? 0 : 1;
    #####: 4338:		      t->balance = 0;
    #####: 4339:		      break;
    #####: 4340:		    default:
    #####: 4341:		      abort ();
call    0 never executed
        -: 4342:		    }
    #####: 4343:		  break;
    #####: 4344:		case 2:
    #####: 4345:		  switch (dirs[depth + 1])
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -: 4346:		    {
    #####: 4347:		    case R:
    #####: 4348:		      l = links[depth], t = l->rlink, lr = t->llink;
    #####: 4349:		      t->llink = l, l->rlink = lr;
    #####: 4350:		      t->balance = l->balance = 0;
    #####: 4351:		      break;
    #####: 4352:		    case L:
    #####: 4353:		      l = links[depth], r = l->rlink, t = r->llink;
    #####: 4354:		      lr = t->llink, rl = t->rlink;
    #####: 4355:		      t->llink = l, l->rlink = lr, t->rlink = r, r->llink = rl;
    #####: 4356:		      l->balance = t->balance != 1 ? 0 : -1;
branch  0 never executed
branch  1 never executed
    #####: 4357:		      r->balance = t->balance != (char) -1 ? 0 : 1;
    #####: 4358:		      t->balance = 0;
    #####: 4359:		      break;
    #####: 4360:		    default:
    #####: 4361:		      abort ();
call    0 never executed
        -: 4362:		    }
    #####: 4363:		  break;
    #####: 4364:		default:
    #####: 4365:		  abort ();
call    0 never executed
        -: 4366:		}
        -: 4367:
    #####: 4368:	      if (dirs[depth - 1] == L)
branch  0 never executed
branch  1 never executed
    #####: 4369:		links[depth - 1]->llink = t;
        -: 4370:	      else
    #####: 4371:		links[depth - 1]->rlink = t;
        -: 4372:	    }
        -: 4373:	}
        -: 4374:
     2822: 4375:      trie = link->trie;
        -: 4376:    }
        -: 4377:
        -: 4378:  /* Mark the node we finally reached as accepting, encoding the
        -: 4379:     index number of this word in the keyword set so far. */
      598: 4380:  if (!trie->accepting)
branch  0 taken 598 (fallthrough)
branch  1 taken 0
      598: 4381:    trie->accepting = 1 + 2 * kwset->words;
      598: 4382:  ++kwset->words;
        -: 4383:
        -: 4384:  /* Keep track of the longest and shortest string of the keyword set. */
      598: 4385:  if (trie->depth < kwset->mind)
branch  0 taken 598 (fallthrough)
branch  1 taken 0
      598: 4386:    kwset->mind = trie->depth;
      598: 4387:  if (trie->depth > kwset->maxd)
branch  0 taken 598 (fallthrough)
branch  1 taken 0
      598: 4388:    kwset->maxd = trie->depth;
        -: 4389:
      598: 4390:  return 0;
        -: 4391:}
        -: 4392:
        -: 4393:/* Enqueue the trie nodes referenced from the given tree in the
        -: 4394:   given queue. */
        -: 4395:static void
function enqueue called 1163 returned 100% blocks executed 100%
     1163: 4396:enqueue (struct tree *tree, struct trie **last)
        -: 4397:{
     1163: 4398:  if (!tree)
branch  0 taken 794 (fallthrough)
branch  1 taken 369
      794: 4399:    return;
      369: 4400:  enqueue(tree->llink, last);
call    0 returned 369
      369: 4401:  enqueue(tree->rlink, last);
call    0 returned 369
      369: 4402:  (*last) = (*last)->next = tree->trie;
        -: 4403:}
        -: 4404:
        -: 4405:/* Compute the Aho-Corasick failure function for the trie nodes referenced
        -: 4406:   from the given tree, given the failure function for their parent as
        -: 4407:   well as a last resort failure node. */
        -: 4408:static void
function treefails called 1163 returned 100% blocks executed 100%
     1163: 4409:treefails (register struct tree *tree, struct trie *fail, struct trie *recourse)
        -: 4410:{
        -: 4411:  register struct tree *link;
        -: 4412:
     1163: 4413:  if (!tree)
branch  0 taken 794 (fallthrough)
branch  1 taken 369
      794: 4414:    return;
        -: 4415:
      369: 4416:  treefails(tree->llink, fail, recourse);
call    0 returned 369
      369: 4417:  treefails(tree->rlink, fail, recourse);
call    0 returned 369
        -: 4418:
        -: 4419:  /* Find, in the chain of fails going back to the root, the first
        -: 4420:     node that has a descendent on the current label. */
      682: 4421:  while (fail)
branch  0 taken 337
branch  1 taken 345 (fallthrough)
        -: 4422:    {
      337: 4423:      link = fail->links;
      650: 4424:      while (link && tree->label != link->label)
branch  0 taken 337 (fallthrough)
branch  1 taken 313
branch  2 taken 313
branch  3 taken 24 (fallthrough)
      313: 4425:	if (tree->label < link->label)
branch  0 taken 100 (fallthrough)
branch  1 taken 213
      100: 4426:	  link = link->llink;
        -: 4427:	else
      213: 4428:	  link = link->rlink;
      337: 4429:      if (link)
branch  0 taken 24 (fallthrough)
branch  1 taken 313
        -: 4430:	{
       24: 4431:	  tree->trie->fail = link->trie;
       24: 4432:	  return;
        -: 4433:	}
      313: 4434:      fail = fail->fail;
        -: 4435:    }
        -: 4436:
      345: 4437:  tree->trie->fail = recourse;
        -: 4438:}
        -: 4439:
        -: 4440:/* Set delta entries for the links of the given tree such that
        -: 4441:   the preexisting delta value is larger than the current depth. */
        -: 4442:static void
function treedelta called 1163 returned 100% blocks executed 100%
     1163: 4443:treedelta (register struct tree *tree,
        -: 4444:	   register unsigned int depth,
        -: 4445:	   unsigned char delta[])
        -: 4446:{
     1163: 4447:  if (!tree)
branch  0 taken 794 (fallthrough)
branch  1 taken 369
      794: 4448:    return;
      369: 4449:  treedelta(tree->llink, depth, delta);
call    0 returned 369
      369: 4450:  treedelta(tree->rlink, depth, delta);
call    0 returned 369
      369: 4451:  if (depth < delta[tree->label])
branch  0 taken 340 (fallthrough)
branch  1 taken 29
      340: 4452:    delta[tree->label] = depth;
        -: 4453:}
        -: 4454:
        -: 4455:/* Return true if A has every label in B. */
        -: 4456:static int
function hasevery called 1139 returned 100% blocks executed 88%
     1139: 4457:hasevery (register struct tree *a, register struct tree *b)
        -: 4458:{
     1139: 4459:  if (!b)
branch  0 taken 778 (fallthrough)
branch  1 taken 361
      778: 4460:    return 1;
      361: 4461:  if (!hasevery(a, b->llink))
call    0 returned 361
branch  1 taken 0 (fallthrough)
branch  2 taken 361
    #####: 4462:    return 0;
      361: 4463:  if (!hasevery(a, b->rlink))
call    0 returned 361
branch  1 taken 0 (fallthrough)
branch  2 taken 361
    #####: 4464:    return 0;
      674: 4465:  while (a && b->label != a->label)
branch  0 taken 361 (fallthrough)
branch  1 taken 313
branch  2 taken 313
branch  3 taken 48 (fallthrough)
      313: 4466:    if (b->label < a->label)
branch  0 taken 100 (fallthrough)
branch  1 taken 213
      100: 4467:      a = a->llink;
        -: 4468:    else
      213: 4469:      a = a->rlink;
      361: 4470:  return !!a;
        -: 4471:}
        -: 4472:
        -: 4473:/* Compute a vector, indexed by character code, of the trie nodes
        -: 4474:   referenced from the given tree. */
        -: 4475:static void
function treenext called 168 returned 100% blocks executed 100%
      168: 4476:treenext (struct tree *tree, struct trie *next[])
        -: 4477:{
      168: 4478:  if (!tree)
branch  0 taken 112 (fallthrough)
branch  1 taken 56
      112: 4479:    return;
       56: 4480:  treenext(tree->llink, next);
call    0 returned 56
       56: 4481:  treenext(tree->rlink, next);
call    0 returned 56
       56: 4482:  next[tree->label] = tree->trie;
        -: 4483:}
        -: 4484:
        -: 4485:/* Compute the shift for each trie node, as well as the delta
        -: 4486:   table and next cache for the given keyword set. */
        -: 4487:char *
function kwsprep called 598 returned 100% blocks executed 83%
      598: 4488:kwsprep (kwset_t kws)
        -: 4489:{
        -: 4490:  register struct kwset *kwset;
        -: 4491:  register int i;
        -: 4492:  register struct trie *curr, *fail;
        -: 4493:  register char *trans;
        -: 4494:  unsigned char delta[NCHAR];
        -: 4495:  struct trie *last, *next[NCHAR];
        -: 4496:
      598: 4497:  kwset = (struct kwset *) kws;
        -: 4498:
        -: 4499:  /* Initial values for the delta table; will be changed later.  The
        -: 4500:     delta entry for a given character is the smallest depth of any
        -: 4501:     node at which an outgoing edge is labeled by that character. */
      598: 4502:  if (kwset->mind < 256)
branch  0 taken 598 (fallthrough)
branch  1 taken 0
   153686: 4503:    for (i = 0; i < NCHAR; ++i)
branch  0 taken 153088
branch  1 taken 598
   153088: 4504:      delta[i] = kwset->mind;
        -: 4505:  else
    #####: 4506:    for (i = 0; i < NCHAR; ++i)
branch  0 never executed
branch  1 never executed
    #####: 4507:      delta[i] = 255;
        -: 4508:
        -: 4509:  /* Check if we can use the simple boyer-moore algorithm, instead
        -: 4510:     of the hairy commentz-walter algorithm. */
      598: 4511:  if (kwset->words == 1 && kwset->trans == 0)
branch  0 taken 598 (fallthrough)
branch  1 taken 0
branch  2 taken 542 (fallthrough)
branch  3 taken 56
        -: 4512:    {
        -: 4513:      /* Looking for just one string.  Extract it from the trie. */
     542*: 4514:      kwset->target = obstack_alloc(&kwset->obstack, kwset->mind);
branch  0 taken 0 (fallthrough)
branch  1 taken 542
call    2 never executed
branch  3 taken 0 (fallthrough)
branch  4 taken 542
branch  5 taken 0 (fallthrough)
branch  6 taken 542
     2995: 4515:      for (i = kwset->mind - 1, curr = kwset->trie; i >= 0; --i)
branch  0 taken 2453
branch  1 taken 542 (fallthrough)
        -: 4516:	{
     2453: 4517:	  kwset->target[i] = curr->links->label;
     2453: 4518:	  curr = curr->links->trie;
        -: 4519:	}
        -: 4520:      /* Build the Boyer Moore delta.  Boy that's easy compared to CW. */
     2995: 4521:      for (i = 0; i < kwset->mind; ++i)
branch  0 taken 2453
branch  1 taken 542 (fallthrough)
     2453: 4522:	delta[(unsigned char) kwset->target[i]] = kwset->mind - (i + 1);
      542: 4523:      kwset->mind2 = kwset->mind;
        -: 4524:      /* Find the minimal delta2 shift that we might make after
        -: 4525:	 a backwards match has failed. */
     2453: 4526:      for (i = 0; i < kwset->mind - 1; ++i)
branch  0 taken 1911
branch  1 taken 542 (fallthrough)
     1911: 4527:	if (kwset->target[i] == kwset->target[kwset->mind - 1])
branch  0 taken 71 (fallthrough)
branch  1 taken 1840
       71: 4528:	  kwset->mind2 = kwset->mind - (i + 1);
        -: 4529:    }
        -: 4530:  else
        -: 4531:    {
        -: 4532:      /* Traverse the nodes of the trie in level order, simultaneously
        -: 4533:	 computing the delta table, failure function, and shift function. */
      481: 4534:      for (curr = last = kwset->trie; curr; curr = curr->next)
branch  0 taken 425
branch  1 taken 56 (fallthrough)
        -: 4535:	{
        -: 4536:	  /* Enqueue the immediate descendents in the level order queue. */
      425: 4537:	  enqueue(curr->links, &last);
call    0 returned 425
        -: 4538:
      425: 4539:	  curr->shift = kwset->mind;
      425: 4540:	  curr->maxshift = kwset->mind;
        -: 4541:
        -: 4542:	  /* Update the delta table for the descendents of this node. */
      425: 4543:	  treedelta(curr->links, curr->depth, delta);
call    0 returned 425
        -: 4544:
        -: 4545:	  /* Compute the failure function for the decendents of this node. */
      425: 4546:	  treefails(curr->links, curr->fail, kwset->trie);
call    0 returned 425
        -: 4547:
        -: 4548:	  /* Update the shifts at each node in the current node's chain
        -: 4549:	     of fails back to the root. */
      842: 4550:	  for (fail = curr->fail; fail; fail = fail->fail)
branch  0 taken 417
branch  1 taken 425 (fallthrough)
        -: 4551:	    {
        -: 4552:	      /* If the current node has some outgoing edge that the fail
        -: 4553:		 doesn't, then the shift at the fail should be no larger
        -: 4554:		 than the difference of their depths. */
      417: 4555:	      if (!hasevery(fail->links, curr->links))
call    0 returned 417
branch  1 taken 313 (fallthrough)
branch  2 taken 104
      313: 4556:		if (curr->depth - fail->depth < fail->shift)
branch  0 taken 80 (fallthrough)
branch  1 taken 233
       80: 4557:		  fail->shift = curr->depth - fail->depth;
        -: 4558:
        -: 4559:	      /* If the current node is accepting then the shift at the
        -: 4560:		 fail and its descendents should be no larger than the
        -: 4561:		 difference of their depths. */
      417: 4562:	      if (curr->accepting && fail->maxshift > curr->depth - fail->depth)
branch  0 taken 56 (fallthrough)
branch  1 taken 361
branch  2 taken 0 (fallthrough)
branch  3 taken 56
    #####: 4563:		fail->maxshift = curr->depth - fail->depth;
        -: 4564:	    }
        -: 4565:	}
        -: 4566:
        -: 4567:      /* Traverse the trie in level order again, fixing up all nodes whose
        -: 4568:	 shift exceeds their inherited maxshift. */
      425: 4569:      for (curr = kwset->trie->next; curr; curr = curr->next)
branch  0 taken 369
branch  1 taken 56 (fallthrough)
        -: 4570:	{
      369: 4571:	  if (curr->maxshift > curr->parent->maxshift)
branch  0 taken 0 (fallthrough)
branch  1 taken 369
    #####: 4572:	    curr->maxshift = curr->parent->maxshift;
      369: 4573:	  if (curr->shift > curr->maxshift)
branch  0 taken 0 (fallthrough)
branch  1 taken 369
    #####: 4574:	    curr->shift = curr->maxshift;
        -: 4575:	}
        -: 4576:
        -: 4577:      /* Create a vector, indexed by character code, of the outgoing links
        -: 4578:	 from the root node. */
    14392: 4579:      for (i = 0; i < NCHAR; ++i)
branch  0 taken 14336
branch  1 taken 56 (fallthrough)
    14336: 4580:	next[i] = 0;
       56: 4581:      treenext(kwset->trie->links, next);
call    0 returned 56
        -: 4582:
       56: 4583:      if ((trans = kwset->trans) != 0)
branch  0 taken 56 (fallthrough)
branch  1 taken 0
    14392: 4584:	for (i = 0; i < NCHAR; ++i)
branch  0 taken 14336
branch  1 taken 56
    14336: 4585:	  kwset->next[i] = next[(unsigned char) trans[i]];
        -: 4586:      else
    #####: 4587:	for (i = 0; i < NCHAR; ++i)
branch  0 never executed
branch  1 never executed
    #####: 4588:	  kwset->next[i] = next[i];
        -: 4589:    }
        -: 4590:
        -: 4591:  /* Fix things up for any translation table. */
      598: 4592:  if ((trans = kwset->trans) != 0)
branch  0 taken 56 (fallthrough)
branch  1 taken 542
    14392: 4593:    for (i = 0; i < NCHAR; ++i)
branch  0 taken 14336
branch  1 taken 56
    14336: 4594:      kwset->delta[i] = delta[(unsigned char) trans[i]];
        -: 4595:  else
   139294: 4596:    for (i = 0; i < NCHAR; ++i)
branch  0 taken 138752
branch  1 taken 542 (fallthrough)
   138752: 4597:      kwset->delta[i] = delta[i];
        -: 4598:
      598: 4599:  return 0;
        -: 4600:}
        -: 4601:
        -: 4602:#define U(C) ((unsigned char) (C))
        -: 4603:
        -: 4604:/* Fast boyer-moore search. */
        -: 4605:static char *
function bmexec called 259387 returned 100% blocks executed 98%
   259387: 4606:bmexec (kwset_t kws, char *text, size_t size)
        -: 4607:{
        -: 4608:  struct kwset *kwset;
        -: 4609:  register unsigned char *d1;
        -: 4610:  register char *ep, *sp, *tp;
        -: 4611:  register int d, gc, i, len, md2;
        -: 4612:
   259387: 4613:  kwset = (struct kwset *) kws;
   259387: 4614:  len = kwset->mind;
        -: 4615:
   259387: 4616:  if (len == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 259387
    #####: 4617:    return text;
   259387: 4618:  if (len > size)
branch  0 taken 804 (fallthrough)
branch  1 taken 258583
      804: 4619:    return 0;
   258583: 4620:  if (len == 1)
branch  0 taken 110422 (fallthrough)
branch  1 taken 148161
   110422: 4621:    return memchr(text, kwset->target[0], size);
        -: 4622:
   148161: 4623:  d1 = kwset->delta;
   148161: 4624:  sp = kwset->target + len;
   148161: 4625:  gc = U(sp[-2]);
   148161: 4626:  md2 = kwset->mind2;
   148161: 4627:  tp = text + len;
        -: 4628:
        -: 4629:  /* Significance of 12: 1 (initial offset) + 10 (skip loop) + 1 (md2). */
   148161: 4630:  if (size > 12 * len)
branch  0 taken 147276 (fallthrough)
branch  1 taken 885
        -: 4631:    /* 11 is not a bug, the initial offset happens only once. */
   147276: 4632:    for (ep = text + size - 11 * len;;)
        -: 4633:      {
  6091626: 4634:	while (tp <= ep)
branch  0 taken 6086797
branch  1 taken 4829 (fallthrough)
        -: 4635:	  {
  6086797: 4636:	    d = d1[U(tp[-1])], tp += d;
  6086797: 4637:	    d = d1[U(tp[-1])], tp += d;
  6086797: 4638:	    if (d == 0)
branch  0 taken 1577748 (fallthrough)
branch  1 taken 4509049
  1577748: 4639:	      goto found;
  4509049: 4640:	    d = d1[U(tp[-1])], tp += d;
  4509049: 4641:	    d = d1[U(tp[-1])], tp += d;
  4509049: 4642:	    d = d1[U(tp[-1])], tp += d;
  4509049: 4643:	    if (d == 0)
branch  0 taken 789006 (fallthrough)
branch  1 taken 3720043
   789006: 4644:	      goto found;
  3720043: 4645:	    d = d1[U(tp[-1])], tp += d;
  3720043: 4646:	    d = d1[U(tp[-1])], tp += d;
  3720043: 4647:	    d = d1[U(tp[-1])], tp += d;
  3720043: 4648:	    if (d == 0)
branch  0 taken 508032 (fallthrough)
branch  1 taken 3212011
   508032: 4649:	      goto found;
  3212011: 4650:	    d = d1[U(tp[-1])], tp += d;
  3212011: 4651:	    d = d1[U(tp[-1])], tp += d;
        -: 4652:	  }
     4829: 4653:	break;
  2874786: 4654:      found:
  2874786: 4655:	if (U(tp[-2]) == gc)
branch  0 taken 326126 (fallthrough)
branch  1 taken 2548660
        -: 4656:	  {
   533498: 4657:	    for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
branch  0 taken 391051 (fallthrough)
branch  1 taken 142447
branch  2 taken 207372
branch  3 taken 183679 (fallthrough)
        -: 4658:	      ;
   326126: 4659:	    if (i > len)
branch  0 taken 142447 (fallthrough)
branch  1 taken 183679
   142447: 4660:	      return tp - len;
        -: 4661:	  }
  2732339: 4662:	tp += md2;
        -: 4663:      }
        -: 4664:
        -: 4665:  /* Now we have only a few characters left to search.  We
        -: 4666:     carefully avoid ever producing an out-of-bounds pointer. */
     5714: 4667:  ep = text + size;
     5714: 4668:  d = d1[U(tp[-1])];
    46121: 4669:  while (d <= ep - tp)
branch  0 taken 41025
branch  1 taken 5096 (fallthrough)
        -: 4670:    {
    41025: 4671:      d = d1[U((tp += d)[-1])];
    41025: 4672:      if (d != 0)
branch  0 taken 37196 (fallthrough)
branch  1 taken 3829
    37196: 4673:	continue;
     3829: 4674:      if (U(tp[-2]) == gc)
branch  0 taken 915 (fallthrough)
branch  1 taken 2914
        -: 4675:	{
     2105: 4676:	  for (i = 3; i <= len && U(tp[-i]) == U(sp[-i]); ++i)
branch  0 taken 1487 (fallthrough)
branch  1 taken 618
branch  2 taken 1190
branch  3 taken 297 (fallthrough)
        -: 4677:	    ;
      915: 4678:	  if (i > len)
branch  0 taken 618 (fallthrough)
branch  1 taken 297
      618: 4679:	    return tp - len;
        -: 4680:	}
     3211: 4681:      d = md2;
        -: 4682:    }
        -: 4683:
     5096: 4684:  return 0;
        -: 4685:}
        -: 4686:
        -: 4687:/* Hairy multiple string search. */
        -: 4688:static char *
function cwexec called 4961 returned 100% blocks executed 60%
     4961: 4689:cwexec (kwset_t kws, char *text, size_t len, struct kwsmatch *kwsmatch)
        -: 4690:{
        -: 4691:  struct kwset *kwset;
        -: 4692:  struct trie **next, *trie, *accept;
        -: 4693:  char *beg, *lim, *mch, *lmch;
        -: 4694:  register unsigned char c, *delta;
        -: 4695:  register int d;
        -: 4696:  register char *end, *qlim;
        -: 4697:  register struct tree *tree;
        -: 4698:  register char *trans;
        -: 4699:
        -: 4700:#ifdef lint
        -: 4701:  accept = NULL;
        -: 4702:#endif
        -: 4703:
        -: 4704:  /* Initialize register copies and look for easy ways out. */
     4961: 4705:  kwset = (struct kwset *) kws;
     4961: 4706:  if (len < kwset->mind)
branch  0 taken 64 (fallthrough)
branch  1 taken 4897
       64: 4707:    return 0;
     4897: 4708:  next = kwset->next;
     4897: 4709:  delta = kwset->delta;
     4897: 4710:  trans = kwset->trans;
     4897: 4711:  lim = text + len;
     4897: 4712:  end = text;
     4897: 4713:  if ((d = kwset->mind) != 0)
branch  0 taken 4897 (fallthrough)
branch  1 taken 0
     4897: 4714:    mch = 0;
        -: 4715:  else
        -: 4716:    {
    #####: 4717:      mch = text, accept = kwset->trie;
    #####: 4718:      goto match;
        -: 4719:    }
        -: 4720:
     4897: 4721:  if (len >= 4 * kwset->mind)
branch  0 taken 4876 (fallthrough)
branch  1 taken 21
     4876: 4722:    qlim = lim - 4 * kwset->mind;
        -: 4723:  else
       21: 4724:    qlim = 0;
        -: 4725:
   145648: 4726:  while (lim - end >= d)
branch  0 taken 145177
branch  1 taken 471 (fallthrough)
        -: 4727:    {
   145177: 4728:      if (qlim && end <= qlim)
branch  0 taken 145155 (fallthrough)
branch  1 taken 22
branch  2 taken 144142 (fallthrough)
branch  3 taken 1013
        -: 4729:	{
   144142: 4730:	  end += d - 1;
   895176: 4731:	  while ((d = delta[c = *end]) && end < qlim)
branch  0 taken 751446 (fallthrough)
branch  1 taken 143730
branch  2 taken 751034
branch  3 taken 412 (fallthrough)
        -: 4732:	    {
   751034: 4733:	      end += d;
   751034: 4734:	      end += delta[(unsigned char) *end];
   751034: 4735:	      end += delta[(unsigned char) *end];
        -: 4736:	    }
   144142: 4737:	  ++end;
        -: 4738:	}
        -: 4739:      else
     1035: 4740:	d = delta[c = (end += d)[-1]];
   145177: 4741:      if (d)
branch  0 taken 1444 (fallthrough)
branch  1 taken 143733
     1444: 4742:	continue;
   143733: 4743:      beg = end - 1;
   143733: 4744:      trie = next[c];
   143733: 4745:      if (trie->accepting)
branch  0 taken 0 (fallthrough)
branch  1 taken 143733
        -: 4746:	{
    #####: 4747:	  mch = beg;
    #####: 4748:	  accept = trie;
        -: 4749:	}
   143733: 4750:      d = trie->shift;
   179943: 4751:      while (beg > text)
branch  0 taken 179933
branch  1 taken 10 (fallthrough)
        -: 4752:	{
  179933*: 4753:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
branch  0 taken 179933 (fallthrough)
branch  1 taken 0
   179933: 4754:	  tree = trie->links;
   319240: 4755:	  while (tree && c != tree->label)
branch  0 taken 175517 (fallthrough)
branch  1 taken 143723
branch  2 taken 139307
branch  3 taken 36210 (fallthrough)
   139307: 4756:	    if (c < tree->label)
branch  0 taken 34755 (fallthrough)
branch  1 taken 104552
    34755: 4757:	      tree = tree->llink;
        -: 4758:	    else
   104552: 4759:	      tree = tree->rlink;
   179933: 4760:	  if (tree)
branch  0 taken 36210 (fallthrough)
branch  1 taken 143723
        -: 4761:	    {
    36210: 4762:	      trie = tree->trie;
    36210: 4763:	      if (trie->accepting)
branch  0 taken 4426 (fallthrough)
branch  1 taken 31784
        -: 4764:		{
     4426: 4765:		  mch = beg;
     4426: 4766:		  accept = trie;
        -: 4767:		}
        -: 4768:	    }
        -: 4769:	  else
   143723: 4770:	    break;
    36210: 4771:	  d = trie->shift;
        -: 4772:	}
   143733: 4773:      if (mch)
branch  0 taken 4426 (fallthrough)
branch  1 taken 139307
     4426: 4774:	goto match;
        -: 4775:    }
      471: 4776:  return 0;
        -: 4777:
     4426: 4778: match:
        -: 4779:  /* Given a known match, find the longest possible match anchored
        -: 4780:     at or before its starting point.  This is nearly a verbatim
        -: 4781:     copy of the preceding main search loops. */
     4426: 4782:  if (lim - mch > kwset->maxd)
branch  0 taken 4426 (fallthrough)
branch  1 taken 0
     4426: 4783:    lim = mch + kwset->maxd;
     4426: 4784:  lmch = 0;
     4426: 4785:  d = 1;
     4426: 4786:  while (lim - end >= d)
branch  0 taken 0
branch  1 taken 4426 (fallthrough)
        -: 4787:    {
    #####: 4788:      if ((d = delta[c = (end += d)[-1]]) != 0)
branch  0 never executed
branch  1 never executed
    #####: 4789:	continue;
    #####: 4790:      beg = end - 1;
    #####: 4791:      if (!(trie = next[c]))
branch  0 never executed
branch  1 never executed
        -: 4792:	{
    #####: 4793:	  d = 1;
    #####: 4794:	  continue;
        -: 4795:	}
    #####: 4796:      if (trie->accepting && beg <= mch)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4797:	{
    #####: 4798:	  lmch = beg;
    #####: 4799:	  accept = trie;
        -: 4800:	}
    #####: 4801:      d = trie->shift;
    #####: 4802:      while (beg > text)
branch  0 never executed
branch  1 never executed
        -: 4803:	{
    #####: 4804:	  c = trans ? trans[(unsigned char) *--beg] : *--beg;
branch  0 never executed
branch  1 never executed
    #####: 4805:	  tree = trie->links;
    #####: 4806:	  while (tree && c != tree->label)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 4807:	    if (c < tree->label)
branch  0 never executed
branch  1 never executed
    #####: 4808:	      tree = tree->llink;
        -: 4809:	    else
    #####: 4810:	      tree = tree->rlink;
    #####: 4811:	  if (tree)
branch  0 never executed
branch  1 never executed
        -: 4812:	    {
    #####: 4813:	      trie = tree->trie;
    #####: 4814:	      if (trie->accepting && beg <= mch)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 4815:		{
    #####: 4816:		  lmch = beg;
    #####: 4817:		  accept = trie;
        -: 4818:		}
        -: 4819:	    }
        -: 4820:	  else
    #####: 4821:	    break;
    #####: 4822:	  d = trie->shift;
        -: 4823:	}
    #####: 4824:      if (lmch)
branch  0 never executed
branch  1 never executed
        -: 4825:	{
    #####: 4826:	  mch = lmch;
    #####: 4827:	  goto match;
        -: 4828:	}
    #####: 4829:      if (!d)
branch  0 never executed
branch  1 never executed
    #####: 4830:	d = 1;
        -: 4831:    }
        -: 4832:
     4426: 4833:  if (kwsmatch)
branch  0 taken 4426 (fallthrough)
branch  1 taken 0
        -: 4834:    {
     4426: 4835:      kwsmatch->index = accept->accepting / 2;
     4426: 4836:      kwsmatch->beg[0] = mch;
     4426: 4837:      kwsmatch->size[0] = accept->depth;
        -: 4838:    }
     4426: 4839:  return mch;
        -: 4840:}
        -: 4841:
        -: 4842:/* Search through the given text for a match of any member of the
        -: 4843:   given keyword set.  Return a pointer to the first character of
        -: 4844:   the matching substring, or NULL if no match is found.  If FOUNDLEN
        -: 4845:   is non-NULL store in the referenced location the length of the
        -: 4846:   matching substring.  Similarly, if FOUNDIDX is non-NULL, store
        -: 4847:   in the referenced location the index number of the particular
        -: 4848:   keyword matched. */
        -: 4849:char *
function kwsexec called 264348 returned 100% blocks executed 100%
   264348: 4850:kwsexec (kwset_t kws, char *text, size_t size, struct kwsmatch *kwsmatch)
        -: 4851:{
        -: 4852:  struct kwset *kwset;
        -: 4853:  char *ret;
        -: 4854:
   264348: 4855:  kwset = (struct kwset *) kws;
   264348: 4856:  if (kwset->words == 1 && kwset->trans == 0)
branch  0 taken 264348 (fallthrough)
branch  1 taken 0
branch  2 taken 259387 (fallthrough)
branch  3 taken 4961
        -: 4857:    {
   259387: 4858:      ret = bmexec(kws, text, size);
call    0 returned 259387
   259387: 4859:      if (kwsmatch != 0 && ret != 0)
branch  0 taken 259387 (fallthrough)
branch  1 taken 0
branch  2 taken 252852 (fallthrough)
branch  3 taken 6535
        -: 4860:	{
   252852: 4861:	  kwsmatch->index = 0;
   252852: 4862:	  kwsmatch->beg[0] = ret;
   252852: 4863:	  kwsmatch->size[0] = kwset->mind;
        -: 4864:	}
   259387: 4865:      return ret;
        -: 4866:    }
        -: 4867:  else
     4961: 4868:    return cwexec(kws, text, size, kwsmatch);
call    0 returned 4961
        -: 4869:}
        -: 4870:
        -: 4871:/* Free the components of the given keyword set. */
        -: 4872:void
function kwsfree called 0 returned 0% blocks executed 0%
    #####: 4873:kwsfree (kwset_t kws)
        -: 4874:{
        -: 4875:  struct kwset *kwset;
        -: 4876:
    #####: 4877:  kwset = (struct kwset *) kws;
    #####: 4878:  obstack_free(&kwset->obstack, 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
call    4 never executed
    #####: 4879:  free(kws);
    #####: 4880:}
        -: 4881:/* obstack.c - subroutines used implicitly by object stack macros
        -: 4882:   Copyright (C) 1988-1994,96,97,98,99 Free Software Foundation, Inc.
        -: 4883:
        -: 4884:   This file is part of the GNU C Library.  Its master source is NOT part of
        -: 4885:   the C library, however.  The master source lives in /gd/gnu/lib.
        -: 4886:
        -: 4887:   The GNU C Library is free software; you can redistribute it and/or
        -: 4888:   modify it under the terms of the GNU Library General Public License as
        -: 4889:   published by the Free Software Foundation; either version 2 of the
        -: 4890:   License, or (at your option) any later version.
        -: 4891:
        -: 4892:   The GNU C Library is distributed in the hope that it will be useful,
        -: 4893:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 4894:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 4895:   Library General Public License for more details.
        -: 4896:
        -: 4897:   You should have received a copy of the GNU Library General Public
        -: 4898:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -: 4899:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 4900:   Boston, MA 02111-1307, USA.  */
        -: 4901:
        -: 4902:#ifdef HAVE_CONFIG_H
        -: 4903:#if flag_config==0
        -: 4904:#include <config.h>
        -: 4905:#define flag_config 1
        -: 4906:#endif
        -: 4907:#endif
        -: 4908:
        -: 4909:/*#include "obstack.h"*/
        -: 4910:
        -: 4911:/* NOTE BEFORE MODIFYING THIS FILE: This version number must be
        -: 4912:   incremented whenever callers compiled using an old obstack.h can no
        -: 4913:   longer properly call the functions in this obstack.c.  */
        -: 4914:#define OBSTACK_INTERFACE_VERSION 1
        -: 4915:
        -: 4916:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 4917:   actually compiling the library itself, and the installed library
        -: 4918:   supports the same library interface we do.  This code is part of the GNU
        -: 4919:   C Library, but also included in many other GNU distributions.  Compiling
        -: 4920:   and linking in this code is a waste when using the GNU C library
        -: 4921:   (especially if it is a shared library).  Rather than having every GNU
        -: 4922:   program understand `configure --with-gnu-libc' and omit the object
        -: 4923:   files, it is simpler to just do this in the source for each such file.  */
        -: 4924:
        -: 4925:/*#include <stdio.h>*/		/* Random thing to get __GNU_LIBRARY__.  */
        -: 4926:#if !defined (_LIBC) && defined (__GNU_LIBRARY__) && __GNU_LIBRARY__ > 1
        -: 4927:#include <gnu-versions.h>
        -: 4928:#define flag_gnuversions 1
        -: 4929:#if _GNU_OBSTACK_INTERFACE_VERSION == OBSTACK_INTERFACE_VERSION
        -: 4930:#define ELIDE_CODE
        -: 4931:#endif
        -: 4932:#endif
        -: 4933:
        -: 4934:
        -: 4935:#ifndef ELIDE_CODE
        -: 4936:
        -: 4937:
        -: 4938:#if defined (__STDC__) && __STDC__
        -: 4939:#define POINTER void *
        -: 4940:#else
        -: 4941:#define POINTER char *
        -: 4942:#endif
        -: 4943:
        -: 4944:/* Determine default alignment.  */
        -: 4945:struct fooalign {char x; double d;};
        -: 4946:#define DEFAULT_ALIGNMENT  \
        -: 4947:  ((PTR_INT_TYPE) ((char *) &((struct fooalign *) 0)->d - (char *) 0))
        -: 4948:/* If malloc were really smart, it would round addresses to DEFAULT_ALIGNMENT.
        -: 4949:   But in fact it might be less smart and round addresses to as much as
        -: 4950:   DEFAULT_ROUNDING.  So we prepare for it to do that.  */
        -: 4951:union fooround {long x; double d;};
        -: 4952:#define DEFAULT_ROUNDING (sizeof (union fooround))
        -: 4953:
        -: 4954:/* When we copy a long block of data, this is the unit to do it with.
        -: 4955:   On some machines, copying successive ints does not work;
        -: 4956:   in such a case, redefine COPYING_UNIT to `long' (if that works)
        -: 4957:   or `char' as a last resort.  */
        -: 4958:#ifndef COPYING_UNIT
        -: 4959:#define COPYING_UNIT int
        -: 4960:#endif
        -: 4961:
        -: 4962:
        -: 4963:/* The functions allocating more room by calling `obstack_chunk_alloc'
        -: 4964:   jump to the handler pointed to by `obstack_alloc_failed_handler'.
        -: 4965:   This can be set to a user defined function which should either
        -: 4966:   abort gracefully or use longjump - but shouldn't return.  This
        -: 4967:   variable by default points to the internal function
        -: 4968:   `print_and_abort'.  */
        -: 4969:#if defined (__STDC__) && __STDC__
        -: 4970:static void print_and_abort (void);
        -: 4971:void (*obstack_alloc_failed_handler) (void) = print_and_abort;
        -: 4972:#else
        -: 4973:static void print_and_abort ();
        -: 4974:void (*obstack_alloc_failed_handler) () = print_and_abort;
        -: 4975:#endif
        -: 4976:
        -: 4977:/* Exit value used when `print_and_abort' is used.  */
        -: 4978:#if defined __GNU_LIBRARY__ || defined HAVE_STDLIB_H
        -: 4979:#if flag_stdlib==0
        -: 4980:#include <stdlib.h>
        -: 4981:#define flag_stdlib 1
        -: 4982:#endif
        -: 4983:#endif
        -: 4984:#ifndef EXIT_FAILURE
        -: 4985:#define EXIT_FAILURE 1
        -: 4986:#endif
        -: 4987:int obstack_exit_failure = EXIT_FAILURE;
        -: 4988:
        -: 4989:/* The non-GNU-C macros copy the obstack into this global variable
        -: 4990:   to avoid multiple evaluation.  */
        -: 4991:
        -: 4992:struct obstack *_obstack;
        -: 4993:
        -: 4994:/* Define a macro that either calls functions with the traditional malloc/free
        -: 4995:   calling interface, or calls functions with the mmalloc/mfree interface
        -: 4996:   (that adds an extra first argument), based on the state of use_extra_arg.
        -: 4997:   For free, do not use ?:, since some compilers, like the MIPS compilers,
        -: 4998:   do not allow (expr) ? void : void.  */
        -: 4999:
        -: 5000:#if defined (__STDC__) && __STDC__
        -: 5001:#define CALL_CHUNKFUN(h, size) \
        -: 5002:  (((h) -> use_extra_arg) \
        -: 5003:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 5004:   : (*(struct _obstack_chunk *(*) (long)) (h)->chunkfun) ((size)))
        -: 5005:
        -: 5006:#define CALL_FREEFUN(h, old_chunk) \
        -: 5007:  do { \
        -: 5008:    if ((h) -> use_extra_arg) \
        -: 5009:      obstack_chunk_free((h)->extra_arg/*, (old_chunk)*/); \
        -: 5010:    else \
        -: 5011:     obstack_chunk_free((old_chunk)); \
        -: 5012:  } while (0)
        -: 5013:
        -: 5014:#define CALL_FREEFUN(h, old_chunk) \
        -: 5015:  do { \
        -: 5016:      free ((old_chunk)); \
        -: 5017:  } while (0)
        -: 5018:
        -: 5019:/*
        -: 5020:#define CALL_FREEFUN(h, old_chunk) \
        -: 5021:  do { \
        -: 5022:    if ((h) -> use_extra_arg) \
        -: 5023:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 5024:    else \
        -: 5025:      (*(void (*) (void *)) (h)->freefun) ((old_chunk)); \
        -: 5026:  } while (0)
        -: 5027:*/
        -: 5028:#else
        -: 5029:#define CALL_CHUNKFUN(h, size) \
        -: 5030:  (((h) -> use_extra_arg) \
        -: 5031:   ? (*(h)->chunkfun) ((h)->extra_arg, (size)) \
        -: 5032:   : (*(struct _obstack_chunk *(*) ()) (h)->chunkfun) ((size)))
        -: 5033:
        -: 5034:#define CALL_FREEFUN(h, old_chunk) \
        -: 5035:  do { \
        -: 5036:    if ((h) -> use_extra_arg) \
        -: 5037:      (*(h)->freefun) ((h)->extra_arg, (old_chunk)); \
        -: 5038:    else \
        -: 5039:      (*(void (*) ()) (h)->freefun) ((old_chunk)); \
        -: 5040:  } while (0)
        -: 5041:#endif
        -: 5042:
        -: 5043:
        -: 5044:/* Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).
        -: 5045:   Objects start on multiples of ALIGNMENT (0 means use default).
        -: 5046:   CHUNKFUN is the function to use to allocate chunks,
        -: 5047:   and FREEFUN the function to free them.
        -: 5048:
        -: 5049:   Return nonzero if successful, calls obstack_alloc_failed_handler if
        -: 5050:   allocation fails.  */
        -: 5051:
        -: 5052:int
        -: 5053:_obstack_begin (h, size, alignment, chunkfun, freefun)
        -: 5054:     struct obstack *h;
        -: 5055:     int size;
        -: 5056:     int alignment;
        -: 5057:#if defined (__STDC__) && __STDC__
        -: 5058:     POINTER (*chunkfun) (long);
        -: 5059:     void (*freefun) (void *);
        -: 5060:#else
        -: 5061:     POINTER (*chunkfun) ();
        -: 5062:     void (*freefun) ();
        -: 5063:#endif
        -: 5064:{
        -: 5065:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 5066:
        -: 5067:  if (alignment == 0)
        -: 5068:    alignment = (int) DEFAULT_ALIGNMENT;
        -: 5069:  if (size == 0)
        -: 5070:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 5071:    {
        -: 5072:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 5073:	 Use the values for range checking, because if range checking is off,
        -: 5074:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 5075:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 5076:	 allocated.
        -: 5077:
        -: 5078:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 5079:	 less sensitive to the size of the request.  */
        -: 5080:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 5081:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 5082:		   & ~(DEFAULT_ROUNDING - 1));
        -: 5083:      size = 4096 - extra;
        -: 5084:    }
        -: 5085:
        -: 5086:#if defined (__STDC__) && __STDC__
        -: 5087:  h->chunkfun = (struct _obstack_chunk * (*)(void *, long)) chunkfun;
        -: 5088:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 5089:#else
        -: 5090:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 5091:  h->freefun = freefun;
        -: 5092:#endif
        -: 5093:  h->chunk_size = size;
        -: 5094:  h->alignment_mask = alignment - 1;
        -: 5095:  h->use_extra_arg = 0;
        -: 5096:
        -: 5097:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 5098:  if (!chunk)
        -: 5099:    (*obstack_alloc_failed_handler) ();
        -: 5100:  h->next_free = h->object_base = chunk->contents;
        -: 5101:  h->chunk_limit = chunk->limit
        -: 5102:    = (char *) chunk + h->chunk_size;
        -: 5103:  chunk->prev = 0;
        -: 5104:  /* The initial chunk now contains no empty object.  */
        -: 5105:  h->maybe_empty_object = 0;
        -: 5106:  h->alloc_failed = 0;
        -: 5107:  return 1;
        -: 5108:}
        -: 5109:
        -: 5110:int
        -: 5111:_obstack_begin_1 (h, size, alignment, chunkfun, freefun, arg)
        -: 5112:     struct obstack *h;
        -: 5113:     int size;
        -: 5114:     int alignment;
        -: 5115:#if defined (__STDC__) && __STDC__
        -: 5116:     POINTER (*chunkfun) (POINTER, long);
        -: 5117:     void (*freefun) (POINTER, POINTER);
        -: 5118:#else
        -: 5119:     POINTER (*chunkfun) ();
        -: 5120:     void (*freefun) ();
        -: 5121:#endif
        -: 5122:     POINTER arg;
        -: 5123:{
        -: 5124:  register struct _obstack_chunk *chunk; /* points to new chunk */
        -: 5125:
        -: 5126:  if (alignment == 0)
        -: 5127:    alignment = (int) DEFAULT_ALIGNMENT;
        -: 5128:  if (size == 0)
        -: 5129:    /* Default size is what GNU malloc can fit in a 4096-byte block.  */
        -: 5130:    {
        -: 5131:      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.
        -: 5132:	 Use the values for range checking, because if range checking is off,
        -: 5133:	 the extra bytes won't be missed terribly, but if range checking is on
        -: 5134:	 and we used a larger request, a whole extra 4096 bytes would be
        -: 5135:	 allocated.
        -: 5136:
        -: 5137:	 These number are irrelevant to the new GNU malloc.  I suspect it is
        -: 5138:	 less sensitive to the size of the request.  */
        -: 5139:      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))
        -: 5140:		    + 4 + DEFAULT_ROUNDING - 1)
        -: 5141:		   & ~(DEFAULT_ROUNDING - 1));
        -: 5142:      size = 4096 - extra;
        -: 5143:    }
        -: 5144:
        -: 5145:#if defined(__STDC__) && __STDC__
        -: 5146:  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;
        -: 5147:  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;
        -: 5148:#else
        -: 5149:  h->chunkfun = (struct _obstack_chunk * (*)()) chunkfun;
        -: 5150:  h->freefun = freefun;
        -: 5151:#endif
        -: 5152:  h->chunk_size = size;
        -: 5153:  h->alignment_mask = alignment - 1;
        -: 5154:  h->extra_arg = arg;
        -: 5155:  h->use_extra_arg = 1;
        -: 5156:
        -: 5157:  chunk = h->chunk = CALL_CHUNKFUN (h, h -> chunk_size);
        -: 5158:  if (!chunk)
        -: 5159:    (*obstack_alloc_failed_handler) ();
        -: 5160:  h->next_free = h->object_base = chunk->contents;
        -: 5161:  h->chunk_limit = chunk->limit
        -: 5162:    = (char *) chunk + h->chunk_size;
        -: 5163:  chunk->prev = 0;
        -: 5164:  /* The initial chunk now contains no empty object.  */
        -: 5165:  h->maybe_empty_object = 0;
        -: 5166:  h->alloc_failed = 0;
        -: 5167:  return 1;
        -: 5168:}
        -: 5169:
        -: 5170:/* Allocate a new current chunk for the obstack *H
        -: 5171:   on the assumption that LENGTH bytes need to be added
        -: 5172:   to the current object, or a new object of length LENGTH allocated.
        -: 5173:   Copies any partial object from the end of the old chunk
        -: 5174:   to the beginning of the new one.  */
        -: 5175:
        -: 5176:void
        -: 5177:_obstack_newchunk (h, length)
        -: 5178:     struct obstack *h;
        -: 5179:     int length;
        -: 5180:{
        -: 5181:  register struct _obstack_chunk *old_chunk = h->chunk;
        -: 5182:  register struct _obstack_chunk *new_chunk;
        -: 5183:  register long	new_size;
        -: 5184:  register long obj_size = h->next_free - h->object_base;
        -: 5185:  register long i;
        -: 5186:  long already;
        -: 5187:
        -: 5188:  /* Compute size for new chunk.  */
        -: 5189:  new_size = (obj_size + length) + (obj_size >> 3) + 100;
        -: 5190:  if (new_size < h->chunk_size)
        -: 5191:    new_size = h->chunk_size;
        -: 5192:
        -: 5193:  /* Allocate and initialize the new chunk.  */
        -: 5194:  new_chunk = CALL_CHUNKFUN (h, new_size);
        -: 5195:  if (!new_chunk)
        -: 5196:    (*obstack_alloc_failed_handler) ();
        -: 5197:  h->chunk = new_chunk;
        -: 5198:  new_chunk->prev = old_chunk;
        -: 5199:  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;
        -: 5200:
        -: 5201:  /* Move the existing object to the new chunk.
        -: 5202:     Word at a time is fast and is safe if the object
        -: 5203:     is sufficiently aligned.  */
        -: 5204:  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)
        -: 5205:    {
        -: 5206:      for (i = obj_size / sizeof (COPYING_UNIT) - 1;
        -: 5207:	   i >= 0; i--)
        -: 5208:	((COPYING_UNIT *)new_chunk->contents)[i]
        -: 5209:	  = ((COPYING_UNIT *)h->object_base)[i];
        -: 5210:      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,
        -: 5211:	 but that can cross a page boundary on a machine
        -: 5212:	 which does not do strict alignment for COPYING_UNITS.  */
        -: 5213:      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);
        -: 5214:    }
        -: 5215:  else
        -: 5216:    already = 0;
        -: 5217:  /* Copy remaining bytes one by one.  */
        -: 5218:  for (i = already; i < obj_size; i++)
        -: 5219:    new_chunk->contents[i] = h->object_base[i];
        -: 5220:
        -: 5221:  /* If the object just copied was the only data in OLD_CHUNK,
        -: 5222:     free that chunk and remove it from the chain.
        -: 5223:     But not if that chunk might contain an empty object.  */
        -: 5224:  if (h->object_base == old_chunk->contents && ! h->maybe_empty_object)
        -: 5225:    {
        -: 5226:      new_chunk->prev = old_chunk->prev;
        -: 5227:      CALL_FREEFUN (h, old_chunk);
        -: 5228:    }
        -: 5229:
        -: 5230:  h->object_base = new_chunk->contents;
        -: 5231:  h->next_free = h->object_base + obj_size;
        -: 5232:  /* The new chunk certainly contains no empty object yet.  */
        -: 5233:  h->maybe_empty_object = 0;
        -: 5234:}
        -: 5235:
        -: 5236:/* Return nonzero if object OBJ has been allocated from obstack H.
        -: 5237:   This is here for debugging.
        -: 5238:   If you use it in a program, you are probably losing.  */
        -: 5239:
        -: 5240:#if defined (__STDC__) && __STDC__
        -: 5241:/* Suppress -Wmissing-prototypes warning.  We don't want to declare this in
        -: 5242:   obstack.h because it is just for debugging.  */
        -: 5243:int _obstack_allocated_p (struct obstack *h, POINTER obj);
        -: 5244:#endif
        -: 5245:
        -: 5246:int
        -: 5247:_obstack_allocated_p (h, obj)
        -: 5248:     struct obstack *h;
        -: 5249:     POINTER obj;
        -: 5250:{
        -: 5251:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 5252:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 5253:
        -: 5254:  lp = (h)->chunk;
        -: 5255:  /* We use >= rather than > since the object cannot be exactly at
        -: 5256:     the beginning of the chunk but might be an empty object exactly
        -: 5257:     at the end of an adjacent chunk.  */
        -: 5258:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 5259:    {
        -: 5260:      plp = lp->prev;
        -: 5261:      lp = plp;
        -: 5262:    }
        -: 5263:  return lp != 0;
        -: 5264:}
        -: 5265:
        -: 5266:/* Free objects in obstack H, including OBJ and everything allocate
        -: 5267:   more recently than OBJ.  If OBJ is zero, free everything in H.  */
        -: 5268:
        -: 5269:#undef obstack_free
        -: 5270:
        -: 5271:/* This function has two names with identical definitions.
        -: 5272:   This is the first one, called from non-ANSI code.  */
        -: 5273:
        -: 5274:void
        -: 5275:_obstack_free (h, obj)
        -: 5276:     struct obstack *h;
        -: 5277:     POINTER obj;
        -: 5278:{
        -: 5279:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 5280:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 5281:
        -: 5282:  lp = h->chunk;
        -: 5283:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 5284:     But there can be an empty object at that address
        -: 5285:     at the end of another chunk.  */
        -: 5286:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 5287:    {
        -: 5288:      plp = lp->prev;
        -: 5289:      CALL_FREEFUN (h, lp);
        -: 5290:      lp = plp;
        -: 5291:      /* If we switch chunks, we can't tell whether the new current
        -: 5292:	 chunk contains an empty object, so assume that it may.  */
        -: 5293:      h->maybe_empty_object = 1;
        -: 5294:    }
        -: 5295:  if (lp)
        -: 5296:    {
        -: 5297:      h->object_base = h->next_free = (char *) (obj);
        -: 5298:      h->chunk_limit = lp->limit;
        -: 5299:      h->chunk = lp;
        -: 5300:    }
        -: 5301:  else if (obj != 0)
        -: 5302:    /* obj is not in any of the chunks! */
        -: 5303:    abort ();
        -: 5304:}
        -: 5305:
        -: 5306:/* This function is used from ANSI code.  */
        -: 5307:
        -: 5308:void
        -: 5309:obstack_free (h, obj)
        -: 5310:     struct obstack *h;
        -: 5311:     POINTER obj;
        -: 5312:{
        -: 5313:  register struct _obstack_chunk *lp;	/* below addr of any objects in this chunk */
        -: 5314:  register struct _obstack_chunk *plp;	/* point to previous chunk if any */
        -: 5315:
        -: 5316:  lp = h->chunk;
        -: 5317:  /* We use >= because there cannot be an object at the beginning of a chunk.
        -: 5318:     But there can be an empty object at that address
        -: 5319:     at the end of another chunk.  */
        -: 5320:  while (lp != 0 && ((POINTER) lp >= obj || (POINTER) (lp)->limit < obj))
        -: 5321:    {
        -: 5322:      plp = lp->prev;
        -: 5323:      CALL_FREEFUN (h, lp);
        -: 5324:      lp = plp;
        -: 5325:      /* If we switch chunks, we can't tell whether the new current
        -: 5326:	 chunk contains an empty object, so assume that it may.  */
        -: 5327:      h->maybe_empty_object = 1;
        -: 5328:    }
        -: 5329:  if (lp)
        -: 5330:    {
        -: 5331:      h->object_base = h->next_free = (char *) (obj);
        -: 5332:      h->chunk_limit = lp->limit;
        -: 5333:      h->chunk = lp;
        -: 5334:    }
        -: 5335:  else if (obj != 0)
        -: 5336:    /* obj is not in any of the chunks! */
        -: 5337:    abort ();
        -: 5338:}
        -: 5339:
        -: 5340:int
        -: 5341:_obstack_memory_used (h)
        -: 5342:     struct obstack *h;
        -: 5343:{
        -: 5344:  register struct _obstack_chunk* lp;
        -: 5345:  register int nbytes = 0;
        -: 5346:
        -: 5347:  for (lp = h->chunk; lp != 0; lp = lp->prev)
        -: 5348:    {
        -: 5349:      nbytes += lp->limit - (char *) lp;
        -: 5350:    }
        -: 5351:  return nbytes;
        -: 5352:}
        -: 5353:
        -: 5354:/* Define the error handler.  */
        -: 5355:#ifndef _
        -: 5356:# ifdef HAVE_LIBINTL_H
        -: 5357:#if flag_libintl==0
        -: 5358:#  include <libintl.h>
        -: 5359:#define flag_libintl 1
        -: 5360:#endif
        -: 5361:#  ifndef _
        -: 5362:#   define _(Str) gettext (Str)
        -: 5363:#  endif
        -: 5364:# else
        -: 5365:#  define _(Str) (Str)
        -: 5366:# endif
        -: 5367:#endif
        -: 5368:#if defined _LIBC && defined USE_IN_LIBIO
        -: 5369:# include <libio/iolibio.h>
        -: 5370:# define fputs(s, f) _IO_fputs (s, f)
        -: 5371:#endif
        -: 5372:
        -: 5373:static void
        -: 5374:print_and_abort ()
        -: 5375:{
        -: 5376:  fputs (_("memory exhausted"), stderr);
        -: 5377:  fputc ('\n', stderr);
        -: 5378:  exit (obstack_exit_failure);
        -: 5379:}
        -: 5380:
        -: 5381:#if 0
        -: 5382:/* These are now turned off because the applications do not use it
        -: 5383:   and it uses bcopy via obstack_grow, which causes trouble on sysV.  */
        -: 5384:
        -: 5385:/* Now define the functional versions of the obstack macros.
        -: 5386:   Define them to simply use the corresponding macros to do the job.  */
        -: 5387:
        -: 5388:#if defined (__STDC__) && __STDC__
        -: 5389:/* These function definitions do not work with non-ANSI preprocessors;
        -: 5390:   they won't pass through the macro names in parentheses.  */
        -: 5391:
        -: 5392:/* The function names appear in parentheses in order to prevent
        -: 5393:   the macro-definitions of the names from being expanded there.  */
        -: 5394:
        -: 5395:POINTER (obstack_base) (obstack)
        -: 5396:     struct obstack *obstack;
        -: 5397:{
        -: 5398:  return obstack_base (obstack);
        -: 5399:}
        -: 5400:
        -: 5401:POINTER (obstack_next_free) (obstack)
        -: 5402:     struct obstack *obstack;
        -: 5403:{
        -: 5404:  return obstack_next_free (obstack);
        -: 5405:}
        -: 5406:
        -: 5407:int (obstack_object_size) (obstack)
        -: 5408:     struct obstack *obstack;
        -: 5409:{
        -: 5410:  return obstack_object_size (obstack);
        -: 5411:}
        -: 5412:
        -: 5413:int (obstack_room) (obstack)
        -: 5414:     struct obstack *obstack;
        -: 5415:{
        -: 5416:  return obstack_room (obstack);
        -: 5417:}
        -: 5418:
        -: 5419:int (obstack_make_room) (obstack, length)
        -: 5420:     struct obstack *obstack;
        -: 5421:     int length;
        -: 5422:{
        -: 5423:  return obstack_make_room (obstack, length);
        -: 5424:}
        -: 5425:
        -: 5426:void (obstack_grow) (obstack, pointer, length)
        -: 5427:     struct obstack *obstack;
        -: 5428:     POINTER pointer;
        -: 5429:     int length;
        -: 5430:{
        -: 5431:  obstack_grow (obstack, pointer, length);
        -: 5432:}
        -: 5433:
        -: 5434:void (obstack_grow0) (obstack, pointer, length)
        -: 5435:     struct obstack *obstack;
        -: 5436:     POINTER pointer;
        -: 5437:     int length;
        -: 5438:{
        -: 5439:  obstack_grow0 (obstack, pointer, length);
        -: 5440:}
        -: 5441:
        -: 5442:void (obstack_1grow) (obstack, character)
        -: 5443:     struct obstack *obstack;
        -: 5444:     int character;
        -: 5445:{
        -: 5446:  obstack_1grow (obstack, character);
        -: 5447:}
        -: 5448:
        -: 5449:void (obstack_blank) (obstack, length)
        -: 5450:     struct obstack *obstack;
        -: 5451:     int length;
        -: 5452:{
        -: 5453:  obstack_blank (obstack, length);
        -: 5454:}
        -: 5455:
        -: 5456:void (obstack_1grow_fast) (obstack, character)
        -: 5457:     struct obstack *obstack;
        -: 5458:     int character;
        -: 5459:{
        -: 5460:  obstack_1grow_fast (obstack, character);
        -: 5461:}
        -: 5462:
        -: 5463:void (obstack_blank_fast) (obstack, length)
        -: 5464:     struct obstack *obstack;
        -: 5465:     int length;
        -: 5466:{
        -: 5467:  obstack_blank_fast (obstack, length);
        -: 5468:}
        -: 5469:
        -: 5470:POINTER (obstack_finish) (obstack)
        -: 5471:     struct obstack *obstack;
        -: 5472:{
        -: 5473:  return obstack_finish (obstack);
        -: 5474:}
        -: 5475:
        -: 5476:POINTER (obstack_alloc) (obstack, length)
        -: 5477:     struct obstack *obstack;
        -: 5478:     int length;
        -: 5479:{
        -: 5480:  return obstack_alloc (obstack, length);
        -: 5481:}
        -: 5482:
        -: 5483:POINTER (obstack_copy) (obstack, pointer, length)
        -: 5484:     struct obstack *obstack;
        -: 5485:     POINTER pointer;
        -: 5486:     int length;
        -: 5487:{
        -: 5488:  return obstack_copy (obstack, pointer, length);
        -: 5489:}
        -: 5490:
        -: 5491:POINTER (obstack_copy0) (obstack, pointer, length)
        -: 5492:     struct obstack *obstack;
        -: 5493:     POINTER pointer;
        -: 5494:     int length;
        -: 5495:{
        -: 5496:  return obstack_copy0 (obstack, pointer, length);
        -: 5497:}
        -: 5498:
        -: 5499:#endif /* __STDC__ */
        -: 5500:
        -: 5501:#endif /* 0 */
        -: 5502:
        -: 5503:#endif	/* !ELIDE_CODE */
        -: 5504:/* savedir.c -- save the list of files in a directory in a string
        -: 5505:   Copyright (C) 1990, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
        -: 5506:
        -: 5507:   This program is free software; you can redistribute it and/or modify
        -: 5508:   it under the terms of the GNU General Public License as published by
        -: 5509:   the Free Software Foundation; either version 2, or (at your option)
        -: 5510:   any later version.
        -: 5511:
        -: 5512:   This program is distributed in the hope that it will be useful,
        -: 5513:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5514:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 5515:   GNU General Public License for more details.
        -: 5516:
        -: 5517:   You should have received a copy of the GNU General Public License
        -: 5518:   along with this program; if not, write to the Free Software Foundation,
        -: 5519:   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 5520:
        -: 5521:/* Written by David MacKenzie <djm@gnu.ai.mit.edu>. */
        -: 5522:
        -: 5523:#if HAVE_CONFIG_H
        -: 5524:#if flag_config==0
        -: 5525:# include <config.h>
        -: 5526:#define flag_config 1
        -: 5527:#endif
        -: 5528:#endif
        -: 5529:
        -: 5530:/*#include <sys/types.h>*/
        -: 5531:
        -: 5532:#if HAVE_UNISTD_H
        -: 5533:# include <unistd.h>
        -: 5534:#define flag_unistd 1
        -: 5535:#endif
        -: 5536:
        -: 5537:#if HAVE_DIRENT_H
        -: 5538:# include <dirent.h>
        -: 5539:# define NAMLEN(dirent) strlen((dirent)->d_name)
        -: 5540:#else
        -: 5541:# define dirent direct
        -: 5542:# define NAMLEN(dirent) (dirent)->d_namlen
        -: 5543:# if HAVE_SYS_NDIR_H
        -: 5544:#  include <sys/ndir.h>
        -: 5545:# endif
        -: 5546:# if HAVE_SYS_DIR_H
        -: 5547:#  include <sys/dir.h>
        -: 5548:# endif
        -: 5549:# if HAVE_NDIR_H
        -: 5550:#  include <ndir.h>
        -: 5551:# endif
        -: 5552:#endif
        -: 5553:
        -: 5554:#ifdef CLOSEDIR_VOID
        -: 5555:/* Fake a return value. */
        -: 5556:# define CLOSEDIR(d) (closedir (d), 0)
        -: 5557:#else
        -: 5558:# define CLOSEDIR(d) closedir (d)
        -: 5559:#endif
        -: 5560:
        -: 5561:#ifdef STDC_HEADERS
        -: 5562:#if flag_stdlib==0
        -: 5563:# include <stdlib.h>
        -: 5564:#define flag_stdlib 1
        -: 5565:#endif
        -: 5566:#if flag_string==0
        -: 5567:# include <string.h>
        -: 5568:#define flag_string 1
        -: 5569:#endif
        -: 5570:#else
        -: 5571:char *malloc ();
        -: 5572:char *realloc ();
        -: 5573:#endif
        -: 5574:#ifndef NULL
        -: 5575:# define NULL 0
        -: 5576:#endif
        -: 5577:
        -: 5578:#ifndef stpcpy
        -: 5579:char *stpcpy ();
        -: 5580:#endif
        -: 5581:
        -: 5582:/*#include "savedir.h"*/
        -: 5583:
        -: 5584:/* Return a freshly allocated string containing the filenames
        -: 5585:   in directory DIR, separated by '\0' characters;
        -: 5586:   the end is marked by two '\0' characters in a row.
        -: 5587:   NAME_SIZE is the number of bytes to initially allocate
        -: 5588:   for the string; it will be enlarged as needed.
        -: 5589:   Return NULL if DIR cannot be opened or if out of memory. */
        -: 5590:
        -: 5591:char *
function savedir called 0 returned 0% blocks executed 0%
    #####: 5592:savedir (const char *dir, off_t name_size)
        -: 5593:{
        -: 5594:  DIR *dirp;
        -: 5595:  struct dirent *dp;
        -: 5596:  char *name_space;
        -: 5597:  char *namep;
        -: 5598:
    #####: 5599:  dirp = opendir (dir);
call    0 never executed
    #####: 5600:  if (dirp == NULL)
branch  0 never executed
branch  1 never executed
    #####: 5601:    return NULL;
        -: 5602:
        -: 5603:  /* Be sure name_size is at least `1' so there's room for
        -: 5604:     the final NUL byte.  */
    #####: 5605:  name_size += !name_size;
        -: 5606:
    #####: 5607:  name_space = (char *) malloc (name_size);
call    0 never executed
    #####: 5608:  if (name_space == NULL)
branch  0 never executed
branch  1 never executed
        -: 5609:    {
    #####: 5610:      closedir (dirp);
call    0 never executed
    #####: 5611:      return NULL;
        -: 5612:    }
    #####: 5613:  namep = name_space;
        -: 5614:
    #####: 5615:  while ((dp = readdir (dirp)) != NULL)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5616:    {
        -: 5617:      /* Skip "." and ".." (some NFS filesystems' directories lack them). */
    #####: 5618:      if (dp->d_name[0] != '.'
branch  0 never executed
branch  1 never executed
    #####: 5619:	  || (dp->d_name[1] != '\0'
branch  0 never executed
branch  1 never executed
    #####: 5620:	      && (dp->d_name[1] != '.' || dp->d_name[2] != '\0')))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 5621:	{
    #####: 5622:	  off_t size_needed = (namep - name_space) + NAMLEN (dp) + 2;
        -: 5623:
    #####: 5624:	  if (size_needed > name_size)
branch  0 never executed
branch  1 never executed
        -: 5625:	    {
        -: 5626:	      char *new_name_space;
        -: 5627:
    #####: 5628:	      while (size_needed > name_size)
branch  0 never executed
branch  1 never executed
    #####: 5629:		name_size += 1024;
        -: 5630:
    #####: 5631:	      new_name_space = realloc (name_space, name_size);
    #####: 5632:	      if (new_name_space == NULL)
branch  0 never executed
branch  1 never executed
        -: 5633:		{
    #####: 5634:		  closedir (dirp);
call    0 never executed
    #####: 5635:		  return NULL;
        -: 5636:		}
    #####: 5637:	      namep += new_name_space - name_space;
    #####: 5638:	      name_space = new_name_space;
        -: 5639:	    }
    #####: 5640:	  namep = stpcpy (namep, dp->d_name) + 1;
        -: 5641:	}
        -: 5642:    }
    #####: 5643:  *namep = '\0';
    #####: 5644:  if (CLOSEDIR (dirp))
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 5645:    {
    #####: 5646:      free (name_space);
    #####: 5647:      return NULL;
        -: 5648:    }
    #####: 5649:  return name_space;
        -: 5650:}
        -: 5651:/* Getopt for GNU.
        -: 5652:   NOTE: The canonical source of this file is maintained with the GNU
        -: 5653:   C Library.  Bugs can be reported to bug-glibc@gnu.org.
        -: 5654:
        -: 5655:   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99
        -: 5656:   	Free Software Foundation, Inc.
        -: 5657:
        -: 5658:   This program is free software; you can redistribute it and/or modify it
        -: 5659:   under the terms of the GNU General Public License as published by the
        -: 5660:   Free Software Foundation; either version 2, or (at your option) any
        -: 5661:   later version.
        -: 5662:
        -: 5663:   This program is distributed in the hope that it will be useful,
        -: 5664:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 5665:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 5666:   GNU General Public License for more details.
        -: 5667:
        -: 5668:   You should have received a copy of the GNU General Public License
        -: 5669:   along with this program; if not, write to the Free Software Foundation,
        -: 5670:   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 5671:
        -: 5672:/* This tells Alpha OSF/1 not to define a getopt prototype in <stdio.h>.
        -: 5673:   Ditto for AIX 3.2 and <stdlib.h>.  */
        -: 5674:#ifndef _NO_PROTO
        -: 5675:# define _NO_PROTO
        -: 5676:#endif
        -: 5677:
        -: 5678:#ifdef HAVE_CONFIG_H
        -: 5679:#if flag_config==0
        -: 5680:# include <config.h>
        -: 5681:#define flag_config 1
        -: 5682:#endif
        -: 5683:#else
        -: 5684:# if !defined __STDC__ || !__STDC__
        -: 5685:/* This is a separate conditional since some stdc systems
        -: 5686:   reject `defined (const)'.  */
        -: 5687:#  ifndef const
        -: 5688:#   define const
        -: 5689:#  endif
        -: 5690:# endif
        -: 5691:#endif
        -: 5692:
        -: 5693:/*#include <stdio.h>*/
        -: 5694:
        -: 5695:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 5696:   actually compiling the library itself.  This code is part of the GNU C
        -: 5697:   Library, but also included in many other GNU distributions.  Compiling
        -: 5698:   and linking in this code is a waste when using the GNU C library
        -: 5699:   (especially if it is a shared library).  Rather than having every GNU
        -: 5700:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 5701:   it is simpler to just do this in the source for each such file.  */
        -: 5702:
        -: 5703:#define GETOPT_INTERFACE_VERSION 2
        -: 5704:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 5705:#if flag_gnuversions==0
        -: 5706:# include <gnu-versions.h>
        -: 5707:#define flag_gnuversions 1
        -: 5708:#endif
        -: 5709:# if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 5710:#  define ELIDE_CODE
        -: 5711:# endif
        -: 5712:#endif
        -: 5713:
        -: 5714:#ifndef ELIDE_CODE
        -: 5715:
        -: 5716:
        -: 5717:/* This needs to come after some library #include
        -: 5718:   to get __GNU_LIBRARY__ defined.  */
        -: 5719:#ifdef	__GNU_LIBRARY__
        -: 5720:/* Don't include stdlib.h for non-GNU C libraries because some of them
        -: 5721:   contain conflicting prototypes for getopt.  */
        -: 5722:#if flag_stdlib==0   
        -: 5723:# include <stdlib.h>
        -: 5724:#define flag_stdlib 1
        -: 5725:#endif
        -: 5726:#if flag_unistd==0
        -: 5727:# include <unistd.h>
        -: 5728:#define flag_unistd 1
        -: 5729:#endif
        -: 5730:#endif	/* GNU C library.  */
        -: 5731:
        -: 5732:#ifdef VMS
        -: 5733:# include <unixlib.h>
        -: 5734:# if HAVE_STRING_H - 0
        -: 5735:#if flag_string==0
        -: 5736:#  include <string.h>
        -: 5737:#define flag_string 1
        -: 5738:#endif
        -: 5739:# endif
        -: 5740:#endif
        -: 5741:
        -: 5742:#ifndef _
        -: 5743:/* This is for other GNU distributions with internationalized messages.
        -: 5744:   When compiling libc, the _ macro is predefined.  */
        -: 5745:# ifdef HAVE_LIBINTL_H
        -: 5746:#if flag_libintl==0
        -: 5747:#  include <libintl.h>
        -: 5748:#define flag_libintl 1
        -: 5749:#endif
        -: 5750:#  define _(msgid)	gettext (msgid)
        -: 5751:# else
        -: 5752:#  define _(msgid)	(msgid)
        -: 5753:# endif
        -: 5754:#endif
        -: 5755:
        -: 5756:/* This version of `getopt' appears to the caller like standard Unix `getopt'
        -: 5757:   but it behaves differently for the user, since it allows the user
        -: 5758:   to intersperse the options with the other arguments.
        -: 5759:
        -: 5760:   As `getopt' works, it permutes the elements of ARGV so that,
        -: 5761:   when it is done, all the options precede everything else.  Thus
        -: 5762:   all application programs are extended to handle flexible argument order.
        -: 5763:
        -: 5764:   Setting the environment variable POSIXLY_CORRECT disables permutation.
        -: 5765:   Then the behavior is completely standard.
        -: 5766:
        -: 5767:   GNU application programs can use a third alternative mode in which
        -: 5768:   they can distinguish the relative order of options and other arguments.  */
        -: 5769:
        -: 5770:/*#include "getopt.h"*/
        -: 5771:
        -: 5772:/* For communication from `getopt' to the caller.
        -: 5773:   When `getopt' finds an option that takes an argument,
        -: 5774:   the argument value is returned here.
        -: 5775:   Also, when `ordering' is RETURN_IN_ORDER,
        -: 5776:   each non-option ARGV-element is returned here.  */
        -: 5777:
        -: 5778:char *optarg;
        -: 5779:
        -: 5780:/* Index in ARGV of the next element to be scanned.
        -: 5781:   This is used for communication to and from the caller
        -: 5782:   and for communication between successive calls to `getopt'.
        -: 5783:
        -: 5784:   On entry to `getopt', zero means this is the first call; initialize.
        -: 5785:
        -: 5786:   When `getopt' returns -1, this is the index of the first of the
        -: 5787:   non-option elements that the caller should itself scan.
        -: 5788:
        -: 5789:   Otherwise, `optind' communicates from one call to the next
        -: 5790:   how much of ARGV has been scanned so far.  */
        -: 5791:
        -: 5792:/* 1003.2 says this must be 1 before any call.  */
        -: 5793:int optind = 1;
        -: 5794:
        -: 5795:/* Formerly, initialization of getopt depended on optind==0, which
        -: 5796:   causes problems with re-calling getopt as programs generally don't
        -: 5797:   know that. */
        -: 5798:
        -: 5799:int __getopt_initialized;
        -: 5800:
        -: 5801:/* The next char to be scanned in the option-element
        -: 5802:   in which the last option character we returned was found.
        -: 5803:   This allows us to pick up the scan where we left off.
        -: 5804:
        -: 5805:   If this is zero, or a null string, it means resume the scan
        -: 5806:   by advancing to the next ARGV-element.  */
        -: 5807:
        -: 5808:static char *nextchar;
        -: 5809:
        -: 5810:/* Callers store zero here to inhibit the error message
        -: 5811:   for unrecognized options.  */
        -: 5812:
        -: 5813:int opterr = 1;
        -: 5814:
        -: 5815:/* Set to an option character which was unrecognized.
        -: 5816:   This must be initialized on some systems to avoid linking in the
        -: 5817:   system's own getopt implementation.  */
        -: 5818:
        -: 5819:int optopt = '?';
        -: 5820:
        -: 5821:/* Describe how to deal with options that follow non-option ARGV-elements.
        -: 5822:
        -: 5823:   If the caller did not specify anything,
        -: 5824:   the default is REQUIRE_ORDER if the environment variable
        -: 5825:   POSIXLY_CORRECT is defined, PERMUTE otherwise.
        -: 5826:
        -: 5827:   REQUIRE_ORDER means don't recognize them as options;
        -: 5828:   stop option processing when the first non-option is seen.
        -: 5829:   This is what Unix does.
        -: 5830:   This mode of operation is selected by either setting the environment
        -: 5831:   variable POSIXLY_CORRECT, or using `+' as the first character
        -: 5832:   of the list of option characters.
        -: 5833:
        -: 5834:   PERMUTE is the default.  We permute the contents of ARGV as we scan,
        -: 5835:   so that eventually all the non-options are at the end.  This allows options
        -: 5836:   to be given in any order, even with programs that were not written to
        -: 5837:   expect this.
        -: 5838:
        -: 5839:   RETURN_IN_ORDER is an option available to programs that were written
        -: 5840:   to expect options and other ARGV-elements in any order and that care about
        -: 5841:   the ordering of the two.  We describe each non-option ARGV-element
        -: 5842:   as if it were the argument of an option with character code 1.
        -: 5843:   Using `-' as the first character of the list of option characters
        -: 5844:   selects this mode of operation.
        -: 5845:
        -: 5846:   The special argument `--' forces an end of option-scanning regardless
        -: 5847:   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only
        -: 5848:   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */
        -: 5849:
        -: 5850:static enum
        -: 5851:{
        -: 5852:  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER
        -: 5853:} ordering;
        -: 5854:
        -: 5855:/* Value of POSIXLY_CORRECT environment variable.  */
        -: 5856:static char *posixly_correct;
        -: 5857:
        -: 5858:#ifdef	__GNU_LIBRARY__
        -: 5859:/* We want to avoid inclusion of string.h with non-GNU libraries
        -: 5860:   because there are many ways it can cause trouble.
        -: 5861:   On some systems, it contains special magic macros that don't work
        -: 5862:   in GCC.  */
        -: 5863:#if flag_string==0   
        -: 5864:# include <string.h>
        -: 5865:#define flag_string 1
        -: 5866:#endif
        -: 5867:# define my_index	strchr
        -: 5868:#else
        -: 5869:
        -: 5870:# if HAVE_STRING_H
        -: 5871:#if flag_string==0
        -: 5872:#  include <string.h>
        -: 5873:#define flag_string 1
        -: 5874:#endif
        -: 5875:# else
        -: 5876:#if flag_strings==0
        -: 5877:#  include <strings.h>
        -: 5878:#define flag_strings 1
        -: 5879:#endif
        -: 5880:# endif
        -: 5881:
        -: 5882:/* Avoid depending on library functions or files
        -: 5883:   whose names are inconsistent.  */
        -: 5884:
        -: 5885:#ifndef getenv
        -: 5886:extern char *getenv ();
        -: 5887:#endif
        -: 5888:
        -: 5889:static char *
        -: 5890:my_index (str, chr)
        -: 5891:     const char *str;
        -: 5892:     int chr;
        -: 5893:{
        -: 5894:  while (*str)
        -: 5895:    {
        -: 5896:      if (*str == chr)
        -: 5897:	return (char *) str;
        -: 5898:      str++;
        -: 5899:    }
        -: 5900:  return 0;
        -: 5901:}
        -: 5902:
        -: 5903:/* If using GCC, we can safely declare strlen this way.
        -: 5904:   If not using GCC, it is ok not to declare it.  */
        -: 5905:#ifdef __GNUC__
        -: 5906:/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.
        -: 5907:   That was relevant to code that was here before.  */
        -: 5908:# if (!defined __STDC__ || !__STDC__) && !defined strlen
        -: 5909:/* gcc with -traditional declares the built-in strlen to return int,
        -: 5910:   and has done so at least since version 2.4.5. -- rms.  */
        -: 5911:extern int strlen (const char *);
        -: 5912:# endif /* not __STDC__ */
        -: 5913:#endif /* __GNUC__ */
        -: 5914:
        -: 5915:#endif /* not __GNU_LIBRARY__ */
        -: 5916:
        -: 5917:/* Handle permutation of arguments.  */
        -: 5918:
        -: 5919:/* Describe the part of ARGV that contains non-options that have
        -: 5920:   been skipped.  `first_nonopt' is the index in ARGV of the first of them;
        -: 5921:   `last_nonopt' is the index after the last of them.  */
        -: 5922:
        -: 5923:static int first_nonopt;
        -: 5924:static int last_nonopt;
        -: 5925:
        -: 5926:#ifdef _LIBC
        -: 5927:/* Bash 2.0 gives us an environment variable containing flags
        -: 5928:   indicating ARGV elements that should not be considered arguments.  */
        -: 5929:
        -: 5930:/* Defined in getopt_init.c  */
        -: 5931:extern char *__getopt_nonoption_flags;
        -: 5932:
        -: 5933:static int nonoption_flags_max_len;
        -: 5934:static int nonoption_flags_len;
        -: 5935:
        -: 5936:static int original_argc;
        -: 5937:static char *const *original_argv;
        -: 5938:
        -: 5939:/* Make sure the environment variable bash 2.0 puts in the environment
        -: 5940:   is valid for the getopt call we must make sure that the ARGV passed
        -: 5941:   to getopt is that one passed to the process.  */
        -: 5942:static void
        -: 5943:__attribute__ ((unused))
        -: 5944:store_args_and_env (int argc, char *const *argv)
        -: 5945:{
        -: 5946:  /* XXX This is no good solution.  We should rather copy the args so
        -: 5947:     that we can compare them later.  But we must not use malloc(3).  */
        -: 5948:  original_argc = argc;
        -: 5949:  original_argv = argv;
        -: 5950:}
        -: 5951:# ifdef text_set_element
        -: 5952:text_set_element (__libc_subinit, store_args_and_env);
        -: 5953:# endif /* text_set_element */
        -: 5954:
        -: 5955:# define SWAP_FLAGS(ch1, ch2) \
        -: 5956:  if (nonoption_flags_len > 0)						      \
        -: 5957:    {									      \
        -: 5958:      char __tmp = __getopt_nonoption_flags[ch1];			      \
        -: 5959:      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \
        -: 5960:      __getopt_nonoption_flags[ch2] = __tmp;				      \
        -: 5961:    }
        -: 5962:#else	/* !_LIBC */
        -: 5963:# define SWAP_FLAGS(ch1, ch2)
        -: 5964:#endif	/* _LIBC */
        -: 5965:
        -: 5966:/* Exchange two adjacent subsequences of ARGV.
        -: 5967:   One subsequence is elements [first_nonopt,last_nonopt)
        -: 5968:   which contains all the non-options that have been skipped so far.
        -: 5969:   The other is elements [last_nonopt,optind), which contains all
        -: 5970:   the options processed since those non-options were skipped.
        -: 5971:
        -: 5972:   `first_nonopt' and `last_nonopt' are relocated so that they describe
        -: 5973:   the new indices of the non-options in ARGV after they are moved.  */
        -: 5974:
        -: 5975:#if defined __STDC__ && __STDC__
        -: 5976:static void exchange (char **);
        -: 5977:#endif
        -: 5978:
        -: 5979:static void
        -: 5980:exchange (argv)
        -: 5981:     char **argv;
        -: 5982:{
        -: 5983:  int bottom = first_nonopt;
        -: 5984:  int middle = last_nonopt;
        -: 5985:  int top = optind;
        -: 5986:  char *tem;
        -: 5987:
        -: 5988:  /* Exchange the shorter segment with the far end of the longer segment.
        -: 5989:     That puts the shorter segment into the right place.
        -: 5990:     It leaves the longer segment in the right place overall,
        -: 5991:     but it consists of two parts that need to be swapped next.  */
        -: 5992:
        -: 5993:#ifdef _LIBC
        -: 5994:  /* First make sure the handling of the `__getopt_nonoption_flags'
        -: 5995:     string can work normally.  Our top argument must be in the range
        -: 5996:     of the string.  */
        -: 5997:  #ifndef FAULTY_F_DG_5  
        -: 5998:  if (nonoption_flags_len > 0 && top >= nonoption_flags_max_len)
        -: 5999:  #else
        -: 6000:  if (nonoption_flags_len > 0 && top <= nonoption_flags_max_len)
        -: 6001:  #endif
        -: 6002:    {
        -: 6003:      /* We must extend the array.  The user plays games with us and
        -: 6004:	 presents new arguments.  */
        -: 6005:      char *new_str = malloc (top + 1);
        -: 6006:      if (new_str == NULL)
        -: 6007:	nonoption_flags_len = nonoption_flags_max_len = 0;
        -: 6008:      else
        -: 6009:	{
        -: 6010:	  memset (__mempcpy (new_str, __getopt_nonoption_flags,
        -: 6011:#ifndef FAULTY_F_KP_4
        -: 6012:			     nonoption_flags_max_len),
        -: 6013:#else
        -: 6014:			     nonoption_flags_len),
        -: 6015:#endif
        -: 6016:		  '\0', top + 1 - nonoption_flags_max_len);
        -: 6017:	  nonoption_flags_max_len = top + 1;
        -: 6018:	  __getopt_nonoption_flags = new_str;
        -: 6019:	}
        -: 6020:    }
        -: 6021:#endif
        -: 6022:
        -: 6023:  while (top > middle && middle > bottom)
        -: 6024:    {
        -: 6025:      if (top - middle > middle - bottom)
        -: 6026:	{
        -: 6027:	  /* Bottom segment is the short one.  */
        -: 6028:	  int len = middle - bottom;
        -: 6029:	  register int i;
        -: 6030:
        -: 6031:	  /* Swap it with the top part of the top segment.  */
        -: 6032:	  for (i = 0; i < len; i++)
        -: 6033:	    {
        -: 6034:	      tem = argv[bottom + i];
        -: 6035:	      argv[bottom + i] = argv[top - (middle - bottom) + i];
        -: 6036:	      argv[top - (middle - bottom) + i] = tem;
        -: 6037:	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);
        -: 6038:	    }
        -: 6039:	  /* Exclude the moved bottom segment from further swapping.  */
        -: 6040:	  top -= len;
        -: 6041:	}
        -: 6042:      else
        -: 6043:	{
        -: 6044:	  /* Top segment is the short one.  */
        -: 6045:	  int len = top - middle;
        -: 6046:	  register int i;
        -: 6047:
        -: 6048:	  /* Swap it with the bottom part of the bottom segment.  */
        -: 6049:	  for (i = 0; i < len; i++)
        -: 6050:	    {
        -: 6051:	      tem = argv[bottom + i];
        -: 6052:	      argv[bottom + i] = argv[middle + i];
        -: 6053:	      argv[middle + i] = tem;
        -: 6054:	      SWAP_FLAGS (bottom + i, middle + i);
        -: 6055:	    }
        -: 6056:	  /* Exclude the moved top segment from further swapping.  */
        -: 6057:	  bottom += len;
        -: 6058:	}
        -: 6059:    }
        -: 6060:
        -: 6061:  /* Update records for the slots the non-options now occupy.  */
        -: 6062:
        -: 6063:  first_nonopt += (optind - last_nonopt);
        -: 6064:  last_nonopt = optind;
        -: 6065:}
        -: 6066:
        -: 6067:/* Initialize the internal data when the first call is made.  */
        -: 6068:
        -: 6069:#if defined __STDC__ && __STDC__
        -: 6070:static const char *_getopt_initialize (int, char *const *, const char *);
        -: 6071:#endif
        -: 6072:static const char *
        -: 6073:_getopt_initialize (argc, argv, optstring)
        -: 6074:     int argc;
        -: 6075:     char *const *argv;
        -: 6076:     const char *optstring;
        -: 6077:{
        -: 6078:  /* Start processing options with ARGV-element 1 (since ARGV-element 0
        -: 6079:     is the program name); the sequence of previously skipped
        -: 6080:     non-option ARGV-elements is empty.  */
        -: 6081:
        -: 6082:  first_nonopt = last_nonopt = optind;
        -: 6083:
        -: 6084:  nextchar = NULL;
        -: 6085:
        -: 6086:  posixly_correct = getenv ("POSIXLY_CORRECT");
        -: 6087:
        -: 6088:  /* Determine how to handle the ordering of options and nonoptions.  */
        -: 6089:
        -: 6090:  if (optstring[0] == '-')
        -: 6091:    {
        -: 6092:      ordering = RETURN_IN_ORDER;
        -: 6093:      ++optstring;
        -: 6094:    }
        -: 6095:  else if (optstring[0] == '+')
        -: 6096:    {
        -: 6097:      ordering = REQUIRE_ORDER;
        -: 6098:      ++optstring;
        -: 6099:    }
        -: 6100:  else if (posixly_correct != NULL)
        -: 6101:    ordering = REQUIRE_ORDER;
        -: 6102:  else
        -: 6103:    ordering = PERMUTE;
        -: 6104:
        -: 6105:#ifdef _LIBC
        -: 6106:  if (posixly_correct == NULL
        -: 6107:      && argc == original_argc && argv == original_argv)
        -: 6108:    {
        -: 6109:      if (nonoption_flags_max_len == 0)
        -: 6110:	{
        -: 6111:	  if (__getopt_nonoption_flags == NULL
        -: 6112:	      || __getopt_nonoption_flags[0] == '\0')
        -: 6113:	    nonoption_flags_max_len = -1;
        -: 6114:	  else
        -: 6115:	    {
        -: 6116:	      const char *orig_str = __getopt_nonoption_flags;
        -: 6117:	      int len = nonoption_flags_max_len = strlen (orig_str);
        -: 6118:#ifndef FAULTY_F_KP_1
        -: 6119:	      if (nonoption_flags_max_len < argc)
        -: 6120:#else
        -: 6121:	      if (nonoption_flags_max_len > argc)
        -: 6122:#endif
        -: 6123:		nonoption_flags_max_len = argc;
        -: 6124:	      __getopt_nonoption_flags =
        -: 6125:		(char *) malloc (nonoption_flags_max_len);
        -: 6126:	      if (__getopt_nonoption_flags == NULL)
        -: 6127:		nonoption_flags_max_len = -1;
        -: 6128:	      else
        -: 6129:		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),
        -: 6130:			'\0', nonoption_flags_max_len - len);
        -: 6131:	    }
        -: 6132:	}
        -: 6133:      nonoption_flags_len = nonoption_flags_max_len;
        -: 6134:    }
        -: 6135:  else
        -: 6136:    nonoption_flags_len = 0;
        -: 6137:#endif
        -: 6138:
        -: 6139:  return optstring;
        -: 6140:}
        -: 6141:
        -: 6142:/* Scan elements of ARGV (whose length is ARGC) for option characters
        -: 6143:   given in OPTSTRING.
        -: 6144:
        -: 6145:   If an element of ARGV starts with '-', and is not exactly "-" or "--",
        -: 6146:   then it is an option element.  The characters of this element
        -: 6147:   (aside from the initial '-') are option characters.  If `getopt'
        -: 6148:   is called repeatedly, it returns successively each of the option characters
        -: 6149:   from each of the option elements.
        -: 6150:
        -: 6151:   If `getopt' finds another option character, it returns that character,
        -: 6152:   updating `optind' and `nextchar' so that the next call to `getopt' can
        -: 6153:   resume the scan with the following option character or ARGV-element.
        -: 6154:
        -: 6155:   If there are no more option characters, `getopt' returns -1.
        -: 6156:   Then `optind' is the index in ARGV of the first ARGV-element
        -: 6157:   that is not an option.  (The ARGV-elements have been permuted
        -: 6158:   so that those that are not options now come last.)
        -: 6159:
        -: 6160:   OPTSTRING is a string containing the legitimate option characters.
        -: 6161:   If an option character is seen that is not listed in OPTSTRING,
        -: 6162:   return '?' after printing an error message.  If you set `opterr' to
        -: 6163:   zero, the error message is suppressed but we still return '?'.
        -: 6164:
        -: 6165:   If a char in OPTSTRING is followed by a colon, that means it wants an arg,
        -: 6166:   so the following text in the same ARGV-element, or the text of the following
        -: 6167:   ARGV-element, is returned in `optarg'.  Two colons mean an option that
        -: 6168:   wants an optional arg; if there is text in the current ARGV-element,
        -: 6169:   it is returned in `optarg', otherwise `optarg' is set to zero.
        -: 6170:
        -: 6171:   If OPTSTRING starts with `-' or `+', it requests different methods of
        -: 6172:   handling the non-option ARGV-elements.
        -: 6173:   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
        -: 6174:
        -: 6175:   Long-named options begin with `--' instead of `-'.
        -: 6176:   Their names may be abbreviated as long as the abbreviation is unique
        -: 6177:   or is an exact match for some defined option.  If they have an
        -: 6178:   argument, it follows the option name in the same ARGV-element, separated
        -: 6179:   from the option name by a `=', or else the in next ARGV-element.
        -: 6180:   When `getopt' finds a long-named option, it returns 0 if that option's
        -: 6181:   `flag' field is nonzero, the value of the option's `val' field
        -: 6182:   if the `flag' field is zero.
        -: 6183:
        -: 6184:   The elements of ARGV aren't really const, because we permute them.
        -: 6185:   But we pretend they're const in the prototype to be compatible
        -: 6186:   with other systems.
        -: 6187:
        -: 6188:   LONGOPTS is a vector of `struct option' terminated by an
        -: 6189:   element containing a name which is zero.
        -: 6190:
        -: 6191:   LONGIND returns the index in LONGOPT of the long-named option found.
        -: 6192:   It is only valid when a long-named option has been found by the most
        -: 6193:   recent call.
        -: 6194:
        -: 6195:   If LONG_ONLY is nonzero, '-' as well as '--' can introduce
        -: 6196:   long-named options.  */
        -: 6197:
        -: 6198:int
        -: 6199:_getopt_internal (argc, argv, optstring, longopts, longind, long_only)
        -: 6200:     int argc;
        -: 6201:     char *const *argv;
        -: 6202:     const char *optstring;
        -: 6203:     const struct option *longopts;
        -: 6204:     int *longind;
        -: 6205:     int long_only;
        -: 6206:{
        -: 6207:  optarg = NULL;
        -: 6208:
        -: 6209:  if (optind == 0 || !__getopt_initialized)
        -: 6210:    {
        -: 6211:#ifndef FAULTY_F_KP_2
        -: 6212:      if (optind == 0)
        -: 6213:#else
        -: 6214:	/* nothing here */
        -: 6215:#endif
        -: 6216:	optind = 1;	/* Don't scan ARGV[0], the program name.  */
        -: 6217:      optstring = _getopt_initialize (argc, argv, optstring);
        -: 6218:      __getopt_initialized = 1;
        -: 6219:    }
        -: 6220:
        -: 6221:  /* Test whether ARGV[optind] points to a non-option argument.
        -: 6222:     Either it does not have option syntax, or there is an environment flag
        -: 6223:     from the shell indicating it is not an option.  The later information
        -: 6224:     is only used when the used in the GNU libc.  */
        -: 6225:#ifdef _LIBC
        -: 6226:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \
        -: 6227:		      || (optind < nonoption_flags_len			      \
        -: 6228:			  && __getopt_nonoption_flags[optind] == '1'))
        -: 6229:#else
        -: 6230:# define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')
        -: 6231:#endif
        -: 6232:
        -: 6233:  if (nextchar == NULL || *nextchar == '\0')
        -: 6234:    {
        -: 6235:      /* Advance to the next ARGV-element.  */
        -: 6236:
        -: 6237:      /* Give FIRST_NONOPT & LAST_NONOPT rational values if OPTIND has been
        -: 6238:	 moved back by the user (who may also have changed the arguments).  */
        -: 6239:      if (last_nonopt > optind)
        -: 6240:	last_nonopt = optind;
        -: 6241:      if (first_nonopt > optind)
        -: 6242:	first_nonopt = optind;
        -: 6243:
        -: 6244:      if (ordering == PERMUTE)
        -: 6245:	{
        -: 6246:	  /* If we have just processed some options following some non-options,
        -: 6247:	     exchange them so that the options come first.  */
        -: 6248:
        -: 6249:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 6250:	    exchange ((char **) argv);
        -: 6251:	  else if (last_nonopt != optind)
        -: 6252:	    first_nonopt = optind;
        -: 6253:
        -: 6254:	  /* Skip any additional non-options
        -: 6255:	     and extend the range of non-options previously skipped.  */
        -: 6256:
        -: 6257:	  while (optind < argc && NONOPTION_P)
        -: 6258:	    optind++;
        -: 6259:	  last_nonopt = optind;
        -: 6260:	}
        -: 6261:
        -: 6262:      /* The special ARGV-element `--' means premature end of options.
        -: 6263:	 Skip it like a null option,
        -: 6264:	 then exchange with previous non-options as if it were an option,
        -: 6265:	 then skip everything else like a non-option.  */
        -: 6266:
        -: 6267:      if (optind != argc && !strcmp (argv[optind], "--"))
        -: 6268:	{
        -: 6269:	  optind++;
        -: 6270:
        -: 6271:	  if (first_nonopt != last_nonopt && last_nonopt != optind)
        -: 6272:	    exchange ((char **) argv);
        -: 6273:	  else if (first_nonopt == last_nonopt)
        -: 6274:	    first_nonopt = optind;
        -: 6275:	  last_nonopt = argc;
        -: 6276:
        -: 6277:	  optind = argc;
        -: 6278:	}
        -: 6279:
        -: 6280:      /* If we have done all the ARGV-elements, stop the scan
        -: 6281:	 and back over any non-options that we skipped and permuted.  */
        -: 6282:
        -: 6283:      if (optind == argc)
        -: 6284:	{
        -: 6285:	  /* Set the next-arg-index to point at the non-options
        -: 6286:	     that we previously skipped, so the caller will digest them.  */
        -: 6287:	  if (first_nonopt != last_nonopt)
        -: 6288:	    optind = first_nonopt;
        -: 6289:	  return -1;
        -: 6290:	}
        -: 6291:
        -: 6292:      /* If we have come to a non-option and did not permute it,
        -: 6293:	 either stop the scan or describe it to the caller and pass it by.  */
        -: 6294:
        -: 6295:      if (NONOPTION_P)
        -: 6296:	{
        -: 6297:	  if (ordering == REQUIRE_ORDER)
        -: 6298:	    return -1;
        -: 6299:	  optarg = argv[optind++];
        -: 6300:	  return 1;
        -: 6301:	}
        -: 6302:
        -: 6303:      /* We have found another option-ARGV-element.
        -: 6304:	 Skip the initial punctuation.  */
        -: 6305:
        -: 6306:      nextchar = (argv[optind] + 1
        -: 6307:		  + (longopts != NULL && argv[optind][1] == '-'));
        -: 6308:    }
        -: 6309:
        -: 6310:  /* Decode the current option-ARGV-element.  */
        -: 6311:
        -: 6312:  /* Check whether the ARGV-element is a long option.
        -: 6313:
        -: 6314:     If long_only and the ARGV-element has the form "-f", where f is
        -: 6315:     a valid short option, don't consider it an abbreviated form of
        -: 6316:     a long option that starts with f.  Otherwise there would be no
        -: 6317:     way to give the -f short option.
        -: 6318:
        -: 6319:     On the other hand, if there's a long option "fubar" and
        -: 6320:     the ARGV-element is "-fu", do consider that an abbreviation of
        -: 6321:     the long option, just like "--fu", and not "-f" with arg "u".
        -: 6322:
        -: 6323:     This distinction seems to be the most useful approach.  */
        -: 6324:
        -: 6325:  if (longopts != NULL
        -: 6326:      && (argv[optind][1] == '-'
        -: 6327:	  || (long_only && (argv[optind][2] || !my_index (optstring, argv[optind][1])))))
        -: 6328:    {
        -: 6329:      char *nameend;
        -: 6330:      const struct option *p;
        -: 6331:      const struct option *pfound = NULL;
        -: 6332:      int exact = 0;
        -: 6333:      int ambig = 0;
        -: 6334:      int indfound = -1;
        -: 6335:      int option_index;
        -: 6336:
        -: 6337:      for (nameend = nextchar; *nameend && *nameend != '='; nameend++)
        -: 6338:	/* Do nothing.  */ ;
        -: 6339:
        -: 6340:      /* Test all long options for either exact match
        -: 6341:	 or abbreviated matches.  */
        -: 6342:      for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 6343:	if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 6344:	  {
        -: 6345:	    if ((unsigned int) (nameend - nextchar)
        -: 6346:		== (unsigned int) strlen (p->name))
        -: 6347:	      {
        -: 6348:		/* Exact match found.  */
        -: 6349:		pfound = p;
        -: 6350:		indfound = option_index;
        -: 6351:		exact = 1;
        -: 6352:		break;
        -: 6353:	      }
        -: 6354:	    else if (pfound == NULL)
        -: 6355:	      {
        -: 6356:		/* First nonexact match found.  */
        -: 6357:		pfound = p;
        -: 6358:		indfound = option_index;
        -: 6359:	      }
        -: 6360:	    else
        -: 6361:	      /* Second or later nonexact match found.  */
        -: 6362:	      ambig = 1;
        -: 6363:	  }
        -: 6364:
        -: 6365:      if (ambig && !exact)
        -: 6366:	{
        -: 6367:	  if (opterr)
        -: 6368:	    fprintf (stderr, _("%s: option `%s' is ambiguous\n"),
        -: 6369:		     argv[0], argv[optind]);
        -: 6370:	  nextchar += strlen (nextchar);
        -: 6371:	  optind++;
        -: 6372:	  optopt = 0;
        -: 6373:	  return '?';
        -: 6374:	}
        -: 6375:
        -: 6376:      if (pfound != NULL)
        -: 6377:	{
        -: 6378:	  option_index = indfound;
        -: 6379:	  optind++;
        -: 6380:	  if (*nameend)
        -: 6381:	    {
        -: 6382:	      /* Don't test has_arg with >, because some C compilers don't
        -: 6383:		 allow it to be used on enums.  */
        -: 6384:	      if (pfound->has_arg)
        -: 6385:		optarg = nameend + 1;
        -: 6386:	      else
        -: 6387:		{
        -: 6388:		  if (opterr)
        -: 6389:		    {
        -: 6390:		      if (argv[optind - 1][1] == '-')
        -: 6391:			/* --option */
        -: 6392:			fprintf (stderr,
        -: 6393:				 _("%s: option `--%s' doesn't allow an argument\n"),
        -: 6394:				 argv[0], pfound->name);
        -: 6395:		      else
        -: 6396:			/* +option or -option */
        -: 6397:			fprintf (stderr,
        -: 6398:				 _("%s: option `%c%s' doesn't allow an argument\n"),
        -: 6399:				 argv[0], argv[optind - 1][0], pfound->name);
        -: 6400:		    }
        -: 6401:
        -: 6402:		  nextchar += strlen (nextchar);
        -: 6403:
        -: 6404:		  optopt = pfound->val;
        -: 6405:		  return '?';
        -: 6406:		}
        -: 6407:	    }
        -: 6408:	  else if (pfound->has_arg == 1)
        -: 6409:	    {
        -: 6410:	      if (optind < argc)
        -: 6411:		optarg = argv[optind++];
        -: 6412:	      else
        -: 6413:		{
        -: 6414:		  if (opterr)
        -: 6415:		    fprintf (stderr,
        -: 6416:			   _("%s: option `%s' requires an argument\n"),
        -: 6417:			   argv[0], argv[optind - 1]);
        -: 6418:		  nextchar += strlen (nextchar);
        -: 6419:		  optopt = pfound->val;
        -: 6420:		  return optstring[0] == ':' ? ':' : '?';
        -: 6421:		}
        -: 6422:	    }
        -: 6423:	  nextchar += strlen (nextchar);
        -: 6424:	  if (longind != NULL)
        -: 6425:	    *longind = option_index;
        -: 6426:	  if (pfound->flag)
        -: 6427:	    {
        -: 6428:	      *(pfound->flag) = pfound->val;
        -: 6429:	      return 0;
        -: 6430:	    }
        -: 6431:	  return pfound->val;
        -: 6432:	}
        -: 6433:
        -: 6434:      /* Can't find it as a long option.  If this is not getopt_long_only,
        -: 6435:	 or the option starts with '--' or is not a valid short
        -: 6436:	 option, then it's an error.
        -: 6437:	 Otherwise interpret it as a short option.  */
        -: 6438:      if (!long_only || argv[optind][1] == '-'
        -: 6439:	  || my_index (optstring, *nextchar) == NULL)
        -: 6440:	{
        -: 6441:	  if (opterr)
        -: 6442:	    {
        -: 6443:	      if (argv[optind][1] == '-')
        -: 6444:		/* --option */
        -: 6445:		fprintf (stderr, _("%s: unrecognized option `--%s'\n"),
        -: 6446:			 argv[0], nextchar);
        -: 6447:	      else
        -: 6448:		/* +option or -option */
        -: 6449:		fprintf (stderr, _("%s: unrecognized option `%c%s'\n"),
        -: 6450:			 argv[0], argv[optind][0], nextchar);
        -: 6451:	    }
        -: 6452:	  nextchar = (char *) "";
        -: 6453:	  optind++;
        -: 6454:	  optopt = 0;
        -: 6455:	  return '?';
        -: 6456:	}
        -: 6457:    }
        -: 6458:
        -: 6459:  /* Look at and handle the next short option-character.  */
        -: 6460:
        -: 6461:  {
        -: 6462:    char c = *nextchar++;
        -: 6463:    char *temp = my_index (optstring, c);
        -: 6464:
        -: 6465:    /* Increment `optind' when we start to process its last character.  */
        -: 6466:    if (*nextchar == '\0')
        -: 6467:      ++optind;
        -: 6468:
        -: 6469:    if (temp == NULL || c == ':')
        -: 6470:      {
        -: 6471:	if (opterr)
        -: 6472:	  {
        -: 6473:	    if (posixly_correct)
        -: 6474:	      /* 1003.2 specifies the format of this message.  */
        -: 6475:	      fprintf (stderr, _("%s: illegal option -- %c\n"),
        -: 6476:		       argv[0], c);
        -: 6477:	    else
        -: 6478:	      fprintf (stderr, _("%s: invalid option -- %c\n"),
        -: 6479:		       argv[0], c);
        -: 6480:	  }
        -: 6481:	optopt = c;
        -: 6482:	return '?';
        -: 6483:      }
        -: 6484:    /* Convenience. Treat POSIX -W foo same as long option --foo */
        -: 6485:    if (temp[0] == 'W' && temp[1] == ';')
        -: 6486:      {
        -: 6487:	char *nameend;
        -: 6488:	const struct option *p;
        -: 6489:	const struct option *pfound = NULL;
        -: 6490:	int exact = 0;
        -: 6491:	int ambig = 0;
        -: 6492:	int indfound = 0;
        -: 6493:	int option_index;
        -: 6494:
        -: 6495:	/* This is an option that requires an argument.  */
        -: 6496:	if (*nextchar != '\0')
        -: 6497:	  {
        -: 6498:	    optarg = nextchar;
        -: 6499:	    /* If we end this ARGV-element by taking the rest as an arg,
        -: 6500:	       we must advance to the next element now.  */
        -: 6501:	    optind++;
        -: 6502:	  }
        -: 6503:	else if (optind == argc)
        -: 6504:	  {
        -: 6505:	    if (opterr)
        -: 6506:	      {
        -: 6507:		/* 1003.2 specifies the format of this message.  */
        -: 6508:		fprintf (stderr, _("%s: option requires an argument -- %c\n"),
        -: 6509:			 argv[0], c);
        -: 6510:	      }
        -: 6511:	    optopt = c;
        -: 6512:	    if (optstring[0] == ':')
        -: 6513:	      c = ':';
        -: 6514:	    else
        -: 6515:	      c = '?';
        -: 6516:	    return c;
        -: 6517:	  }
        -: 6518:	else
        -: 6519:	  /* We already incremented `optind' once;
        -: 6520:	     increment it again when taking next ARGV-elt as argument.  */
        -: 6521:	  optarg = argv[optind++];
        -: 6522:
        -: 6523:	/* optarg is now the argument, see if it's in the
        -: 6524:	   table of longopts.  */
        -: 6525:
        -: 6526:	for (nextchar = nameend = optarg; *nameend && *nameend != '='; nameend++)
        -: 6527:	  /* Do nothing.  */ ;
        -: 6528:
        -: 6529:	/* Test all long options for either exact match
        -: 6530:	   or abbreviated matches.  */
        -: 6531:	for (p = longopts, option_index = 0; p->name; p++, option_index++)
        -: 6532:	  if (!strncmp (p->name, nextchar, nameend - nextchar))
        -: 6533:	    {
        -: 6534:	      if ((unsigned int) (nameend - nextchar) == strlen (p->name))
        -: 6535:		{
        -: 6536:		  /* Exact match found.  */
        -: 6537:		  pfound = p;
        -: 6538:		  indfound = option_index;
        -: 6539:		  exact = 1;
        -: 6540:		  break;
        -: 6541:		}
        -: 6542:	      else if (pfound == NULL)
        -: 6543:		{
        -: 6544:		  /* First nonexact match found.  */
        -: 6545:		  pfound = p;
        -: 6546:		  indfound = option_index;
        -: 6547:		}
        -: 6548:	      else
        -: 6549:		/* Second or later nonexact match found.  */
        -: 6550:		ambig = 1;
        -: 6551:	    }
        -: 6552:	if (ambig && !exact)
        -: 6553:	  {
        -: 6554:	    if (opterr)
        -: 6555:	      fprintf (stderr, _("%s: option `-W %s' is ambiguous\n"),
        -: 6556:		       argv[0], argv[optind]);
        -: 6557:	    nextchar += strlen (nextchar);
        -: 6558:	    optind++;
        -: 6559:	    return '?';
        -: 6560:	  }
        -: 6561:	if (pfound != NULL)
        -: 6562:	  {
        -: 6563:	    option_index = indfound;
        -: 6564:	    if (*nameend)
        -: 6565:	      {
        -: 6566:		/* Don't test has_arg with >, because some C compilers don't
        -: 6567:		   allow it to be used on enums.  */
        -: 6568:		if (pfound->has_arg)
        -: 6569:		  optarg = nameend + 1;
        -: 6570:		else
        -: 6571:		  {
        -: 6572:		    if (opterr)
        -: 6573:		      fprintf (stderr, _("\
        -: 6574:%s: option `-W %s' doesn't allow an argument\n"),
        -: 6575:			       argv[0], pfound->name);
        -: 6576:
        -: 6577:		    nextchar += strlen (nextchar);
        -: 6578:		    return '?';
        -: 6579:		  }
        -: 6580:	      }
        -: 6581:	    else if (pfound->has_arg == 1)
        -: 6582:	      {
        -: 6583:		if (optind < argc)
        -: 6584:		  optarg = argv[optind++];
        -: 6585:		else
        -: 6586:		  {
        -: 6587:		    if (opterr)
        -: 6588:		      fprintf (stderr,
        -: 6589:			       _("%s: option `%s' requires an argument\n"),
        -: 6590:			       argv[0], argv[optind - 1]);
        -: 6591:		    nextchar += strlen (nextchar);
        -: 6592:		    return optstring[0] == ':' ? ':' : '?';
        -: 6593:		  }
        -: 6594:	      }
        -: 6595:	    nextchar += strlen (nextchar);
        -: 6596:	    if (longind != NULL)
        -: 6597:	      *longind = option_index;
        -: 6598:	    if (pfound->flag)
        -: 6599:	      {
        -: 6600:		*(pfound->flag) = pfound->val;
        -: 6601:		return 0;
        -: 6602:	      }
        -: 6603:	    return pfound->val;
        -: 6604:	  }
        -: 6605:	  nextchar = NULL;
        -: 6606:	  return 'W';	/* Let the application handle it.   */
        -: 6607:      }
        -: 6608:    if (temp[1] == ':')
        -: 6609:      {
        -: 6610:	if (temp[2] == ':')
        -: 6611:	  {
        -: 6612:	    /* This is an option that accepts an argument optionally.  */
        -: 6613:	    if (*nextchar != '\0')
        -: 6614:	      {
        -: 6615:		optarg = nextchar;
        -: 6616:		optind++;
        -: 6617:	      }
        -: 6618:	    else
        -: 6619:	      optarg = NULL;
        -: 6620:	    nextchar = NULL;
        -: 6621:	  }
        -: 6622:	else
        -: 6623:	  {
        -: 6624:	    /* This is an option that requires an argument.  */
        -: 6625:	    if (*nextchar != '\0')
        -: 6626:	      {
        -: 6627:		optarg = nextchar;
        -: 6628:		/* If we end this ARGV-element by taking the rest as an arg,
        -: 6629:		   we must advance to the next element now.  */
        -: 6630:		optind++;
        -: 6631:	      }
        -: 6632:	    else if (optind == argc)
        -: 6633:	      {
        -: 6634:		if (opterr)
        -: 6635:		  {
        -: 6636:		    /* 1003.2 specifies the format of this message.  */
        -: 6637:		    fprintf (stderr,
        -: 6638:			   _("%s: option requires an argument -- %c\n"),
        -: 6639:			   argv[0], c);
        -: 6640:		  }
        -: 6641:		optopt = c;
        -: 6642:		if (optstring[0] == ':')
        -: 6643:		  c = ':';
        -: 6644:		else
        -: 6645:		  c = '?';
        -: 6646:	      }
        -: 6647:	    else
        -: 6648:	      /* We already incremented `optind' once;
        -: 6649:		 increment it again when taking next ARGV-elt as argument.  */
        -: 6650:	      optarg = argv[optind++];
        -: 6651:	    nextchar = NULL;
        -: 6652:	  }
        -: 6653:      }
        -: 6654:    return c;
        -: 6655:  }
        -: 6656:}
        -: 6657:
        -: 6658:int
        -: 6659:getopt (argc, argv, optstring)
        -: 6660:     int argc;
        -: 6661:     char *const *argv;
        -: 6662:     const char *optstring;
        -: 6663:{
        -: 6664:  return _getopt_internal (argc, argv, optstring,
        -: 6665:			   (const struct option *) 0,
        -: 6666:			   (int *) 0,
        -: 6667:			   0);
        -: 6668:}
        -: 6669:
        -: 6670:#endif	/* Not ELIDE_CODE.  */
        -: 6671:
        -: 6672:#ifdef TEST
        -: 6673:
        -: 6674:/* Compile with -DTEST to make an executable for use in testing
        -: 6675:   the above definition of `getopt'.  */
        -: 6676:
        -: 6677:int
        -: 6678:main (argc, argv)
        -: 6679:     int argc;
        -: 6680:     char **argv;
        -: 6681:{
        -: 6682:  int c;
        -: 6683:  int digit_optind = 0;
        -: 6684:
        -: 6685:  while (1)
        -: 6686:    {
        -: 6687:      int this_option_optind = optind ? optind : 1;
        -: 6688:
        -: 6689:      c = getopt (argc, argv, "abc:d:0123456789");
        -: 6690:      if (c == -1)
        -: 6691:	break;
        -: 6692:
        -: 6693:      switch (c)
        -: 6694:	{
        -: 6695:	case '0':
        -: 6696:	case '1':
        -: 6697:	case '2':
        -: 6698:	case '3':
        -: 6699:	case '4':
        -: 6700:	case '5':
        -: 6701:	case '6':
        -: 6702:	case '7':
        -: 6703:	case '8':
        -: 6704:	case '9':
        -: 6705:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6706:	    printf ("digits occur in two different argv-elements.\n");
        -: 6707:	  digit_optind = this_option_optind;
        -: 6708:	  printf ("option %c\n", c);
        -: 6709:	  break;
        -: 6710:
        -: 6711:	case 'a':
        -: 6712:	  printf ("option a\n");
        -: 6713:	  break;
        -: 6714:
        -: 6715:	case 'b':
        -: 6716:	  printf ("option b\n");
        -: 6717:	  break;
        -: 6718:
        -: 6719:	case 'c':
        -: 6720:	  printf ("option c with value `%s'\n", optarg);
        -: 6721:	  break;
        -: 6722:
        -: 6723:	case '?':
        -: 6724:	  break;
        -: 6725:
        -: 6726:	default:
        -: 6727:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6728:	}
        -: 6729:    }
        -: 6730:
        -: 6731:  if (optind < argc)
        -: 6732:    {
        -: 6733:      printf ("non-option ARGV-elements: ");
        -: 6734:      while (optind < argc)
        -: 6735:	printf ("%s ", argv[optind++]);
        -: 6736:      printf ("\n");
        -: 6737:    }
        -: 6738:
        -: 6739:  exit (0);
        -: 6740:}
        -: 6741:
        -: 6742:#endif /* TEST */
        -: 6743:/* getopt_long and getopt_long_only entry points for GNU getopt.
        -: 6744:   Copyright (C) 1987,88,89,90,91,92,93,94,96,97,98
        -: 6745:     Free Software Foundation, Inc.
        -: 6746:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 6747:   Bugs can be reported to bug-glibc@gnu.org.
        -: 6748:
        -: 6749:   This program is free software; you can redistribute it and/or modify it
        -: 6750:   under the terms of the GNU General Public License as published by the
        -: 6751:   Free Software Foundation; either version 2, or (at your option) any
        -: 6752:   later version.
        -: 6753:
        -: 6754:   This program is distributed in the hope that it will be useful,
        -: 6755:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6756:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6757:   GNU General Public License for more details.
        -: 6758:
        -: 6759:   You should have received a copy of the GNU General Public License
        -: 6760:   along with this program; if not, write to the Free Software Foundation,
        -: 6761:   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
        -: 6762:
        -: 6763:#ifdef HAVE_CONFIG_H
        -: 6764:#if flag_config==0
        -: 6765:#include <config.h>
        -: 6766:#define flag_config 1
        -: 6767:#endif
        -: 6768:#else
        -: 6769:#if !defined __STDC__ || !__STDC__
        -: 6770:/* This is a separate conditional since some stdc systems
        -: 6771:   reject `defined (const)'.  */
        -: 6772:#ifndef const
        -: 6773:#define const
        -: 6774:#endif
        -: 6775:#endif
        -: 6776:#endif
        -: 6777:
        -: 6778:/*#include "getopt.h"*/
        -: 6779:
        -: 6780:/*#include <stdio.h>*/
        -: 6781:
        -: 6782:/* Comment out all this code if we are using the GNU C Library, and are not
        -: 6783:   actually compiling the library itself.  This code is part of the GNU C
        -: 6784:   Library, but also included in many other GNU distributions.  Compiling
        -: 6785:   and linking in this code is a waste when using the GNU C library
        -: 6786:   (especially if it is a shared library).  Rather than having every GNU
        -: 6787:   program understand `configure --with-gnu-libc' and omit the object files,
        -: 6788:   it is simpler to just do this in the source for each such file.  */
        -: 6789:
        -: 6790:#define GETOPT_INTERFACE_VERSION 2
        -: 6791:#if !defined _LIBC && defined __GLIBC__ && __GLIBC__ >= 2
        -: 6792:#if flag_gnuversions==0
        -: 6793:#include <gnu-versions.h>
        -: 6794:#define flag_gnuversions 1
        -: 6795:#endif
        -: 6796:#if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION
        -: 6797:#define ELIDE_CODE
        -: 6798:#endif
        -: 6799:#endif
        -: 6800:
        -: 6801:#ifndef ELIDE_CODE
        -: 6802:
        -: 6803:
        -: 6804:/* This needs to come after some library #include
        -: 6805:   to get __GNU_LIBRARY__ defined.  */
        -: 6806:#ifdef __GNU_LIBRARY__
        -: 6807:#if flag_stdlib==0
        -: 6808:#include <stdlib.h>
        -: 6809:#define flag_stdlib 1
        -: 6810:#endif
        -: 6811:#endif
        -: 6812:
        -: 6813:#ifndef	NULL
        -: 6814:#define NULL 0
        -: 6815:#endif
        -: 6816:
        -: 6817:int
        -: 6818:getopt_long (argc, argv, options, long_options, opt_index)
        -: 6819:     int argc;
        -: 6820:     char *const *argv;
        -: 6821:     const char *options;
        -: 6822:     const struct option *long_options;
        -: 6823:     int *opt_index;
        -: 6824:{
        -: 6825:  return _getopt_internal (argc, argv, options, long_options, opt_index, 0);
        -: 6826:}
        -: 6827:
        -: 6828:/* Like getopt_long, but '-' as well as '--' can indicate a long option.
        -: 6829:   If an option that starts with '-' (not '--') doesn't match a long option,
        -: 6830:   but does match a short option, it is parsed as a short option
        -: 6831:   instead.  */
        -: 6832:
        -: 6833:int
        -: 6834:getopt_long_only (argc, argv, options, long_options, opt_index)
        -: 6835:     int argc;
        -: 6836:     char *const *argv;
        -: 6837:     const char *options;
        -: 6838:     const struct option *long_options;
        -: 6839:     int *opt_index;
        -: 6840:{
        -: 6841:  return _getopt_internal (argc, argv, options, long_options, opt_index, 1);
        -: 6842:}
        -: 6843:
        -: 6844:
        -: 6845:#endif	/* Not ELIDE_CODE.  */
        -: 6846:
        -: 6847:#ifdef TEST
        -: 6848:
        -: 6849:/*#include <stdio.h>*/
        -: 6850:
        -: 6851:int
        -: 6852:main (argc, argv)
        -: 6853:     int argc;
        -: 6854:     char **argv;
        -: 6855:{
        -: 6856:  int c;
        -: 6857:  int digit_optind = 0;
        -: 6858:
        -: 6859:  while (1)
        -: 6860:    {
        -: 6861:      int this_option_optind = optind ? optind : 1;
        -: 6862:      int option_index = 0;
        -: 6863:      static struct option long_options[] =
        -: 6864:      {
        -: 6865:	{"add", 1, 0, 0},
        -: 6866:	{"append", 0, 0, 0},
        -: 6867:	{"delete", 1, 0, 0},
        -: 6868:	{"verbose", 0, 0, 0},
        -: 6869:	{"create", 0, 0, 0},
        -: 6870:	{"file", 1, 0, 0},
        -: 6871:	{0, 0, 0, 0}
        -: 6872:      };
        -: 6873:
        -: 6874:      c = getopt_long (argc, argv, "abc:d:0123456789",
        -: 6875:		       long_options, &option_index);
        -: 6876:      if (c == -1)
        -: 6877:	break;
        -: 6878:
        -: 6879:      switch (c)
        -: 6880:	{
        -: 6881:	case 0:
        -: 6882:	  printf ("option %s", long_options[option_index].name);
        -: 6883:	  if (optarg)
        -: 6884:	    printf (" with arg %s", optarg);
        -: 6885:	  printf ("\n");
        -: 6886:	  break;
        -: 6887:
        -: 6888:	case '0':
        -: 6889:	case '1':
        -: 6890:	case '2':
        -: 6891:	case '3':
        -: 6892:	case '4':
        -: 6893:	case '5':
        -: 6894:	case '6':
        -: 6895:	case '7':
        -: 6896:	case '8':
        -: 6897:	case '9':
        -: 6898:	  if (digit_optind != 0 && digit_optind != this_option_optind)
        -: 6899:	    printf ("digits occur in two different argv-elements.\n");
        -: 6900:	  digit_optind = this_option_optind;
        -: 6901:	  printf ("option %c\n", c);
        -: 6902:	  break;
        -: 6903:
        -: 6904:	case 'a':
        -: 6905:	  printf ("option a\n");
        -: 6906:	  break;
        -: 6907:
        -: 6908:	case 'b':
        -: 6909:	  printf ("option b\n");
        -: 6910:	  break;
        -: 6911:
        -: 6912:	case 'c':
        -: 6913:	  printf ("option c with value `%s'\n", optarg);
        -: 6914:	  break;
        -: 6915:
        -: 6916:	case 'd':
        -: 6917:	  printf ("option d with value `%s'\n", optarg);
        -: 6918:	  break;
        -: 6919:
        -: 6920:	case '?':
        -: 6921:	  break;
        -: 6922:
        -: 6923:	default:
        -: 6924:	  printf ("?? getopt returned character code 0%o ??\n", c);
        -: 6925:	}
        -: 6926:    }
        -: 6927:
        -: 6928:  if (optind < argc)
        -: 6929:    {
        -: 6930:      printf ("non-option ARGV-elements: ");
        -: 6931:      while (optind < argc)
        -: 6932:	printf ("%s ", argv[optind++]);
        -: 6933:      printf ("\n");
        -: 6934:    }
        -: 6935:
        -: 6936:  exit (0);
        -: 6937:}
        -: 6938:
        -: 6939:#endif /* TEST */
        -: 6940:/* search.c - searching subroutines using dfa, kwset and regex for grep.
        -: 6941:   Copyright 1992, 1998, 2000 Free Software Foundation, Inc.
        -: 6942:
        -: 6943:   This program is free software; you can redistribute it and/or modify
        -: 6944:   it under the terms of the GNU General Public License as published by
        -: 6945:   the Free Software Foundation; either version 2, or (at your option)
        -: 6946:   any later version.
        -: 6947:
        -: 6948:   This program is distributed in the hope that it will be useful,
        -: 6949:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 6950:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 6951:   GNU General Public License for more details.
        -: 6952:
        -: 6953:   You should have received a copy of the GNU General Public License
        -: 6954:   along with this program; if not, write to the Free Software
        -: 6955:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
        -: 6956:   02111-1307, USA.  */
        -: 6957:
        -: 6958:/* Written August 1992 by Mike Haertel. */
        -: 6959:
        -: 6960:#ifdef HAVE_CONFIG_H
        -: 6961:#if flag_config==0
        -: 6962:# include <config.h>
        -: 6963:#define flag_config 1
        -: 6964:#endif
        -: 6965:#endif
        -: 6966:/*#include <sys/types.h>*/
        -: 6967:/*#include "system.h"*/
        -: 6968:/*#include "grep.h"*/
        -: 6969:/*#include "regex.h"*/
        -: 6970:/*#include "dfa.h"*/
        -: 6971:/*#include "kwset.h"*/
        -: 6972:
        -: 6973:#define NCHAR (UCHAR_MAX + 1)
        -: 6974:
        -: 6975:static void Gcompile PARAMS((char *, size_t));
        -: 6976:static void Ecompile PARAMS((char *, size_t));
        -: 6977:static char *EGexecute PARAMS((char *, size_t, char **));
        -: 6978:static void Fcompile PARAMS((char *, size_t));
        -: 6979:static char *Fexecute PARAMS((char *, size_t, char **));
        -: 6980:static void kwsinit PARAMS((void));
        -: 6981:
        -: 6982:/* Here is the matchers vector for the main program. */
        -: 6983:struct matcher matchers[] = {
        -: 6984:  { "default", Gcompile, EGexecute },
        -: 6985:  { "grep", Gcompile, EGexecute },
        -: 6986:  { "egrep", Ecompile, EGexecute },
        -: 6987:  { "awk", Ecompile, EGexecute },
        -: 6988:  { "fgrep", Fcompile, Fexecute },
        -: 6989:  { 0, 0, 0 },
        -: 6990:};
        -: 6991:
        -: 6992:/* For -w, we also consider _ to be word constituent.  */
        -: 6993:#define WCHAR(C) (ISALNUM(C) || (C) == '_')
        -: 6994:
        -: 6995:/* DFA compiled regexp. */
        -: 6996:static struct dfa dfa_1;
        -: 6997:
        -: 6998:/* Regex compiled regexp. */
        -: 6999:static struct re_pattern_buffer regexbuf;
        -: 7000:
        -: 7001:/* KWset compiled pattern.  For Ecompile and Gcompile, we compile
        -: 7002:   a list of strings, at least one of which is known to occur in
        -: 7003:   any string matching the regexp. */
        -: 7004:static kwset_t kwset;
        -: 7005:
        -: 7006:/* Last compiled fixed string known to exactly match the regexp.
        -: 7007:   If kwsexec() returns < lastexact, then we don't need to
        -: 7008:   call the regexp matcher at all. */
        -: 7009:static int lastexact;
        -: 7010:
        -: 7011:void
function dfaerror called 0 returned 0% blocks executed 0%
    #####: 7012:dfaerror (char const *mesg)
        -: 7013:{
    #####: 7014:  fatal(mesg, 0);
        -: 7015:}
        -: 7016:
        -: 7017:static void
function kwsinit called 598 returned 100% blocks executed 93%
      598: 7018:kwsinit (void)
        -: 7019:{
        -: 7020:  static char trans[NCHAR];
        -: 7021:  int i;
        -: 7022:
      598: 7023:  if (match_icase)
branch  0 taken 56 (fallthrough)
branch  1 taken 542
    14392: 7024:    for (i = 0; i < NCHAR; ++i)
branch  0 taken 14336
branch  1 taken 56 (fallthrough)
    14336: 7025:      trans[i] = TOLOWER(i);
branch  0 taken 1456 (fallthrough)
branch  1 taken 12880
        -: 7026:
      598: 7027:  if (!(kwset = kwsalloc(match_icase ? trans : (char *) 0)))
branch  0 taken 56 (fallthrough)
branch  1 taken 542
call    2 returned 598
branch  3 taken 0 (fallthrough)
branch  4 taken 598
    #####: 7028:    fatal("memory exhausted", 0);
call    0 never executed
      598: 7029:}
        -: 7030:
        -: 7031:/* If the DFA turns out to have some set of fixed strings one of
        -: 7032:   which must occur in the match, then we build a kwset matcher
        -: 7033:   to find those strings, and thus quickly filter out impossible
        -: 7034:   matches. */
        -: 7035:static void
function kwsmusts called 722 returned 100% blocks executed 86%
      722: 7036:kwsmusts (void)
        -: 7037:{
        -: 7038:  struct dfamust *dm;
        -: 7039:  char *err;
        -: 7040:
      722: 7041:  if (dfa_1.musts)
branch  0 taken 593 (fallthrough)
branch  1 taken 129
        -: 7042:    {
      593: 7043:      kwsinit();
call    0 returned 593
        -: 7044:      /* First, we compile in the substrings known to be exact
        -: 7045:	 matches.  The kwset matcher will return the index
        -: 7046:	 of the matching string that it chooses. */
     1186: 7047:      for (dm = dfa_1.musts; dm; dm = dm->next)
branch  0 taken 593
branch  1 taken 593 (fallthrough)
        -: 7048:	{
      593: 7049:	  if (!dm->exact)
branch  0 taken 385 (fallthrough)
branch  1 taken 208
      385: 7050:	    continue;
      208: 7051:	  ++lastexact;
      208: 7052:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
call    0 returned 208
branch  1 taken 0 (fallthrough)
branch  2 taken 208
    #####: 7053:	    fatal(err, 0);
call    0 never executed
        -: 7054:	}
        -: 7055:      /* Now, we compile the substrings that will require
        -: 7056:	 the use of the regexp matcher.  */
     1186: 7057:      for (dm = dfa_1.musts; dm; dm = dm->next)
branch  0 taken 593
branch  1 taken 593 (fallthrough)
        -: 7058:	{
      593: 7059:	  if (dm->exact)
branch  0 taken 208 (fallthrough)
branch  1 taken 385
      208: 7060:	    continue;
      385: 7061:	  if ((err = kwsincr(kwset, dm->must, strlen(dm->must))) != 0)
call    0 returned 385
branch  1 taken 0 (fallthrough)
branch  2 taken 385
    #####: 7062:	    fatal(err, 0);
call    0 never executed
        -: 7063:	}
      593: 7064:      if ((err = kwsprep(kwset)) != 0)
call    0 returned 593
branch  1 taken 0 (fallthrough)
branch  2 taken 593
    #####: 7065:	fatal(err, 0);
call    0 never executed
        -: 7066:    }
      722: 7067:}
        -: 7068:
        -: 7069:static void
function Gcompile called 535 returned 89% blocks executed 100%
      535: 7070:Gcompile (char *pattern, size_t size)
        -: 7071:{
        -: 7072:  const char *err;
        -: 7073:
      535: 7074:  re_set_syntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE);
call    0 returned 535
      535: 7075:  dfasyntax(RE_SYNTAX_GREP | RE_HAT_LISTS_NOT_NEWLINE, match_icase, eolbyte);
call    0 returned 535
        -: 7076:
      535: 7077:  if ((err = re_compile_pattern(pattern, size, &regexbuf)) != 0)
call    0 returned 535
branch  1 taken 59 (fallthrough)
branch  2 taken 476
       59: 7078:    fatal(err, 0);
call    0 returned 0
        -: 7079:
        -: 7080:  /* In the match_words and match_lines cases, we use a different pattern
        -: 7081:     for the DFA matcher that will quickly throw out cases that won't work.
        -: 7082:     Then if DFA succeeds we do some hairy stuff using the regex matcher
        -: 7083:     to decide whether the match should really count. */
      476: 7084:  if (match_words || match_lines)
branch  0 taken 475 (fallthrough)
branch  1 taken 1
branch  2 taken 1 (fallthrough)
branch  3 taken 474
        2: 7085:    {
        -: 7086:      /* In the whole-word case, we use the pattern:
        -: 7087:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
        -: 7088:	 In the whole-line case, we use the pattern:
        -: 7089:	 ^(userpattern)$.
        -: 7090:	 BUG: Using [A-Za-z_] is locale-dependent!
        -: 7091:	 So will use [:alnum:] */
        -: 7092:
        2: 7093:      char *n = malloc(size + 50);
call    0 returned 2
        2: 7094:      int i = 0;
        -: 7095:
        2: 7096:      strcpy(n, "");
        -: 7097:
        2: 7098:      if (match_lines)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 7099:	strcpy(n, "^\\(");
        2: 7100:      if (match_words)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 7101:	strcpy(n, "\\(^\\|[^[:alnum:]_]\\)\\(");
        -: 7102:
        2: 7103:      i = strlen(n);
        2: 7104:      memcpy(n + i, pattern, size);
        2: 7105:      i += size;
        -: 7106:
        2: 7107:      if (match_words)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 7108:	strcpy(n + i, "\\)\\([^[:alnum:]_]\\|$\\)");
        2: 7109:      if (match_lines)
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1: 7110:	strcpy(n + i, "\\)$");
        -: 7111:
        2: 7112:      i += strlen(n + i);
        2: 7113:      dfacomp(n, i, &dfa_1, 1);
call    0 returned 2
        -: 7114:    }
        -: 7115:  else
      474: 7116:    dfacomp(pattern, size, &dfa_1, 1);
call    0 returned 474
        -: 7117:
      476: 7118:  kwsmusts();
call    0 returned 476
      476: 7119:}
        -: 7120:
        -: 7121:static void
function Ecompile called 246 returned 100% blocks executed 42%
      246: 7122:Ecompile (char *pattern, size_t size)
        -: 7123:{
        -: 7124:  const char *err;
        -: 7125:
      246: 7126:  if (strcmp(matcher, "awk") == 0)
branch  0 taken 0 (fallthrough)
branch  1 taken 246
        -: 7127:    {
    #####: 7128:      re_set_syntax(RE_SYNTAX_AWK);
call    0 never executed
    #####: 7129:      dfasyntax(RE_SYNTAX_AWK, match_icase, eolbyte);
call    0 never executed
        -: 7130:    }
        -: 7131:  else
        -: 7132:    {
      246: 7133:      re_set_syntax (RE_SYNTAX_POSIX_EGREP);
call    0 returned 246
      246: 7134:      dfasyntax (RE_SYNTAX_POSIX_EGREP, match_icase, eolbyte);
call    0 returned 246
        -: 7135:    }
        -: 7136:
      246: 7137:  if ((err = re_compile_pattern(pattern, size, &regexbuf)) != 0)
call    0 returned 246
branch  1 taken 0 (fallthrough)
branch  2 taken 246
    #####: 7138:    fatal(err, 0);
call    0 never executed
        -: 7139:
        -: 7140:  /* In the match_words and match_lines cases, we use a different pattern
        -: 7141:     for the DFA matcher that will quickly throw out cases that won't work.
        -: 7142:     Then if DFA succeeds we do some hairy stuff using the regex matcher
        -: 7143:     to decide whether the match should really count. */
      246: 7144:  if (match_words || match_lines)
branch  0 taken 246 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 246
    #####: 7145:    {
        -: 7146:      /* In the whole-word case, we use the pattern:
        -: 7147:	 (^|[^A-Za-z_])(userpattern)([^A-Za-z_]|$).
        -: 7148:	 In the whole-line case, we use the pattern:
        -: 7149:	 ^(userpattern)$.
        -: 7150:	 BUG: Using [A-Za-z_] is locale-dependent!
        -: 7151:	 so will use the char class */
        -: 7152:
    #####: 7153:      char *n = malloc(size + 50);
call    0 never executed
    #####: 7154:      int i = 0;
        -: 7155:
    #####: 7156:      strcpy(n, "");
        -: 7157:
    #####: 7158:      if (match_lines)
branch  0 never executed
branch  1 never executed
    #####: 7159:	strcpy(n, "^(");
    #####: 7160:      if (match_words)
branch  0 never executed
branch  1 never executed
    #####: 7161:	strcpy(n, "(^|[^[:alnum:]_])(");
        -: 7162:
    #####: 7163:      i = strlen(n);
    #####: 7164:      memcpy(n + i, pattern, size);
    #####: 7165:      i += size;
        -: 7166:
    #####: 7167:      if (match_words)
branch  0 never executed
branch  1 never executed
    #####: 7168:	strcpy(n + i, ")([^[:alnum:]_]|$)");
    #####: 7169:      if (match_lines)
branch  0 never executed
branch  1 never executed
    #####: 7170:	strcpy(n + i, ")$");
        -: 7171:
    #####: 7172:      i += strlen(n + i);
    #####: 7173:      dfacomp(n, i, &dfa_1, 1);
call    0 never executed
        -: 7174:    }
        -: 7175:  else
      246: 7176:    dfacomp(pattern, size, &dfa_1, 1);
call    0 returned 246
        -: 7177:
      246: 7178:  kwsmusts();
call    0 returned 246
      246: 7179:}
        -: 7180:
        -: 7181:static char *
function EGexecute called 561365 returned 100% blocks executed 57%
   561365: 7182:EGexecute (char *buf, size_t size, char **endp)
        -: 7183:{
        -: 7184:  register char *buflim, *beg, *end, save;
   561365: 7185:  char eol = eolbyte;
        -: 7186:  int backref, start, len;
        -: 7187:  struct kwsmatch kwsm;
        -: 7188:  static struct re_registers regs; /* This is static on account of a BRAIN-DEAD
        -: 7189:				    Q@#%!# library interface in regex.c.  */
        -: 7190:
   561365: 7191:  buflim = buf + size;
        -: 7192:
   763520: 7193:  for (beg = end = buf; end < buflim; beg = end + 1)
branch  0 taken 762933
branch  1 taken 587 (fallthrough)
        -: 7194:    {
   762933: 7195:      if (kwset)
branch  0 taken 264151 (fallthrough)
branch  1 taken 498782
        -: 7196:	{
        -: 7197:	  /* Find a possible match using the KWset matcher. */
   264151: 7198:	  beg = kwsexec(kwset, beg, buflim - beg, &kwsm);
call    0 returned 264151
   264151: 7199:	  if (!beg)
branch  0 taken 7009 (fallthrough)
branch  1 taken 257142
     7009: 7200:	    goto failure;
        -: 7201:	  /* Narrow down to the line containing the candidate, and
        -: 7202:	     run it through DFA. */
   257142: 7203:	  end = memchr(beg, eol, buflim - beg);
   257142: 7204:	  if (!end)
branch  0 taken 0 (fallthrough)
branch  1 taken 257142
    #####: 7205:	    end = buflim;
  3595300: 7206:	  while (beg > buf && beg[-1] != eol)
branch  0 taken 3578980 (fallthrough)
branch  1 taken 16320
branch  2 taken 3338158
branch  3 taken 240822 (fallthrough)
  3338158: 7207:	    --beg;
   257142: 7208:	  save = *end;
   257142: 7209:	  if (kwsm.index < lastexact)
branch  0 taken 24283 (fallthrough)
branch  1 taken 232859
    24283: 7210:	    goto success;
   232859: 7211:	  if (!dfaexec(&dfa_1, beg, end, 0, (int *) 0, &backref))
call    0 returned 232859
branch  1 taken 202155 (fallthrough)
branch  2 taken 30704
        -: 7212:	    {
   202155: 7213:	      *end = save;
   202155: 7214:	      continue;
        -: 7215:	    }
    30704: 7216:	  *end = save;
        -: 7217:	  /* Successful, no backreferences encountered. */
    30704: 7218:	  if (!backref)
branch  0 taken 30704 (fallthrough)
branch  1 taken 0
    30704: 7219:	    goto success;
        -: 7220:	}
        -: 7221:      else
        -: 7222:	{
        -: 7223:	  /* No good fixed strings; start with DFA. */
   498782: 7224:	  save = *buflim;
   498782: 7225:	  beg = dfaexec(&dfa_1, beg, buflim, 0, (int *) 0, &backref);
call    0 returned 498782
   498782: 7226:	  *buflim = save;
   498782: 7227:	  if (!beg)
branch  0 taken 963 (fallthrough)
branch  1 taken 497819
      963: 7228:	    goto failure;
        -: 7229:	  /* Narrow down to the line we've found. */
   497819: 7230:	  end = memchr(beg, eol, buflim - beg);
   497819: 7231:	  if (!end)
branch  0 taken 0 (fallthrough)
branch  1 taken 497819
    #####: 7232:	    end = buflim;
  3186068: 7233:	  while (beg > buf && beg[-1] != eol)
branch  0 taken 2763625 (fallthrough)
branch  1 taken 422443
branch  2 taken 2688249
branch  3 taken 75376 (fallthrough)
  2688249: 7234:	    --beg;
        -: 7235:	  /* Successful, no backreferences encountered! */
   497819: 7236:	  if (!backref)
branch  0 taken 497819 (fallthrough)
branch  1 taken 0
   497819: 7237:	    goto success;
        -: 7238:	}
        -: 7239:      /* If we've made it to this point, this means DFA has seen
        -: 7240:	 a probable match, and we need to run it through Regex. */
    #####: 7241:      regexbuf.not_eol = 0;
    #####: 7242:      if ((start = re_search(&regexbuf, beg, end - beg, 0, end - beg, &regs)) >= 0)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -: 7243:	{
    #####: 7244:	  len = regs.end[0] - start;
    #####: 7245:	  if ((!match_lines && !match_words)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7246:	      || (match_lines && len == end - beg))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7247:	    goto success;
        -: 7248:	  /* If -w, check if the match aligns with word boundaries.
        -: 7249:	     We do this iteratively because:
        -: 7250:	     (a) the line may contain more than one occurence of the pattern, and
        -: 7251:	     (b) Several alternatives in the pattern might be valid at a given
        -: 7252:	     point, and we may need to consider a shorter one to find a word
        -: 7253:	     boundary. */
    #####: 7254:	  if (match_words)
branch  0 never executed
branch  1 never executed
    #####: 7255:	    while (start >= 0)
branch  0 never executed
branch  1 never executed
        -: 7256:	      {
    #####: 7257:		if ((start == 0 || !WCHAR ((unsigned char) beg[start - 1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 7258:		    && (len == end - beg
branch  0 never executed
branch  1 never executed
    #####: 7259:			|| !WCHAR ((unsigned char) beg[start + len])))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7260:		  goto success;
    #####: 7261:		if (len > 0)
branch  0 never executed
branch  1 never executed
        -: 7262:		  {
        -: 7263:		    /* Try a shorter length anchored at the same place. */
    #####: 7264:		    --len;
    #####: 7265:		    regexbuf.not_eol = 1;
    #####: 7266:		    len = re_match(&regexbuf, beg, start + len, start, &regs);
call    0 never executed
        -: 7267:		  }
    #####: 7268:		if (len <= 0)
branch  0 never executed
branch  1 never executed
        -: 7269:		  {
        -: 7270:		    /* Try looking further on. */
    #####: 7271:		    if (start == end - beg)
branch  0 never executed
branch  1 never executed
    #####: 7272:		      break;
    #####: 7273:		    ++start;
    #####: 7274:		    regexbuf.not_eol = 0;
    #####: 7275:		    start = re_search(&regexbuf, beg, end - beg,
    #####: 7276:				      start, end - beg - start, &regs);
call    0 never executed
    #####: 7277:		    len = regs.end[0] - start;
        -: 7278:		  }
        -: 7279:	      }
        -: 7280:	}
        -: 7281:    }
        -: 7282:
      587: 7283: failure:
     8559: 7284:  return 0;
        -: 7285:
   552806: 7286: success:
  552806*: 7287:  *endp = end < buflim ? end + 1 : end;
branch  0 taken 552806 (fallthrough)
branch  1 taken 0
   552806: 7288:  return beg;
        -: 7289:}
        -: 7290:
        -: 7291:static void
function Fcompile called 5 returned 100% blocks executed 81%
        5: 7292:Fcompile (char *pattern, size_t size)
        -: 7293:{
        -: 7294:  char *beg, *lim, *err;
        -: 7295:
        5: 7296:  kwsinit();
call    0 returned 5
        5: 7297:  beg = pattern;
        -: 7298:  do
        -: 7299:    {
       38: 7300:      for (lim = beg; lim < pattern + size && *lim != '\n'; ++lim)
branch  0 taken 33 (fallthrough)
branch  1 taken 5
branch  2 taken 33
branch  3 taken 0 (fallthrough)
        -: 7301:	;
        5: 7302:      if ((err = kwsincr(kwset, beg, lim - beg)) != 0)
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####: 7303:	fatal(err, 0);
call    0 never executed
        5: 7304:      if (lim < pattern + size)
branch  0 taken 0 (fallthrough)
branch  1 taken 5
    #####: 7305:	++lim;
        5: 7306:      beg = lim;
        -: 7307:    }
        5: 7308:  while (beg < pattern + size);
branch  0 taken 0
branch  1 taken 5 (fallthrough)
        -: 7309:
        5: 7310:  if ((err = kwsprep(kwset)) != 0)
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
    #####: 7311:    fatal(err, 0);
call    0 never executed
        5: 7312:}
        -: 7313:
        -: 7314:static char *
function Fexecute called 197 returned 100% blocks executed 44%
      197: 7315:Fexecute (char *buf, size_t size, char **endp)
        -: 7316:{
        -: 7317:  register char *beg, *try, *end;
        -: 7318:  register size_t len;
      197: 7319:  char eol = eolbyte;
        -: 7320:  struct kwsmatch kwsmatch;
        -: 7321:
     197*: 7322:  for (beg = buf; beg <= buf + size; ++beg)
branch  0 taken 197
branch  1 taken 0 (fallthrough)
        -: 7323:    {
      197: 7324:      if (!(beg = kwsexec(kwset, beg, buf + size - beg, &kwsmatch)))
call    0 returned 197
branch  1 taken 61 (fallthrough)
branch  2 taken 136
       61: 7325:	return 0;
      136: 7326:      len = kwsmatch.size[0];
      136: 7327:      if (match_lines)
branch  0 taken 0 (fallthrough)
branch  1 taken 136
        -: 7328:	{
    #####: 7329:	  if (beg > buf && beg[-1] != eol)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7330:	    continue;
    #####: 7331:	  if (beg + len < buf + size && beg[len] != eol)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 7332:	    continue;
    #####: 7333:	  goto success;
        -: 7334:	}
      136: 7335:      else if (match_words)
branch  0 taken 0 (fallthrough)
branch  1 taken 136
    #####: 7336:	for (try = beg; len && try;)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -: 7337:	  {
    #####: 7338:	    if (try > buf && WCHAR((unsigned char) try[-1]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7339:	      break;
    #####: 7340:	    if (try + len < buf + size && WCHAR((unsigned char) try[len]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -: 7341:	      {
    #####: 7342:		try = kwsexec(kwset, beg, --len, &kwsmatch);
call    0 never executed
    #####: 7343:		len = kwsmatch.size[0];
        -: 7344:	      }
        -: 7345:	    else
    #####: 7346:	      goto success;
        -: 7347:	  }
        -: 7348:      else
      136: 7349:	goto success;
        -: 7350:    }
        -: 7351:
    #####: 7352:  return 0;
        -: 7353:
      136: 7354: success:
      136: 7355:  if ((end = memchr(beg + len, eol, (buf + size) - (beg + len))) != 0)
branch  0 taken 136 (fallthrough)
branch  1 taken 0
      136: 7356:    ++end;
        -: 7357:  else
    #####: 7358:    end = buf + size;
      136: 7359:  *endp = end;
     3274: 7360:  while (beg > buf && beg[-1] != '\n')
branch  0 taken 3253 (fallthrough)
branch  1 taken 21
branch  2 taken 3138
branch  3 taken 115 (fallthrough)
     3138: 7361:    --beg;
      136: 7362:  return beg;
        -: 7363:}
        -: 7364:#ifdef HAVE_CONFIG_H
        -: 7365:#if flag_config==0
        -: 7366:# include <config.h>
        -: 7367:#define flag_config 1
        -: 7368:#endif
        -: 7369:#endif
        -: 7370:/*#include "system.h"*/
        -: 7371:/*#include "grep.h"*/
        -: 7372:char const *matcher;
        -: 7373:/* stpcpy.c -- copy a string and return pointer to end of new string
        -: 7374:   Copyright (C) 1992, 1995, 1997, 1998 Free Software Foundation, Inc.
        -: 7375:
        -: 7376:   NOTE: The canonical source of this file is maintained with the GNU C Library.
        -: 7377:   Bugs can be reported to bug-glibc@prep.ai.mit.edu.
        -: 7378:
        -: 7379:   This program is free software; you can redistribute it and/or modify it
        -: 7380:   under the terms of the GNU General Public License as published by the
        -: 7381:   Free Software Foundation; either version 2, or (at your option) any
        -: 7382:   later version.
        -: 7383:
        -: 7384:   This program is distributed in the hope that it will be useful,
        -: 7385:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7386:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -: 7387:   GNU General Public License for more details.
        -: 7388:
        -: 7389:   You should have received a copy of the GNU General Public License
        -: 7390:   along with this program; if not, write to the Free Software
        -: 7391:   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
        -: 7392:   USA.  */
        -: 7393:
        -: 7394:#ifdef HAVE_CONFIG_H
        -: 7395:#if flag_config==0
        -: 7396:# include <config.h>
        -: 7397:#define flag_config 1
        -: 7398:#endif
        -: 7399:#endif
        -: 7400:
        -: 7401:#if flag_string==0
        -: 7402:#include <string.h>
        -: 7403:#define flag_string 1
        -: 7404:#endif
        -: 7405:
        -: 7406:#undef __stpcpy
        -: 7407:#undef stpcpy
        -: 7408:
        -: 7409:#ifndef weak_alias
        -: 7410:# define __stpcpy stpcpy
        -: 7411:#endif
        -: 7412:
        -: 7413:/* Copy SRC to DEST, returning the address of the terminating '\0' in DEST.  */
        -: 7414:char *
        -: 7415:__stpcpy (char *dest, const char *src)
        -: 7416:{
    #####: 7417:  register char *d = dest;
    #####: 7418:  register const char *s = src;
        -: 7419:
        -: 7420:  do
    #####: 7421:    *d++ = *s;
    #####: 7422:  while (*s++ != '\0');
branch  0 never executed
branch  1 never executed
        -: 7423:
    #####: 7424:  return d - 1;
        -: 7425:}
        -: 7426:#ifdef weak_alias
        -: 7427:weak_alias (__stpcpy, stpcpy)
        -: 7428:#endif
        -: 7429:/* Extended regular expression matching and search library,
        -: 7430:   version 0.12.
        -: 7431:   (Implements POSIX draft P1003.2/D11.2, except for some of the
        -: 7432:   internationalization features.)
        -: 7433:   Copyright (C) 1993, 94, 95, 96, 97, 98, 99 Free Software Foundation, Inc.
        -: 7434:
        -: 7435:   The GNU C Library is free software; you can redistribute it and/or
        -: 7436:   modify it under the terms of the GNU Library General Public License as
        -: 7437:   published by the Free Software Foundation; either version 2 of the
        -: 7438:   License, or (at your option) any later version.
        -: 7439:
        -: 7440:   The GNU C Library is distributed in the hope that it will be useful,
        -: 7441:   but WITHOUT ANY WARRANTY; without even the implied warranty of
        -: 7442:   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
        -: 7443:   Library General Public License for more details.
        -: 7444:
        -: 7445:   You should have received a copy of the GNU Library General Public
        -: 7446:   License along with the GNU C Library; see the file COPYING.LIB.  If not,
        -: 7447:   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
        -: 7448:   Boston, MA 02111-1307, USA.  */
        -: 7449:
        -: 7450:/* AIX requires this to be the first thing in the file. */
        -: 7451:#if defined _AIX && !defined REGEX_MALLOC
        -: 7452:  #pragma alloca
        -: 7453:#endif
        -: 7454:
        -: 7455:#undef	_GNU_SOURCE
        -: 7456:#define _GNU_SOURCE
        -: 7457:
        -: 7458:#ifdef HAVE_CONFIG_H
        -: 7459:#if flag_config==0
        -: 7460:# include <config.h>
        -: 7461:#define flag_config 1
        -: 7462:#endif
        -: 7463:#endif
        -: 7464:
        -: 7465:#ifndef PARAMS
        -: 7466:# if defined __GNUC__ || (defined __STDC__ && __STDC__)
        -: 7467:#  define PARAMS(args) args
        -: 7468:# else
        -: 7469:#  define PARAMS(args) ()
        -: 7470:# endif  /* GCC.  */
        -: 7471:#endif  /* Not PARAMS.  */
        -: 7472:
        -: 7473:#if defined STDC_HEADERS && !defined emacs
        -: 7474:# include <stddef.h>
        -: 7475:#else
        -: 7476:/* We need this for `regex.h', and perhaps for the Emacs include files.  */
        -: 7477:#if flag_systypes==0
        -: 7478:# include <sys/types.h>
        -: 7479:#define flag_systypes 1
        -: 7480:#endif
        -: 7481:#endif
        -: 7482:
        -: 7483:#define WIDE_CHAR_SUPPORT (HAVE_WCTYPE_H && HAVE_WCHAR_H && HAVE_BTOWC)
        -: 7484:
        -: 7485:/* For platform which support the ISO C amendement 1 functionality we
        -: 7486:   support user defined character classes.  */
        -: 7487:#if defined _LIBC || WIDE_CHAR_SUPPORT
        -: 7488:/* Solaris 2.5 has a bug: <wchar.h> must be included before <wctype.h>.  */
        -: 7489:# include <wchar.h>
        -: 7490:# include <wctype.h>
        -: 7491:#endif
        -: 7492:
        -: 7493:#ifdef _LIBC
        -: 7494:/* We have to keep the namespace clean.  */
        -: 7495:# define regfree(preg) __regfree (preg)
        -: 7496:# define regexec(pr, st, nm, pm, ef) __regexec (pr, st, nm, pm, ef)
        -: 7497:# define regcomp(preg, pattern, cflags) __regcomp (preg, pattern, cflags)
        -: 7498:# define regerror(errcode, preg, errbuf, errbuf_size) \
        -: 7499:	__regerror(errcode, preg, errbuf, errbuf_size)
        -: 7500:# define re_set_registers(bu, re, nu, st, en) \
        -: 7501:	__re_set_registers (bu, re, nu, st, en)
        -: 7502:# define re_match_2(bufp, string1, size1, string2, size2, pos, regs, stop) \
        -: 7503:	__re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -: 7504:# define re_match(bufp, string, size, pos, regs) \
        -: 7505:	__re_match (bufp, string, size, pos, regs)
        -: 7506:# define re_search(bufp, string, size, startpos, range, regs) \
        -: 7507:	__re_search (bufp, string, size, startpos, range, regs)
        -: 7508:# define re_compile_pattern(pattern, length, bufp) \
        -: 7509:	__re_compile_pattern (pattern, length, bufp)
        -: 7510:# define re_set_syntax(syntax) __re_set_syntax (syntax)
        -: 7511:# define re_search_2(bufp, st1, s1, st2, s2, startpos, range, regs, stop) \
        -: 7512:	__re_search_2 (bufp, st1, s1, st2, s2, startpos, range, regs, stop)
        -: 7513:# define re_compile_fastmap(bufp) __re_compile_fastmap (bufp)
        -: 7514:
        -: 7515:#define btowc __btowc
        -: 7516:#endif
        -: 7517:
        -: 7518:
        -: 7519:#ifndef _
        -: 7520:/* This is for other GNU distributions with internationalized messages.
        -: 7521:   When compiling libc, the _ and N_ macros are predefined.  */
        -: 7522:# ifdef HAVE_LIBINTL_H
        -: 7523:#if flag_libintl==0
        -: 7524:#  include <libintl.h>
        -: 7525:#define flag_libintl 1
        -: 7526:#endif
        -: 7527:# else
        -: 7528:#  define gettext(msgid) (msgid)
        -: 7529:# endif
        -: 7530:# define N_(msgid) (msgid)
        -: 7531:#endif
        -: 7532:
        -: 7533:/* The `emacs' switch turns on certain matching commands
        -: 7534:   that make sense only in Emacs. */
        -: 7535:#ifdef emacs
        -: 7536:
        -: 7537:# include "lisp.h"
        -: 7538:# include "buffer.h"
        -: 7539:# include "syntax.h"
        -: 7540:
        -: 7541:#else  /* not emacs */
        -: 7542:
        -: 7543:/* If we are not linking with Emacs proper,
        -: 7544:   we can't use the relocating allocator
        -: 7545:   even if config.h says that we can.  */
        -: 7546:# undef REL_ALLOC
        -: 7547:
        -: 7548:# if defined STDC_HEADERS || defined _LIBC
        -: 7549:#if flag_stdlib==0
        -: 7550:#  include <stdlib.h>
        -: 7551:#define flag_stdlib 1
        -: 7552:#endif
        -: 7553:# else
        -: 7554:char *malloc ();
        -: 7555:char *realloc ();
        -: 7556:# endif
        -: 7557:
        -: 7558:/* When used in Emacs's lib-src, we need to get bzero and bcopy somehow.
        -: 7559:   If nothing else has been done, use the method below.  */
        -: 7560:# ifdef INHIBIT_STRING_HEADER
        -: 7561:#  if !(defined HAVE_BZERO && defined HAVE_BCOPY)
        -: 7562:#   if !defined bzero && !defined bcopy
        -: 7563:#    undef INHIBIT_STRING_HEADER
        -: 7564:#   endif
        -: 7565:#  endif
        -: 7566:# endif
        -: 7567:
        -: 7568:/* This is the normal way of making sure we have a bcopy and a bzero.
        -: 7569:   This is used in most programs--a few other programs avoid this
        -: 7570:   by defining INHIBIT_STRING_HEADER.  */
        -: 7571:# ifndef INHIBIT_STRING_HEADER
        -: 7572:#  if defined HAVE_STRING_H || defined STDC_HEADERS || defined _LIBC
        -: 7573:#if flag_string==0
        -: 7574:#   include <string.h>
        -: 7575:#define flag_string 1
        -: 7576:#endif
        -: 7577:#   ifndef bzero
        -: 7578:#    ifndef _LIBC
        -: 7579:#     define bzero(s, n)	(memset (s, '\0', n), (s))
        -: 7580:#    else
        -: 7581:#     define bzero(s, n)	__bzero (s, n)
        -: 7582:#    endif
        -: 7583:#   endif
        -: 7584:#  else
        -: 7585:#if flag_strings==0 
        -: 7586:#   include <strings.h>
        -: 7587:#define flag_strings 1
        -: 7588:#endif
        -: 7589:#   ifndef memcmp
        -: 7590:#    define memcmp(s1, s2, n)	bcmp (s1, s2, n)
        -: 7591:#   endif
        -: 7592:#   ifndef memcpy
        -: 7593:#    define memcpy(d, s, n)	(bcopy (s, d, n), (d))
        -: 7594:#   endif
        -: 7595:#  endif
        -: 7596:# endif
        -: 7597:
        -: 7598:/* Define the syntax stuff for \<, \>, etc.  */
        -: 7599:
        -: 7600:/* This must be nonzero for the wordchar and notwordchar pattern
        -: 7601:   commands in re_match_2.  */
        -: 7602:# ifndef Sword
        -: 7603:#  define Sword 1
        -: 7604:# endif
        -: 7605:
        -: 7606:# ifdef SWITCH_ENUM_BUG
        -: 7607:#  define SWITCH_ENUM_CAST(x) ((int)(x))
        -: 7608:# else
        -: 7609:#  define SWITCH_ENUM_CAST(x) (x)
        -: 7610:# endif
        -: 7611:
        -: 7612:#endif /* not emacs */
        -: 7613:
        -: 7614:/* Get the interface, including the syntax bits.  */
        -: 7615:#include <regex.h>
        -: 7616:
        -: 7617:/* isalpha etc. are used for the character classes.  */
        -: 7618:/*#include <ctype.h>*/
        -: 7619:
        -: 7620:/* Jim Meyering writes:
        -: 7621:
        -: 7622:   "... Some ctype macros are valid only for character codes that
        -: 7623:   isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
        -: 7624:   using /bin/cc or gcc but without giving an ansi option).  So, all
        -: 7625:   ctype uses should be through macros like ISPRINT...  If
        -: 7626:   STDC_HEADERS is defined, then autoconf has verified that the ctype
        -: 7627:   macros don't need to be guarded with references to isascii. ...
        -: 7628:   Defining isascii to 1 should let any compiler worth its salt
        -: 7629:   eliminate the && through constant folding."
        -: 7630:   Solaris defines some of these symbols so we must undefine them first.  */
        -: 7631:
        -: 7632:#undef ISASCII
        -: 7633:#if defined STDC_HEADERS || (!defined isascii && !defined HAVE_ISASCII)
        -: 7634:# define ISASCII(c) 1
        -: 7635:#else
        -: 7636:# define ISASCII(c) isascii(c)
        -: 7637:#endif
        -: 7638:
        -: 7639:#ifdef isblank
        -: 7640:# define ISBLANK(c) (ISASCII (c) && isblank (c))
        -: 7641:#else
        -: 7642:# define ISBLANK(c) ((c) == ' ' || (c) == '\t')
        -: 7643:#endif
        -: 7644:
        -: 7645:#undef ISGRAPH
        -: 7646:#undef ISDIGIT
        -: 7647:#undef  ISALNUM
        -: 7648:#undef ISALPHA
        -: 7649:#undef ISCNTRL
        -: 7650:#undef ISLOWER
        -: 7651:#undef ISPUNCT
        -: 7652:#undef  ISSPACE
        -: 7653:#undef  ISUPPER
        -: 7654:#undef ISXDIGIT
        -: 7655:
        -: 7656:#ifdef isgraph
        -: 7657:# define ISGRAPH(c) (ISASCII (c) && isgraph (c))
        -: 7658:#else
        -: 7659:# define ISGRAPH(c) (ISASCII (c) && isprint (c) && !isspace (c))
        -: 7660:#endif
        -: 7661:
        -: 7662:#undef ISPRINT
        -: 7663:#define ISPRINT(c) (ISASCII (c) && isprint (c))
        -: 7664:#define ISDIGIT(c) (ISASCII (c) && isdigit (c))
        -: 7665:#define ISALNUM(c) (ISASCII (c) && isalnum (c))
        -: 7666:#define ISALPHA(c) (ISASCII (c) && isalpha (c))
        -: 7667:#define ISCNTRL(c) (ISASCII (c) && iscntrl (c))
        -: 7668:#define ISLOWER(c) (ISASCII (c) && islower (c))
        -: 7669:#define ISPUNCT(c) (ISASCII (c) && ispunct (c))
        -: 7670:#define ISSPACE(c) (ISASCII (c) && isspace (c))
        -: 7671:#define ISUPPER(c) (ISASCII (c) && isupper (c))
        -: 7672:#define ISXDIGIT(c) (ISASCII (c) && isxdigit (c))
        -: 7673:
        -: 7674:#undef TOLOWER
        -: 7675:#ifdef _tolower
        -: 7676:# define TOLOWER(c) _tolower(c)
        -: 7677:#else
        -: 7678:# define TOLOWER(c) tolower(c)
        -: 7679:#endif
        -: 7680:
        -: 7681:#ifndef NULL
        -: 7682:# define NULL (void *)0
        -: 7683:#endif
        -: 7684:
        -: 7685:/* We remove any previous definition of `SIGN_EXTEND_CHAR',
        -: 7686:   since ours (we hope) works properly with all combinations of
        -: 7687:   machines, compilers, `char' and `unsigned char' argument types.
        -: 7688:   (Per Bothner suggested the basic approach.)  */
        -: 7689:#undef SIGN_EXTEND_CHAR
        -: 7690:#if __STDC__
        -: 7691:# define SIGN_EXTEND_CHAR(c) ((signed char) (c))
        -: 7692:#else  /* not __STDC__ */
        -: 7693:/* As in Harbison and Steele.  */
        -: 7694:# define SIGN_EXTEND_CHAR(c) ((((unsigned char) (c)) ^ 128) - 128)
        -: 7695:#endif
        -: 7696:
        -: 7697:#ifndef emacs
        -: 7698:/* How many characters in the character set.  */
        -: 7699:# define CHAR_SET_SIZE 256
        -: 7700:
        -: 7701:# ifdef SYNTAX_TABLE
        -: 7702:
        -: 7703:extern char *re_syntax_table;
        -: 7704:
        -: 7705:# else /* not SYNTAX_TABLE */
        -: 7706:
        -: 7707:static char re_syntax_table[CHAR_SET_SIZE];
        -: 7708:
        -: 7709:static void
function init_syntax_once called 781 returned 100% blocks executed 89%
      781: 7710:init_syntax_once ()
        -: 7711:{
        -: 7712:   register int c;
        -: 7713:   static int done = 0;
        -: 7714:
      781: 7715:   if (done)
branch  0 taken 0 (fallthrough)
branch  1 taken 781
    #####: 7716:     return;
      781: 7717:   bzero (re_syntax_table, sizeof re_syntax_table);
        -: 7718:
   200717: 7719:   for (c = 0; c < CHAR_SET_SIZE; ++c)
branch  0 taken 199936
branch  1 taken 781 (fallthrough)
   199936: 7720:     if (ISALNUM (c))
branch  0 taken 48422 (fallthrough)
branch  1 taken 151514
    48422: 7721:	re_syntax_table[c] = Sword;
        -: 7722:
      781: 7723:   re_syntax_table['_'] = Sword;
        -: 7724:
      781: 7725:   done = 1;
        -: 7726:}
        -: 7727:
        -: 7728:# endif /* not SYNTAX_TABLE */
        -: 7729:
        -: 7730:# define SYNTAX(c) re_syntax_table[((c) & 0xFF)]
        -: 7731:
        -: 7732:#endif /* emacs */
        -: 7733:
        -: 7734:/* Should we use malloc or alloca?  If REGEX_MALLOC is not defined, we
        -: 7735:   use `alloca' instead of `malloc'.  This is because using malloc in
        -: 7736:   re_search* or re_match* could cause memory leaks when C-g is used in
        -: 7737:   Emacs; also, malloc is slower and causes storage fragmentation.  On
        -: 7738:   the other hand, malloc is more portable, and easier to debug.
        -: 7739:
        -: 7740:   Because we sometimes use alloca, some routines have to be macros,
        -: 7741:   not functions -- `alloca'-allocated space disappears at the end of the
        -: 7742:   function it is called in.  */
        -: 7743:
        -: 7744:#ifdef REGEX_MALLOC
        -: 7745:
        -: 7746:# define REGEX_ALLOCATE malloc
        -: 7747:# define REGEX_REALLOCATE(source, osize, nsize) realloc (source, nsize)
        -: 7748:# define REGEX_FREE free
        -: 7749:
        -: 7750:#else /* not REGEX_MALLOC  */
        -: 7751:
        -: 7752:/* Emacs already defines alloca, sometimes.  */
        -: 7753:# ifndef alloca
        -: 7754:
        -: 7755:/* Make alloca work the best possible way.  */
        -: 7756:#  ifdef __GNUC__
        -: 7757:#   define alloca __builtin_alloca
        -: 7758:#  else /* not __GNUC__ */
        -: 7759:#   if HAVE_ALLOCA_H
        -: 7760:#    include <alloca.h>
        -: 7761:#   endif /* HAVE_ALLOCA_H */
        -: 7762:#  endif /* not __GNUC__ */
        -: 7763:
        -: 7764:# endif /* not alloca */
        -: 7765:
        -: 7766:# define REGEX_ALLOCATE alloca
        -: 7767:
        -: 7768:/* Assumes a `char *destination' variable.  */
        -: 7769:# define REGEX_REALLOCATE(source, osize, nsize)				\
        -: 7770:  (destination = (char *) alloca (nsize),				\
        -: 7771:   memcpy (destination, source, osize))
        -: 7772:
        -: 7773:/* No need to do anything to free, after alloca.  */
        -: 7774:# define REGEX_FREE(arg) ((void)0) /* Do nothing!  But inhibit gcc warning.  */
        -: 7775:
        -: 7776:#endif /* not REGEX_MALLOC */
        -: 7777:
        -: 7778:/* Define how to allocate the failure stack.  */
        -: 7779:
        -: 7780:#if defined REL_ALLOC && defined REGEX_MALLOC
        -: 7781:
        -: 7782:# define REGEX_ALLOCATE_STACK(size)				\
        -: 7783:  r_alloc (&failure_stack_ptr, (size))
        -: 7784:# define REGEX_REALLOCATE_STACK(source, osize, nsize)		\
        -: 7785:  r_re_alloc (&failure_stack_ptr, (nsize))
        -: 7786:# define REGEX_FREE_STACK(ptr)					\
        -: 7787:  r_alloc_free (&failure_stack_ptr)
        -: 7788:
        -: 7789:#else /* not using relocating allocator */
        -: 7790:
        -: 7791:# ifdef REGEX_MALLOC
        -: 7792:
        -: 7793:#  define REGEX_ALLOCATE_STACK malloc
        -: 7794:#  define REGEX_REALLOCATE_STACK(source, osize, nsize) realloc (source, nsize)
        -: 7795:#  define REGEX_FREE_STACK free
        -: 7796:
        -: 7797:# else /* not REGEX_MALLOC */
        -: 7798:
        -: 7799:#  define REGEX_ALLOCATE_STACK alloca
        -: 7800:
        -: 7801:#  define REGEX_REALLOCATE_STACK(source, osize, nsize)			\
        -: 7802:   REGEX_REALLOCATE (source, osize, nsize)
        -: 7803:/* No need to explicitly free anything.  */
        -: 7804:#  define REGEX_FREE_STACK(arg)
        -: 7805:
        -: 7806:# endif /* not REGEX_MALLOC */
        -: 7807:#endif /* not using relocating allocator */
        -: 7808:
        -: 7809:
        -: 7810:/* True if `size1' is non-NULL and PTR is pointing anywhere inside
        -: 7811:   `string1' or just past its end.  This works if PTR is NULL, which is
        -: 7812:   a good thing.  */
        -: 7813:#define FIRST_STRING_P(ptr) 					\
        -: 7814:  (size1 && string1 <= (ptr) && (ptr) <= string1 + size1)
        -: 7815:
        -: 7816:/* (Re)Allocate N items of type T using malloc, or fail.  */
        -: 7817:#define TALLOC(n, t) ((t *) malloc ((n) * sizeof (t)))
        -: 7818:#define RETALLOC(addr, n, t) ((addr) = (t *) realloc (addr, (n) * sizeof (t)))
        -: 7819:#define RETALLOC_IF(addr, n, t) \
        -: 7820:  if (addr) RETALLOC((addr), (n), t); else (addr) = TALLOC ((n), t)
        -: 7821:#define REGEX_TALLOC(n, t) ((t *) REGEX_ALLOCATE ((n) * sizeof (t)))
        -: 7822:
        -: 7823:#define BYTEWIDTH 8 /* In bits.  */
        -: 7824:
        -: 7825:#define STREQ(s1, s2) ((strcmp (s1, s2) == 0))
        -: 7826:
        -: 7827:#undef MAX
        -: 7828:#undef MIN
        -: 7829:#define MAX(a, b) ((a) > (b) ? (a) : (b))
        -: 7830:#define MIN(a, b) ((a) < (b) ? (a) : (b))
        -: 7831:
        -: 7832:typedef char boolean;
        -: 7833:#define false 0
        -: 7834:#define true 1
        -: 7835:
        -: 7836:static int re_match_2_internal PARAMS ((struct re_pattern_buffer *bufp,
        -: 7837:					const char *string1, int size1,
        -: 7838:					const char *string2, int size2,
        -: 7839:					int pos,
        -: 7840:					struct re_registers *regs,
        -: 7841:					int stop));
        -: 7842:
        -: 7843:/* These are the command codes that appear in compiled regular
        -: 7844:   expressions.  Some opcodes are followed by argument bytes.  A
        -: 7845:   command code can specify any interpretation whatsoever for its
        -: 7846:   arguments.  Zero bytes may appear in the compiled regular expression.  */
        -: 7847:
        -: 7848:typedef enum
        -: 7849:{
        -: 7850:  no_op = 0,
        -: 7851:
        -: 7852:  /* Succeed right away--no more backtracking.  */
        -: 7853:  succeed,
        -: 7854:
        -: 7855:        /* Followed by one byte giving n, then by n literal bytes.  */
        -: 7856:  exactn,
        -: 7857:
        -: 7858:        /* Matches any (more or less) character.  */
        -: 7859:  anychar,
        -: 7860:
        -: 7861:        /* Matches any one char belonging to specified set.  First
        -: 7862:           following byte is number of bitmap bytes.  Then come bytes
        -: 7863:           for a bitmap saying which chars are in.  Bits in each byte
        -: 7864:           are ordered low-bit-first.  A character is in the set if its
        -: 7865:           bit is 1.  A character too large to have a bit in the map is
        -: 7866:           automatically not in the set.  */
        -: 7867:  charset,
        -: 7868:
        -: 7869:        /* Same parameters as charset, but match any character that is
        -: 7870:           not one of those specified.  */
        -: 7871:  charset_not,
        -: 7872:
        -: 7873:        /* Start remembering the text that is matched, for storing in a
        -: 7874:           register.  Followed by one byte with the register number, in
        -: 7875:           the range 0 to one less than the pattern buffer's re_nsub
        -: 7876:           field.  Then followed by one byte with the number of groups
        -: 7877:           inner to this one.  (This last has to be part of the
        -: 7878:           start_memory only because we need it in the on_failure_jump
        -: 7879:           of re_match_2.)  */
        -: 7880:  start_memory,
        -: 7881:
        -: 7882:        /* Stop remembering the text that is matched and store it in a
        -: 7883:           memory register.  Followed by one byte with the register
        -: 7884:           number, in the range 0 to one less than `re_nsub' in the
        -: 7885:           pattern buffer, and one byte with the number of inner groups,
        -: 7886:           just like `start_memory'.  (We need the number of inner
        -: 7887:           groups here because we don't have any easy way of finding the
        -: 7888:           corresponding start_memory when we're at a stop_memory.)  */
        -: 7889:  stop_memory,
        -: 7890:
        -: 7891:        /* Match a duplicate of something remembered. Followed by one
        -: 7892:           byte containing the register number.  */
        -: 7893:  duplicate,
        -: 7894:
        -: 7895:        /* Fail unless at beginning of line.  */
        -: 7896:  begline,
        -: 7897:
        -: 7898:        /* Fail unless at end of line.  */
        -: 7899:  endline,
        -: 7900:
        -: 7901:        /* Succeeds if at beginning of buffer (if emacs) or at beginning
        -: 7902:           of string to be matched (if not).  */
        -: 7903:  begbuf,
        -: 7904:
        -: 7905:        /* Analogously, for end of buffer/string.  */
        -: 7906:  endbuf,
        -: 7907:
        -: 7908:        /* Followed by two byte relative address to which to jump.  */
        -: 7909:  jump,
        -: 7910:
        -: 7911:	/* Same as jump, but marks the end of an alternative.  */
        -: 7912:  jump_past_alt,
        -: 7913:
        -: 7914:        /* Followed by two-byte relative address of place to resume at
        -: 7915:           in case of failure.  */
        -: 7916:  on_failure_jump,
        -: 7917:
        -: 7918:        /* Like on_failure_jump, but pushes a placeholder instead of the
        -: 7919:           current string position when executed.  */
        -: 7920:  on_failure_keep_string_jump,
        -: 7921:
        -: 7922:        /* Throw away latest failure point and then jump to following
        -: 7923:           two-byte relative address.  */
        -: 7924:  pop_failure_jump,
        -: 7925:
        -: 7926:        /* Change to pop_failure_jump if know won't have to backtrack to
        -: 7927:           match; otherwise change to jump.  This is used to jump
        -: 7928:           back to the beginning of a repeat.  If what follows this jump
        -: 7929:           clearly won't match what the repeat does, such that we can be
        -: 7930:           sure that there is no use backtracking out of repetitions
        -: 7931:           already matched, then we change it to a pop_failure_jump.
        -: 7932:           Followed by two-byte address.  */
        -: 7933:  maybe_pop_jump,
        -: 7934:
        -: 7935:        /* Jump to following two-byte address, and push a dummy failure
        -: 7936:           point. This failure point will be thrown away if an attempt
        -: 7937:           is made to use it for a failure.  A `+' construct makes this
        -: 7938:           before the first repeat.  Also used as an intermediary kind
        -: 7939:           of jump when compiling an alternative.  */
        -: 7940:  dummy_failure_jump,
        -: 7941:
        -: 7942:	/* Push a dummy failure point and continue.  Used at the end of
        -: 7943:	   alternatives.  */
        -: 7944:  push_dummy_failure,
        -: 7945:
        -: 7946:        /* Followed by two-byte relative address and two-byte number n.
        -: 7947:           After matching N times, jump to the address upon failure.  */
        -: 7948:  succeed_n,
        -: 7949:
        -: 7950:        /* Followed by two-byte relative address, and two-byte number n.
        -: 7951:           Jump to the address N times, then fail.  */
        -: 7952:  jump_n,
        -: 7953:
        -: 7954:        /* Set the following two-byte relative address to the
        -: 7955:           subsequent two-byte number.  The address *includes* the two
        -: 7956:           bytes of number.  */
        -: 7957:  set_number_at,
        -: 7958:
        -: 7959:  wordchar,	/* Matches any word-constituent character.  */
        -: 7960:  notwordchar,	/* Matches any char that is not a word-constituent.  */
        -: 7961:
        -: 7962:  wordbeg,	/* Succeeds if at word beginning.  */
        -: 7963:  wordend,	/* Succeeds if at word end.  */
        -: 7964:
        -: 7965:  wordbound,	/* Succeeds if at a word boundary.  */
        -: 7966:  notwordbound	/* Succeeds if not at a word boundary.  */
        -: 7967:
        -: 7968:#ifdef emacs
        -: 7969:  ,before_dot,	/* Succeeds if before point.  */
        -: 7970:  at_dot,	/* Succeeds if at point.  */
        -: 7971:  after_dot,	/* Succeeds if after point.  */
        -: 7972:
        -: 7973:	/* Matches any character whose syntax is specified.  Followed by
        -: 7974:           a byte which contains a syntax code, e.g., Sword.  */
        -: 7975:  syntaxspec,
        -: 7976:
        -: 7977:	/* Matches any character whose syntax is not that specified.  */
        -: 7978:  notsyntaxspec
        -: 7979:#endif /* emacs */
        -: 7980:} re_opcode_t;
        -: 7981:
        -: 7982:/* Common operations on the compiled pattern.  */
        -: 7983:
        -: 7984:/* Store NUMBER in two contiguous bytes starting at DESTINATION.  */
        -: 7985:
        -: 7986:#define STORE_NUMBER(destination, number)				\
        -: 7987:  do {									\
        -: 7988:    (destination)[0] = (number) & 0377;					\
        -: 7989:    (destination)[1] = (number) >> 8;					\
        -: 7990:  } while (0)
        -: 7991:
        -: 7992:/* Same as STORE_NUMBER, except increment DESTINATION to
        -: 7993:   the byte after where the number is stored.  Therefore, DESTINATION
        -: 7994:   must be an lvalue.  */
        -: 7995:
        -: 7996:#define STORE_NUMBER_AND_INCR(destination, number)			\
        -: 7997:  do {									\
        -: 7998:    STORE_NUMBER (destination, number);					\
        -: 7999:    (destination) += 2;							\
        -: 8000:  } while (0)
        -: 8001:
        -: 8002:/* Put into DESTINATION a number stored in two contiguous bytes starting
        -: 8003:   at SOURCE.  */
        -: 8004:
        -: 8005:#define EXTRACT_NUMBER(destination, source)				\
        -: 8006:  do {									\
        -: 8007:    (destination) = *(source) & 0377;					\
        -: 8008:    (destination) += SIGN_EXTEND_CHAR (*((source) + 1)) << 8;		\
        -: 8009:  } while (0)
        -: 8010:
        -: 8011:#ifdef DEBUG
        -: 8012:static void extract_number _RE_ARGS ((int *dest, unsigned char *source));
        -: 8013:static void
        -: 8014:extract_number (dest, source)
        -: 8015:    int *dest;
        -: 8016:    unsigned char *source;
        -: 8017:{
        -: 8018:  int temp = SIGN_EXTEND_CHAR (*(source + 1));
        -: 8019:  *dest = *source & 0377;
        -: 8020:  *dest += temp << 8;
        -: 8021:}
        -: 8022:
        -: 8023:# ifndef EXTRACT_MACROS /* To debug the macros.  */
        -: 8024:#  undef EXTRACT_NUMBER
        -: 8025:#  define EXTRACT_NUMBER(dest, src) extract_number (&dest, src)
        -: 8026:# endif /* not EXTRACT_MACROS */
        -: 8027:
        -: 8028:#endif /* DEBUG */
        -: 8029:
        -: 8030:/* Same as EXTRACT_NUMBER, except increment SOURCE to after the number.
        -: 8031:   SOURCE must be an lvalue.  */
        -: 8032:
        -: 8033:#define EXTRACT_NUMBER_AND_INCR(destination, source)			\
        -: 8034:  do {									\
        -: 8035:    EXTRACT_NUMBER (destination, source);				\
        -: 8036:    (source) += 2; 							\
        -: 8037:  } while (0)
        -: 8038:
        -: 8039:#ifdef DEBUG
        -: 8040:static void extract_number_and_incr _RE_ARGS ((int *destination,
        -: 8041:					       unsigned char **source));
        -: 8042:static void
        -: 8043:extract_number_and_incr (destination, source)
        -: 8044:    int *destination;
        -: 8045:    unsigned char **source;
        -: 8046:{
        -: 8047:  extract_number (destination, *source);
        -: 8048:  *source += 2;
        -: 8049:}
        -: 8050:
        -: 8051:# ifndef EXTRACT_MACROS
        -: 8052:#  undef EXTRACT_NUMBER_AND_INCR
        -: 8053:#  define EXTRACT_NUMBER_AND_INCR(dest, src) \
        -: 8054:  extract_number_and_incr (&dest, &src)
        -: 8055:# endif /* not EXTRACT_MACROS */
        -: 8056:
        -: 8057:#endif /* DEBUG */
        -: 8058:
        -: 8059:/* If DEBUG is defined, Regex prints many voluminous messages about what
        -: 8060:   it is doing (if the variable `debug' is nonzero).  If linked with the
        -: 8061:   main program in `iregex.c', you can enter patterns and strings
        -: 8062:   interactively.  And if linked with the main program in `main.c' and
        -: 8063:   the other test files, you can run the already-written tests.  */
        -: 8064:
        -: 8065:#ifdef DEBUG
        -: 8066:
        -: 8067:/* We use standard I/O for debugging.  */
        -: 8068:/*# include <stdio.h>*/
        -: 8069:
        -: 8070:/* It is useful to test things that ``must'' be true when debugging.  */
        -: 8071:/*# include <assert.h>*/
        -: 8072:
        -: 8073:static int debug;
        -: 8074:
        -: 8075:# define DEBUG_STATEMENT(e) e
        -: 8076:# define DEBUG_PRINT1(x) if (debug) printf (x)
        -: 8077:# define DEBUG_PRINT2(x1, x2) if (debug) printf (x1, x2)
        -: 8078:# define DEBUG_PRINT3(x1, x2, x3) if (debug) printf (x1, x2, x3)
        -: 8079:# define DEBUG_PRINT4(x1, x2, x3, x4) if (debug) printf (x1, x2, x3, x4)
        -: 8080:# define DEBUG_PRINT_COMPILED_PATTERN(p, s, e) 				\
        -: 8081:  if (debug) print_partial_compiled_pattern (s, e)
        -: 8082:# define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)			\
        -: 8083:  if (debug) print_double_string (w, s1, sz1, s2, sz2)
        -: 8084:
        -: 8085:
        -: 8086:/* Print the fastmap in human-readable form.  */
        -: 8087:
        -: 8088:void
        -: 8089:print_fastmap (fastmap)
        -: 8090:    char *fastmap;
        -: 8091:{
        -: 8092:  unsigned was_a_range = 0;
        -: 8093:  unsigned i = 0;
        -: 8094:
        -: 8095:  while (i < (1 << BYTEWIDTH))
        -: 8096:    {
        -: 8097:      if (fastmap[i++])
        -: 8098:	{
        -: 8099:	  was_a_range = 0;
        -: 8100:          putchar (i - 1);
        -: 8101:          while (i < (1 << BYTEWIDTH)  &&  fastmap[i])
        -: 8102:            {
        -: 8103:              was_a_range = 1;
        -: 8104:              i++;
        -: 8105:            }
        -: 8106:	  if (was_a_range)
        -: 8107:            {
        -: 8108:              printf ("-");
        -: 8109:              putchar (i - 1);
        -: 8110:            }
        -: 8111:        }
        -: 8112:    }
        -: 8113:  putchar ('\n');
        -: 8114:}
        -: 8115:
        -: 8116:
        -: 8117:/* Print a compiled pattern string in human-readable form, starting at
        -: 8118:   the START pointer into it and ending just before the pointer END.  */
        -: 8119:
        -: 8120:void
        -: 8121:print_partial_compiled_pattern (start, end)
        -: 8122:    unsigned char *start;
        -: 8123:    unsigned char *end;
        -: 8124:{
        -: 8125:  int mcnt, mcnt2;
        -: 8126:  unsigned char *p1;
        -: 8127:  unsigned char *p = start;
        -: 8128:  unsigned char *pend = end;
        -: 8129:
        -: 8130:  if (start == NULL)
        -: 8131:    {
        -: 8132:      printf ("(null)\n");
        -: 8133:      return;
        -: 8134:    }
        -: 8135:
        -: 8136:  /* Loop over pattern commands.  */
        -: 8137:  while (p < pend)
        -: 8138:    {
        -: 8139:      printf ("%d:\t", p - start);
        -: 8140:
        -: 8141:      switch ((re_opcode_t) *p++)
        -: 8142:	{
        -: 8143:        case no_op:
        -: 8144:          printf ("/no_op");
        -: 8145:          break;
        -: 8146:
        -: 8147:	case exactn:
        -: 8148:	  mcnt = *p++;
        -: 8149:          printf ("/exactn/%d", mcnt);
        -: 8150:          do
        -: 8151:	    {
        -: 8152:              putchar ('/');
        -: 8153:	      putchar (*p++);
        -: 8154:            }
        -: 8155:          while (--mcnt);
        -: 8156:          break;
        -: 8157:
        -: 8158:	case start_memory:
        -: 8159:          mcnt = *p++;
        -: 8160:          printf ("/start_memory/%d/%d", mcnt, *p++);
        -: 8161:          break;
        -: 8162:
        -: 8163:	case stop_memory:
        -: 8164:          mcnt = *p++;
        -: 8165:	  printf ("/stop_memory/%d/%d", mcnt, *p++);
        -: 8166:          break;
        -: 8167:
        -: 8168:	case duplicate:
        -: 8169:	  printf ("/duplicate/%d", *p++);
        -: 8170:	  break;
        -: 8171:
        -: 8172:	case anychar:
        -: 8173:	  printf ("/anychar");
        -: 8174:	  break;
        -: 8175:
        -: 8176:	case charset:
        -: 8177:        case charset_not:
        -: 8178:          {
        -: 8179:            register int c, last = -100;
        -: 8180:	    register int in_range = 0;
        -: 8181:
        -: 8182:	    printf ("/charset [%s",
        -: 8183:	            (re_opcode_t) *(p - 1) == charset_not ? "^" : "");
        -: 8184:
        -: 8185:            assert (p + *p < pend);
        -: 8186:
        -: 8187:            for (c = 0; c < 256; c++)
        -: 8188:	      if (c / 8 < *p
        -: 8189:		  && (p[1 + (c/8)] & (1 << (c % 8))))
        -: 8190:		{
        -: 8191:		  /* Are we starting a range?  */
        -: 8192:		  if (last + 1 == c && ! in_range)
        -: 8193:		    {
        -: 8194:		      putchar ('-');
        -: 8195:		      in_range = 1;
        -: 8196:		    }
        -: 8197:		  /* Have we broken a range?  */
        -: 8198:		  else if (last + 1 != c && in_range)
        -: 8199:              {
        -: 8200:		      putchar (last);
        -: 8201:		      in_range = 0;
        -: 8202:		    }
        -: 8203:
        -: 8204:		  if (! in_range)
        -: 8205:		    putchar (c);
        -: 8206:
        -: 8207:		  last = c;
        -: 8208:              }
        -: 8209:
        -: 8210:	    if (in_range)
        -: 8211:	      putchar (last);
        -: 8212:
        -: 8213:	    putchar (']');
        -: 8214:
        -: 8215:	    p += 1 + *p;
        -: 8216:	  }
        -: 8217:	  break;
        -: 8218:
        -: 8219:	case begline:
        -: 8220:	  printf ("/begline");
        -: 8221:          break;
        -: 8222:
        -: 8223:	case endline:
        -: 8224:          printf ("/endline");
        -: 8225:          break;
        -: 8226:
        -: 8227:	case on_failure_jump:
        -: 8228:          extract_number_and_incr (&mcnt, &p);
        -: 8229:  	  printf ("/on_failure_jump to %d", p + mcnt - start);
        -: 8230:          break;
        -: 8231:
        -: 8232:	case on_failure_keep_string_jump:
        -: 8233:          extract_number_and_incr (&mcnt, &p);
        -: 8234:  	  printf ("/on_failure_keep_string_jump to %d", p + mcnt - start);
        -: 8235:          break;
        -: 8236:
        -: 8237:	case dummy_failure_jump:
        -: 8238:          extract_number_and_incr (&mcnt, &p);
        -: 8239:  	  printf ("/dummy_failure_jump to %d", p + mcnt - start);
        -: 8240:          break;
        -: 8241:
        -: 8242:	case push_dummy_failure:
        -: 8243:          printf ("/push_dummy_failure");
        -: 8244:          break;
        -: 8245:
        -: 8246:        case maybe_pop_jump:
        -: 8247:          extract_number_and_incr (&mcnt, &p);
        -: 8248:  	  printf ("/maybe_pop_jump to %d", p + mcnt - start);
        -: 8249:	  break;
        -: 8250:
        -: 8251:        case pop_failure_jump:
        -: 8252:	  extract_number_and_incr (&mcnt, &p);
        -: 8253:  	  printf ("/pop_failure_jump to %d", p + mcnt - start);
        -: 8254:	  break;
        -: 8255:
        -: 8256:        case jump_past_alt:
        -: 8257:	  extract_number_and_incr (&mcnt, &p);
        -: 8258:  	  printf ("/jump_past_alt to %d", p + mcnt - start);
        -: 8259:	  break;
        -: 8260:
        -: 8261:        case jump:
        -: 8262:	  extract_number_and_incr (&mcnt, &p);
        -: 8263:  	  printf ("/jump to %d", p + mcnt - start);
        -: 8264:	  break;
        -: 8265:
        -: 8266:        case succeed_n:
        -: 8267:          extract_number_and_incr (&mcnt, &p);
        -: 8268:	  p1 = p + mcnt;
        -: 8269:          extract_number_and_incr (&mcnt2, &p);
        -: 8270:	  printf ("/succeed_n to %d, %d times", p1 - start, mcnt2);
        -: 8271:          break;
        -: 8272:
        -: 8273:        case jump_n:
        -: 8274:          extract_number_and_incr (&mcnt, &p);
        -: 8275:	  p1 = p + mcnt;
        -: 8276:          extract_number_and_incr (&mcnt2, &p);
        -: 8277:	  printf ("/jump_n to %d, %d times", p1 - start, mcnt2);
        -: 8278:          break;
        -: 8279:
        -: 8280:        case set_number_at:
        -: 8281:          extract_number_and_incr (&mcnt, &p);
        -: 8282:	  p1 = p + mcnt;
        -: 8283:          extract_number_and_incr (&mcnt2, &p);
        -: 8284:	  printf ("/set_number_at location %d to %d", p1 - start, mcnt2);
        -: 8285:          break;
        -: 8286:
        -: 8287:        case wordbound:
        -: 8288:	  printf ("/wordbound");
        -: 8289:	  break;
        -: 8290:
        -: 8291:	case notwordbound:
        -: 8292:	  printf ("/notwordbound");
        -: 8293:          break;
        -: 8294:
        -: 8295:	case wordbeg:
        -: 8296:	  printf ("/wordbeg");
        -: 8297:	  break;
        -: 8298:
        -: 8299:	case wordend:
        -: 8300:	  printf ("/wordend");
        -: 8301:
        -: 8302:# ifdef emacs
        -: 8303:	case before_dot:
        -: 8304:	  printf ("/before_dot");
        -: 8305:          break;
        -: 8306:
        -: 8307:	case at_dot:
        -: 8308:	  printf ("/at_dot");
        -: 8309:          break;
        -: 8310:
        -: 8311:	case after_dot:
        -: 8312:	  printf ("/after_dot");
        -: 8313:          break;
        -: 8314:
        -: 8315:	case syntaxspec:
        -: 8316:          printf ("/syntaxspec");
        -: 8317:	  mcnt = *p++;
        -: 8318:	  printf ("/%d", mcnt);
        -: 8319:          break;
        -: 8320:
        -: 8321:	case notsyntaxspec:
        -: 8322:          printf ("/notsyntaxspec");
        -: 8323:	  mcnt = *p++;
        -: 8324:	  printf ("/%d", mcnt);
        -: 8325:	  break;
        -: 8326:# endif /* emacs */
        -: 8327:
        -: 8328:	case wordchar:
        -: 8329:	  printf ("/wordchar");
        -: 8330:          break;
        -: 8331:
        -: 8332:	case notwordchar:
        -: 8333:	  printf ("/notwordchar");
        -: 8334:          break;
        -: 8335:
        -: 8336:	case begbuf:
        -: 8337:	  printf ("/begbuf");
        -: 8338:          break;
        -: 8339:
        -: 8340:	case endbuf:
        -: 8341:	  printf ("/endbuf");
        -: 8342:          break;
        -: 8343:
        -: 8344:        default:
        -: 8345:          printf ("?%d", *(p-1));
        -: 8346:	}
        -: 8347:
        -: 8348:      putchar ('\n');
        -: 8349:    }
        -: 8350:
        -: 8351:  printf ("%d:\tend of pattern.\n", p - start);
        -: 8352:}
        -: 8353:
        -: 8354:
        -: 8355:void
        -: 8356:print_compiled_pattern (bufp)
        -: 8357:    struct re_pattern_buffer *bufp;
        -: 8358:{
        -: 8359:  unsigned char *buffer = bufp->buffer;
        -: 8360:
        -: 8361:  print_partial_compiled_pattern (buffer, buffer + bufp->used);
        -: 8362:  printf ("%ld bytes used/%ld bytes allocated.\n",
        -: 8363:	  bufp->used, bufp->allocated);
        -: 8364:
        -: 8365:  if (bufp->fastmap_accurate && bufp->fastmap)
        -: 8366:    {
        -: 8367:      printf ("fastmap: ");
        -: 8368:      print_fastmap (bufp->fastmap);
        -: 8369:    }
        -: 8370:
        -: 8371:  printf ("re_nsub: %d\t", bufp->re_nsub);
        -: 8372:  printf ("regs_alloc: %d\t", bufp->regs_allocated);
        -: 8373:  printf ("can_be_null: %d\t", bufp->can_be_null);
        -: 8374:  printf ("newline_anchor: %d\n", bufp->newline_anchor);
        -: 8375:  printf ("no_sub: %d\t", bufp->no_sub);
        -: 8376:  printf ("not_bol: %d\t", bufp->not_bol);
        -: 8377:  printf ("not_eol: %d\t", bufp->not_eol);
        -: 8378:  printf ("syntax: %lx\n", bufp->syntax);
        -: 8379:  /* Perhaps we should print the translate table?  */
        -: 8380:}
        -: 8381:
        -: 8382:
        -: 8383:void
        -: 8384:print_double_string (where, string1, size1, string2, size2)
        -: 8385:    const char *where;
        -: 8386:    const char *string1;
        -: 8387:    const char *string2;
        -: 8388:    int size1;
        -: 8389:    int size2;
        -: 8390:{
        -: 8391:  int this_char;
        -: 8392:
        -: 8393:  if (where == NULL)
        -: 8394:    printf ("(null)");
        -: 8395:  else
        -: 8396:    {
        -: 8397:      if (FIRST_STRING_P (where))
        -: 8398:        {
        -: 8399:          for (this_char = where - string1; this_char < size1; this_char++)
        -: 8400:            putchar (string1[this_char]);
        -: 8401:
        -: 8402:          where = string2;
        -: 8403:        }
        -: 8404:
        -: 8405:      for (this_char = where - string2; this_char < size2; this_char++)
        -: 8406:        putchar (string2[this_char]);
        -: 8407:    }
        -: 8408:}
        -: 8409:
        -: 8410:void
        -: 8411:printchar (c)
        -: 8412:     int c;
        -: 8413:{
        -: 8414:  putc (c, stderr);
        -: 8415:}
        -: 8416:
        -: 8417:#else /* not DEBUG */
        -: 8418:
        -: 8419:# undef assert
        -: 8420:# define assert(e)
        -: 8421:
        -: 8422:# define DEBUG_STATEMENT(e)
        -: 8423:# define DEBUG_PRINT1(x)
        -: 8424:# define DEBUG_PRINT2(x1, x2)
        -: 8425:# define DEBUG_PRINT3(x1, x2, x3)
        -: 8426:# define DEBUG_PRINT4(x1, x2, x3, x4)
        -: 8427:# define DEBUG_PRINT_COMPILED_PATTERN(p, s, e)
        -: 8428:# define DEBUG_PRINT_DOUBLE_STRING(w, s1, sz1, s2, sz2)
        -: 8429:
        -: 8430:#endif /* not DEBUG */
        -: 8431:
        -: 8432:/* Set by `re_set_syntax' to the current regexp syntax to recognize.  Can
        -: 8433:   also be assigned to arbitrarily: each pattern buffer stores its own
        -: 8434:   syntax, so it can be changed between regex compilations.  */
        -: 8435:/* This has no initializer because initialized variables in Emacs
        -: 8436:   become read-only after dumping.  */
        -: 8437:reg_syntax_t re_syntax_options;
        -: 8438:
        -: 8439:
        -: 8440:/* Specify the precise syntax of regexps for compilation.  This provides
        -: 8441:   for compatibility for various utilities which historically have
        -: 8442:   different, incompatible syntaxes.
        -: 8443:
        -: 8444:   The argument SYNTAX is a bit mask comprised of the various bits
        -: 8445:   defined in regex.h.  We return the old syntax.  */
        -: 8446:
        -: 8447:reg_syntax_t
function re_set_syntax called 781 returned 100% blocks executed 100%
      781: 8448:re_set_syntax (syntax)
        -: 8449:    reg_syntax_t syntax;
        -: 8450:{
      781: 8451:  reg_syntax_t ret = re_syntax_options;
        -: 8452:
      781: 8453:  re_syntax_options = syntax;
        -: 8454:#ifdef DEBUG
        -: 8455:  if (syntax & RE_DEBUG)
        -: 8456:    debug = 1;
        -: 8457:  else if (debug) /* was on but now is not */
        -: 8458:    debug = 0;
        -: 8459:#endif /* DEBUG */
      781: 8460:  return ret;
        -: 8461:}
        -: 8462:#ifdef _LIBC
        -: 8463:weak_alias (__re_set_syntax, re_set_syntax)
        -: 8464:#endif
        -: 8465:
        -: 8466:/* This table gives an error message for each of the error codes listed
        -: 8467:   in regex.h.  Obviously the order here has to be same as there.
        -: 8468:   POSIX doesn't require that we do anything for REG_NOERROR,
        -: 8469:   but why not be nice?  */
        -: 8470:
        -: 8471:#if 0
        -: 8472:  /* This section is for xgettext; it sees the strings wrapped inside
        -: 8473:     N_() and marks them as needing translation.  They should match
        -: 8474:     the strings in re_error_msgid.  We can't use the usual string
        -: 8475:     concatenation trick to initialize re_error_msgid, since other GNU
        -: 8476:     distributions use this file with traditional C, and traditional C
        -: 8477:     lacks string concatenation.  */
        -: 8478:  N_("Success") /* REG_NOERROR */
        -: 8479:  N_("No match") /* REG_NOMATCH */
        -: 8480:  N_("Invalid regular expression") /* REG_BADPAT */
        -: 8481:  N_("Invalid collation character") /* REG_ECOLLATE */
        -: 8482:  N_("Invalid character class name") /* REG_ECTYPE */
        -: 8483:  N_("Trailing backslash") /* REG_EESCAPE */
        -: 8484:  N_("Invalid back reference") /* REG_ESUBREG */
        -: 8485:  N_("Unmatched [ or [^") /* REG_EBRACK */
        -: 8486:  N_("Unmatched ( or \\(") /* REG_EPAREN */
        -: 8487:  N_("Unmatched \\{") /* REG_EBRACE */
        -: 8488:  N_("Invalid content of \\{\\}") /* REG_BADBR */
        -: 8489:  N_("Invalid range end") /* REG_ERANGE */
        -: 8490:  N_("Memory exhausted") /* REG_ESPACE */
        -: 8491:  N_("Invalid preceding regular expression") /* REG_BADRPT */
        -: 8492:  N_("Premature end of regular expression") /* REG_EEND */
        -: 8493:  N_("Regular expression too big") /* REG_ESIZE */
        -: 8494:  N_("Unmatched ) or \\)") /* REG_ERPAREN */
        -: 8495:#endif
        -: 8496:
        -: 8497:static const char re_error_msgid[] = "\
        -: 8498:Success\0\
        -: 8499:No match\0\
        -: 8500:Invalid regular expression\0\
        -: 8501:Invalid collation character\0\
        -: 8502:Invalid character class name\0\
        -: 8503:Trailing backslash\0\
        -: 8504:Invalid back reference\0\
        -: 8505:Unmatched [ or [^\0\
        -: 8506:Unmatched ( or \\(\0\
        -: 8507:Unmatched \\{\0\
        -: 8508:Invalid content of \\{\\}\0\
        -: 8509:Invalid range end\0\
        -: 8510:Memory exhausted\0\
        -: 8511:Invalid preceding regular expression\0\
        -: 8512:Premature end of regular expression\0\
        -: 8513:Regular expression too big\0\
        -: 8514:Unmatched ) or \\)";
        -: 8515:
        -: 8516:#define REG_NOERROR_IDX	0
        -: 8517:#define REG_NOMATCH_IDX (REG_NOERROR_IDX + sizeof "Success")
        -: 8518:#define REG_BADPAT_IDX	(REG_NOMATCH_IDX + sizeof "No match")
        -: 8519:#define REG_ECOLLATE_IDX (REG_BADPAT_IDX + sizeof "Invalid regular expression")
        -: 8520:#define REG_ECTYPE_IDX	(REG_ECOLLATE_IDX + sizeof "Invalid collation character")
        -: 8521:#define REG_EESCAPE_IDX	(REG_ECTYPE_IDX + sizeof "Invalid character class name")
        -: 8522:#define REG_ESUBREG_IDX	(REG_EESCAPE_IDX + sizeof "Trailing backslash")
        -: 8523:#define REG_EBRACK_IDX	(REG_ESUBREG_IDX + sizeof "Invalid back reference")
        -: 8524:#define REG_EPAREN_IDX	(REG_EBRACK_IDX + sizeof "Unmatched [ or [^")
        -: 8525:#define REG_EBRACE_IDX	(REG_EPAREN_IDX + sizeof "Unmatched ( or \\(")
        -: 8526:#define REG_BADBR_IDX	(REG_EBRACE_IDX + sizeof "Unmatched \\{")
        -: 8527:#define REG_ERANGE_IDX	(REG_BADBR_IDX + sizeof "Invalid content of \\{\\}")
        -: 8528:#define REG_ESPACE_IDX	(REG_ERANGE_IDX + sizeof "Invalid range end")
        -: 8529:#define REG_BADRPT_IDX	(REG_ESPACE_IDX + sizeof "Memory exhausted")
        -: 8530:#define REG_EEND_IDX	(REG_BADRPT_IDX + sizeof "Invalid preceding regular expression")
        -: 8531:#define REG_ESIZE_IDX	(REG_EEND_IDX + sizeof "Premature end of regular expression")
        -: 8532:#define REG_ERPAREN_IDX	(REG_ESIZE_IDX + sizeof "Regular expression too big")
        -: 8533:
        -: 8534:static const size_t re_error_msgid_idx[] =
        -: 8535:  {
        -: 8536:    REG_NOERROR_IDX,
        -: 8537:    REG_NOMATCH_IDX,
        -: 8538:    REG_BADPAT_IDX,
        -: 8539:    REG_ECOLLATE_IDX,
        -: 8540:    REG_ECTYPE_IDX,
        -: 8541:    REG_EESCAPE_IDX,
        -: 8542:    REG_ESUBREG_IDX,
        -: 8543:    REG_EBRACK_IDX,
        -: 8544:    REG_EPAREN_IDX,
        -: 8545:    REG_EBRACE_IDX,
        -: 8546:    REG_BADBR_IDX,
        -: 8547:    REG_ERANGE_IDX,
        -: 8548:    REG_ESPACE_IDX,
        -: 8549:    REG_BADRPT_IDX,
        -: 8550:    REG_EEND_IDX,
        -: 8551:    REG_ESIZE_IDX,
        -: 8552:    REG_ERPAREN_IDX
        -: 8553:  };
        -: 8554:
        -: 8555:/* Avoiding alloca during matching, to placate r_alloc.  */
        -: 8556:
        -: 8557:/* Define MATCH_MAY_ALLOCATE unless we need to make sure that the
        -: 8558:   searching and matching functions should not call alloca.  On some
        -: 8559:   systems, alloca is implemented in terms of malloc, and if we're
        -: 8560:   using the relocating allocator routines, then malloc could cause a
        -: 8561:   relocation, which might (if the strings being searched are in the
        -: 8562:   ralloc heap) shift the data out from underneath the regexp
        -: 8563:   routines.
        -: 8564:
        -: 8565:   Here's another reason to avoid allocation: Emacs
        -: 8566:   processes input from X in a signal handler; processing X input may
        -: 8567:   call malloc; if input arrives while a matching routine is calling
        -: 8568:   malloc, then we're scrod.  But Emacs can't just block input while
        -: 8569:   calling matching routines; then we don't notice interrupts when
        -: 8570:   they come in.  So, Emacs blocks input around all regexp calls
        -: 8571:   except the matching calls, which it leaves unprotected, in the
        -: 8572:   faith that they will not malloc.  */
        -: 8573:
        -: 8574:/* Normally, this is fine.  */
        -: 8575:#define MATCH_MAY_ALLOCATE
        -: 8576:
        -: 8577:/* When using GNU C, we are not REALLY using the C alloca, no matter
        -: 8578:   what config.h may say.  So don't take precautions for it.  */
        -: 8579:#ifdef __GNUC__
        -: 8580:# undef C_ALLOCA
        -: 8581:#endif
        -: 8582:
        -: 8583:/* The match routines may not allocate if (1) they would do it with malloc
        -: 8584:   and (2) it's not safe for them to use malloc.
        -: 8585:   Note that if REL_ALLOC is defined, matching would not use malloc for the
        -: 8586:   failure stack, but we would still use it for the register vectors;
        -: 8587:   so REL_ALLOC should not affect this.  */
        -: 8588:#if (defined C_ALLOCA || defined REGEX_MALLOC) && defined emacs
        -: 8589:# undef MATCH_MAY_ALLOCATE
        -: 8590:#endif
        -: 8591:
        -: 8592:
        -: 8593:/* Failure stack declarations and macros; both re_compile_fastmap and
        -: 8594:   re_match_2 use a failure stack.  These have to be macros because of
        -: 8595:   REGEX_ALLOCATE_STACK.  */
        -: 8596:
        -: 8597:
        -: 8598:/* Number of failure points for which to initially allocate space
        -: 8599:   when matching.  If this number is exceeded, we allocate more
        -: 8600:   space, so it is not a hard limit.  */
        -: 8601:#ifndef INIT_FAILURE_ALLOC
        -: 8602:# define INIT_FAILURE_ALLOC 5
        -: 8603:#endif
        -: 8604:
        -: 8605:/* Roughly the maximum number of failure points on the stack.  Would be
        -: 8606:   exactly that if always used MAX_FAILURE_ITEMS items each time we failed.
        -: 8607:   This is a variable only so users of regex can assign to it; we never
        -: 8608:   change it ourselves.  */
        -: 8609:
        -: 8610:#ifdef INT_IS_16BIT
        -: 8611:
        -: 8612:# if defined MATCH_MAY_ALLOCATE
        -: 8613:/* 4400 was enough to cause a crash on Alpha OSF/1,
        -: 8614:   whose default stack limit is 2mb.  */
        -: 8615:long int re_max_failures = 4000;
        -: 8616:# else
        -: 8617:long int re_max_failures = 2000;
        -: 8618:# endif
        -: 8619:
        -: 8620:union fail_stack_elt
        -: 8621:{
        -: 8622:  unsigned char *pointer;
        -: 8623:  long int integer;
        -: 8624:};
        -: 8625:
        -: 8626:typedef union fail_stack_elt fail_stack_elt_t;
        -: 8627:
        -: 8628:typedef struct
        -: 8629:{
        -: 8630:  fail_stack_elt_t *stack;
        -: 8631:  unsigned long int size;
        -: 8632:  unsigned long int avail;		/* Offset of next open position.  */
        -: 8633:} fail_stack_type;
        -: 8634:
        -: 8635:#else /* not INT_IS_16BIT */
        -: 8636:
        -: 8637:# if defined MATCH_MAY_ALLOCATE
        -: 8638:/* 4400 was enough to cause a crash on Alpha OSF/1,
        -: 8639:   whose default stack limit is 2mb.  */
        -: 8640:int re_max_failures = 20000;
        -: 8641:# else
        -: 8642:int re_max_failures = 2000;
        -: 8643:# endif
        -: 8644:
        -: 8645:union fail_stack_elt
        -: 8646:{
        -: 8647:  unsigned char *pointer;
        -: 8648:  int integer;
        -: 8649:};
        -: 8650:
        -: 8651:typedef union fail_stack_elt fail_stack_elt_t;
        -: 8652:
        -: 8653:typedef struct
        -: 8654:{
        -: 8655:  fail_stack_elt_t *stack;
        -: 8656:  unsigned size;
        -: 8657:  unsigned avail;			/* Offset of next open position.  */
        -: 8658:} fail_stack_type;
        -: 8659:
        -: 8660:#endif /* INT_IS_16BIT */
        -: 8661:
        -: 8662:#define FAIL_STACK_EMPTY()     (fail_stack.avail == 0)
        -: 8663:#define FAIL_STACK_PTR_EMPTY() (fail_stack_ptr->avail == 0)
        -: 8664:#define FAIL_STACK_FULL()      (fail_stack.avail == fail_stack.size)
        -: 8665:
        -: 8666:
        -: 8667:/* Define macros to initialize and free the failure stack.
        -: 8668:   Do `return -2' if the alloc fails.  */
        -: 8669:
        -: 8670:#ifdef MATCH_MAY_ALLOCATE
        -: 8671:# define INIT_FAIL_STACK()						\
        -: 8672:  do {									\
        -: 8673:    fail_stack.stack = (fail_stack_elt_t *)				\
        -: 8674:      REGEX_ALLOCATE_STACK (INIT_FAILURE_ALLOC * sizeof (fail_stack_elt_t)); \
        -: 8675:									\
        -: 8676:    if (fail_stack.stack == NULL)					\
        -: 8677:      return -2;							\
        -: 8678:									\
        -: 8679:    fail_stack.size = INIT_FAILURE_ALLOC;				\
        -: 8680:    fail_stack.avail = 0;						\
        -: 8681:  } while (0)
        -: 8682:
        -: 8683:# define RESET_FAIL_STACK()  REGEX_FREE_STACK (fail_stack.stack)
        -: 8684:#else
        -: 8685:# define INIT_FAIL_STACK()						\
        -: 8686:  do {									\
        -: 8687:    fail_stack.avail = 0;						\
        -: 8688:  } while (0)
        -: 8689:
        -: 8690:# define RESET_FAIL_STACK()
        -: 8691:#endif
        -: 8692:
        -: 8693:
        -: 8694:/* Double the size of FAIL_STACK, up to approximately `re_max_failures' items.
        -: 8695:
        -: 8696:   Return 1 if succeeds, and 0 if either ran out of memory
        -: 8697:   allocating space for it or it was already too large.
        -: 8698:
        -: 8699:   REGEX_REALLOCATE_STACK requires `destination' be declared.   */
        -: 8700:
        -: 8701:#define DOUBLE_FAIL_STACK(fail_stack)					\
        -: 8702:  ((fail_stack).size > (unsigned) (re_max_failures * MAX_FAILURE_ITEMS)	\
        -: 8703:   ? 0									\
        -: 8704:   : ((fail_stack).stack = (fail_stack_elt_t *)				\
        -: 8705:        REGEX_REALLOCATE_STACK ((fail_stack).stack, 			\
        -: 8706:          (fail_stack).size * sizeof (fail_stack_elt_t),		\
        -: 8707:          ((fail_stack).size << 1) * sizeof (fail_stack_elt_t)),	\
        -: 8708:									\
        -: 8709:      (fail_stack).stack == NULL					\
        -: 8710:      ? 0								\
        -: 8711:      : ((fail_stack).size <<= 1, 					\
        -: 8712:         1)))
        -: 8713:
        -: 8714:
        -: 8715:/* Push pointer POINTER on FAIL_STACK.
        -: 8716:   Return 1 if was able to do so and 0 if ran out of memory allocating
        -: 8717:   space to do so.  */
        -: 8718:#define PUSH_PATTERN_OP(POINTER, FAIL_STACK)				\
        -: 8719:  ((FAIL_STACK_FULL ()							\
        -: 8720:    && !DOUBLE_FAIL_STACK (FAIL_STACK))					\
        -: 8721:   ? 0									\
        -: 8722:   : ((FAIL_STACK).stack[(FAIL_STACK).avail++].pointer = POINTER,	\
        -: 8723:      1))
        -: 8724:
        -: 8725:/* Push a pointer value onto the failure stack.
        -: 8726:   Assumes the variable `fail_stack'.  Probably should only
        -: 8727:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 8728:#define PUSH_FAILURE_POINTER(item)					\
        -: 8729:  fail_stack.stack[fail_stack.avail++].pointer = (unsigned char *) (item)
        -: 8730:
        -: 8731:/* This pushes an integer-valued item onto the failure stack.
        -: 8732:   Assumes the variable `fail_stack'.  Probably should only
        -: 8733:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 8734:#define PUSH_FAILURE_INT(item)					\
        -: 8735:  fail_stack.stack[fail_stack.avail++].integer = (item)
        -: 8736:
        -: 8737:/* Push a fail_stack_elt_t value onto the failure stack.
        -: 8738:   Assumes the variable `fail_stack'.  Probably should only
        -: 8739:   be called from within `PUSH_FAILURE_POINT'.  */
        -: 8740:#define PUSH_FAILURE_ELT(item)					\
        -: 8741:  fail_stack.stack[fail_stack.avail++] =  (item)
        -: 8742:
        -: 8743:/* These three POP... operations complement the three PUSH... operations.
        -: 8744:   All assume that `fail_stack' is nonempty.  */
        -: 8745:#define POP_FAILURE_POINTER() fail_stack.stack[--fail_stack.avail].pointer
        -: 8746:#define POP_FAILURE_INT() fail_stack.stack[--fail_stack.avail].integer
        -: 8747:#define POP_FAILURE_ELT() fail_stack.stack[--fail_stack.avail]
        -: 8748:
        -: 8749:/* Used to omit pushing failure point id's when we're not debugging.  */
        -: 8750:#ifdef DEBUG
        -: 8751:# define DEBUG_PUSH PUSH_FAILURE_INT
        -: 8752:# define DEBUG_POP(item_addr) *(item_addr) = POP_FAILURE_INT ()
        -: 8753:#else
        -: 8754:# define DEBUG_PUSH(item)
        -: 8755:# define DEBUG_POP(item_addr)
        -: 8756:#endif
        -: 8757:
        -: 8758:
        -: 8759:/* Push the information about the state we will need
        -: 8760:   if we ever fail back to it.
        -: 8761:
        -: 8762:   Requires variables fail_stack, regstart, regend, reg_info, and
        -: 8763:   num_regs_pushed be declared.  DOUBLE_FAIL_STACK requires `destination'
        -: 8764:   be declared.
        -: 8765:
        -: 8766:   Does `return FAILURE_CODE' if runs out of memory.  */
        -: 8767:
        -: 8768:#define PUSH_FAILURE_POINT(pattern_place, string_place, failure_code)	\
        -: 8769:  do {									\
        -: 8770:    char *destination;							\
        -: 8771:    /* Must be int, so when we don't save any registers, the arithmetic	\
        -: 8772:       of 0 + -1 isn't done as unsigned.  */				\
        -: 8773:    /* Can't be int, since there is not a shred of a guarantee that int	\
        -: 8774:       is wide enough to hold a value of something to which pointer can	\
        -: 8775:       be assigned */							\
        -: 8776:    active_reg_t this_reg;						\
        -: 8777:    									\
        -: 8778:    DEBUG_STATEMENT (failure_id++);					\
        -: 8779:    DEBUG_STATEMENT (nfailure_points_pushed++);				\
        -: 8780:    DEBUG_PRINT2 ("\nPUSH_FAILURE_POINT #%u:\n", failure_id);		\
        -: 8781:    DEBUG_PRINT2 ("  Before push, next avail: %d\n", (fail_stack).avail);\
        -: 8782:    DEBUG_PRINT2 ("                     size: %d\n", (fail_stack).size);\
        -: 8783:									\
        -: 8784:    DEBUG_PRINT2 ("  slots needed: %ld\n", NUM_FAILURE_ITEMS);		\
        -: 8785:    DEBUG_PRINT2 ("     available: %d\n", REMAINING_AVAIL_SLOTS);	\
        -: 8786:									\
        -: 8787:    /* Ensure we have enough space allocated for what we will push.  */	\
        -: 8788:    while (REMAINING_AVAIL_SLOTS < NUM_FAILURE_ITEMS)			\
        -: 8789:      {									\
        -: 8790:        if (!DOUBLE_FAIL_STACK (fail_stack))				\
        -: 8791:          return failure_code;						\
        -: 8792:									\
        -: 8793:        DEBUG_PRINT2 ("\n  Doubled stack; size now: %d\n",		\
        -: 8794:		       (fail_stack).size);				\
        -: 8795:        DEBUG_PRINT2 ("  slots available: %d\n", REMAINING_AVAIL_SLOTS);\
        -: 8796:      }									\
        -: 8797:									\
        -: 8798:    /* Push the info, starting with the registers.  */			\
        -: 8799:    DEBUG_PRINT1 ("\n");						\
        -: 8800:									\
        -: 8801:    if (1)								\
        -: 8802:      for (this_reg = lowest_active_reg; this_reg <= highest_active_reg; \
        -: 8803:	   this_reg++)							\
        -: 8804:	{								\
        -: 8805:	  DEBUG_PRINT2 ("  Pushing reg: %lu\n", this_reg);		\
        -: 8806:	  DEBUG_STATEMENT (num_regs_pushed++);				\
        -: 8807:									\
        -: 8808:	  DEBUG_PRINT2 ("    start: %p\n", regstart[this_reg]);		\
        -: 8809:	  PUSH_FAILURE_POINTER (regstart[this_reg]);			\
        -: 8810:									\
        -: 8811:	  DEBUG_PRINT2 ("    end: %p\n", regend[this_reg]);		\
        -: 8812:	  PUSH_FAILURE_POINTER (regend[this_reg]);			\
        -: 8813:									\
        -: 8814:	  DEBUG_PRINT2 ("    info: %p\n      ",				\
        -: 8815:			reg_info[this_reg].word.pointer);		\
        -: 8816:	  DEBUG_PRINT2 (" match_null=%d",				\
        -: 8817:			REG_MATCH_NULL_STRING_P (reg_info[this_reg]));	\
        -: 8818:	  DEBUG_PRINT2 (" active=%d", IS_ACTIVE (reg_info[this_reg]));	\
        -: 8819:	  DEBUG_PRINT2 (" matched_something=%d",			\
        -: 8820:			MATCHED_SOMETHING (reg_info[this_reg]));	\
        -: 8821:	  DEBUG_PRINT2 (" ever_matched=%d",				\
        -: 8822:			EVER_MATCHED_SOMETHING (reg_info[this_reg]));	\
        -: 8823:	  DEBUG_PRINT1 ("\n");						\
        -: 8824:	  PUSH_FAILURE_ELT (reg_info[this_reg].word);			\
        -: 8825:	}								\
        -: 8826:									\
        -: 8827:    DEBUG_PRINT2 ("  Pushing  low active reg: %ld\n", lowest_active_reg);\
        -: 8828:    PUSH_FAILURE_INT (lowest_active_reg);				\
        -: 8829:									\
        -: 8830:    DEBUG_PRINT2 ("  Pushing high active reg: %ld\n", highest_active_reg);\
        -: 8831:    PUSH_FAILURE_INT (highest_active_reg);				\
        -: 8832:									\
        -: 8833:    DEBUG_PRINT2 ("  Pushing pattern %p:\n", pattern_place);		\
        -: 8834:    DEBUG_PRINT_COMPILED_PATTERN (bufp, pattern_place, pend);		\
        -: 8835:    PUSH_FAILURE_POINTER (pattern_place);				\
        -: 8836:									\
        -: 8837:    DEBUG_PRINT2 ("  Pushing string %p: `", string_place);		\
        -: 8838:    DEBUG_PRINT_DOUBLE_STRING (string_place, string1, size1, string2,   \
        -: 8839:				 size2);				\
        -: 8840:    DEBUG_PRINT1 ("'\n");						\
        -: 8841:    PUSH_FAILURE_POINTER (string_place);				\
        -: 8842:									\
        -: 8843:    DEBUG_PRINT2 ("  Pushing failure id: %u\n", failure_id);		\
        -: 8844:    DEBUG_PUSH (failure_id);						\
        -: 8845:  } while (0)
        -: 8846:
        -: 8847:/* This is the number of items that are pushed and popped on the stack
        -: 8848:   for each register.  */
        -: 8849:#define NUM_REG_ITEMS  3
        -: 8850:
        -: 8851:/* Individual items aside from the registers.  */
        -: 8852:#ifdef DEBUG
        -: 8853:# define NUM_NONREG_ITEMS 5 /* Includes failure point id.  */
        -: 8854:#else
        -: 8855:# define NUM_NONREG_ITEMS 4
        -: 8856:#endif
        -: 8857:
        -: 8858:/* We push at most this many items on the stack.  */
        -: 8859:/* We used to use (num_regs - 1), which is the number of registers
        -: 8860:   this regexp will save; but that was changed to 5
        -: 8861:   to avoid stack overflow for a regexp with lots of parens.  */
        -: 8862:#define MAX_FAILURE_ITEMS (5 * NUM_REG_ITEMS + NUM_NONREG_ITEMS)
        -: 8863:
        -: 8864:/* We actually push this many items.  */
        -: 8865:#define NUM_FAILURE_ITEMS				\
        -: 8866:  (((0							\
        -: 8867:     ? 0 : highest_active_reg - lowest_active_reg + 1)	\
        -: 8868:    * NUM_REG_ITEMS)					\
        -: 8869:   + NUM_NONREG_ITEMS)
        -: 8870:
        -: 8871:/* How many items can still be added to the stack without overflowing it.  */
        -: 8872:#define REMAINING_AVAIL_SLOTS ((fail_stack).size - (fail_stack).avail)
        -: 8873:
        -: 8874:
        -: 8875:/* Pops what PUSH_FAIL_STACK pushes.
        -: 8876:
        -: 8877:   We restore into the parameters, all of which should be lvalues:
        -: 8878:     STR -- the saved data position.
        -: 8879:     PAT -- the saved pattern position.
        -: 8880:     LOW_REG, HIGH_REG -- the highest and lowest active registers.
        -: 8881:     REGSTART, REGEND -- arrays of string positions.
        -: 8882:     REG_INFO -- array of information about each subexpression.
        -: 8883:
        -: 8884:   Also assumes the variables `fail_stack' and (if debugging), `bufp',
        -: 8885:   `pend', `string1', `size1', `string2', and `size2'.  */
        -: 8886:
        -: 8887:#define POP_FAILURE_POINT(str, pat, low_reg, high_reg, regstart, regend, reg_info)\
        -: 8888:{									\
        -: 8889:  DEBUG_STATEMENT (unsigned failure_id;)				\
        -: 8890:  active_reg_t this_reg;						\
        -: 8891:  const unsigned char *string_temp;					\
        -: 8892:									\
        -: 8893:  assert (!FAIL_STACK_EMPTY ());					\
        -: 8894:									\
        -: 8895:  /* Remove failure points and point to how many regs pushed.  */	\
        -: 8896:  DEBUG_PRINT1 ("POP_FAILURE_POINT:\n");				\
        -: 8897:  DEBUG_PRINT2 ("  Before pop, next avail: %d\n", fail_stack.avail);	\
        -: 8898:  DEBUG_PRINT2 ("                    size: %d\n", fail_stack.size);	\
        -: 8899:									\
        -: 8900:  assert (fail_stack.avail >= NUM_NONREG_ITEMS);			\
        -: 8901:									\
        -: 8902:  DEBUG_POP (&failure_id);						\
        -: 8903:  DEBUG_PRINT2 ("  Popping failure id: %u\n", failure_id);		\
        -: 8904:									\
        -: 8905:  /* If the saved string location is NULL, it came from an		\
        -: 8906:     on_failure_keep_string_jump opcode, and we want to throw away the	\
        -: 8907:     saved NULL, thus retaining our current position in the string.  */	\
        -: 8908:  string_temp = POP_FAILURE_POINTER ();					\
        -: 8909:  if (string_temp != NULL)						\
        -: 8910:    str = (const char *) string_temp;					\
        -: 8911:									\
        -: 8912:  DEBUG_PRINT2 ("  Popping string %p: `", str);				\
        -: 8913:  DEBUG_PRINT_DOUBLE_STRING (str, string1, size1, string2, size2);	\
        -: 8914:  DEBUG_PRINT1 ("'\n");							\
        -: 8915:									\
        -: 8916:  pat = (unsigned char *) POP_FAILURE_POINTER ();			\
        -: 8917:  DEBUG_PRINT2 ("  Popping pattern %p:\n", pat);			\
        -: 8918:  DEBUG_PRINT_COMPILED_PATTERN (bufp, pat, pend);			\
        -: 8919:									\
        -: 8920:  /* Restore register info.  */						\
        -: 8921:  high_reg = (active_reg_t) POP_FAILURE_INT ();				\
        -: 8922:  DEBUG_PRINT2 ("  Popping high active reg: %ld\n", high_reg);		\
        -: 8923:									\
        -: 8924:  low_reg = (active_reg_t) POP_FAILURE_INT ();				\
        -: 8925:  DEBUG_PRINT2 ("  Popping  low active reg: %ld\n", low_reg);		\
        -: 8926:									\
        -: 8927:  if (1)								\
        -: 8928:    for (this_reg = high_reg; this_reg >= low_reg; this_reg--)		\
        -: 8929:      {									\
        -: 8930:	DEBUG_PRINT2 ("    Popping reg: %ld\n", this_reg);		\
        -: 8931:									\
        -: 8932:	reg_info[this_reg].word = POP_FAILURE_ELT ();			\
        -: 8933:	DEBUG_PRINT2 ("      info: %p\n",				\
        -: 8934:		      reg_info[this_reg].word.pointer);			\
        -: 8935:									\
        -: 8936:	regend[this_reg] = (const char *) POP_FAILURE_POINTER ();	\
        -: 8937:	DEBUG_PRINT2 ("      end: %p\n", regend[this_reg]);		\
        -: 8938:									\
        -: 8939:	regstart[this_reg] = (const char *) POP_FAILURE_POINTER ();	\
        -: 8940:	DEBUG_PRINT2 ("      start: %p\n", regstart[this_reg]);		\
        -: 8941:      }									\
        -: 8942:  else									\
        -: 8943:    {									\
        -: 8944:      for (this_reg = highest_active_reg; this_reg > high_reg; this_reg--) \
        -: 8945:	{								\
        -: 8946:	  reg_info[this_reg].word.integer = 0;				\
        -: 8947:	  regend[this_reg] = 0;						\
        -: 8948:	  regstart[this_reg] = 0;					\
        -: 8949:	}								\
        -: 8950:      highest_active_reg = high_reg;					\
        -: 8951:    }									\
        -: 8952:									\
        -: 8953:  set_regs_matched_done = 0;						\
        -: 8954:  DEBUG_STATEMENT (nfailure_points_popped++);				\
        -: 8955:} /* POP_FAILURE_POINT */
        -: 8956:
        -: 8957:
        -: 8958:
        -: 8959:/* Structure for per-register (a.k.a. per-group) information.
        -: 8960:   Other register information, such as the
        -: 8961:   starting and ending positions (which are addresses), and the list of
        -: 8962:   inner groups (which is a bits list) are maintained in separate
        -: 8963:   variables.
        -: 8964:
        -: 8965:   We are making a (strictly speaking) nonportable assumption here: that
        -: 8966:   the compiler will pack our bit fields into something that fits into
        -: 8967:   the type of `word', i.e., is something that fits into one item on the
        -: 8968:   failure stack.  */
        -: 8969:
        -: 8970:
        -: 8971:/* Declarations and macros for re_match_2.  */
        -: 8972:
        -: 8973:typedef union
        -: 8974:{
        -: 8975:  fail_stack_elt_t word;
        -: 8976:  struct
        -: 8977:  {
        -: 8978:      /* This field is one if this group can match the empty string,
        -: 8979:         zero if not.  If not yet determined,  `MATCH_NULL_UNSET_VALUE'.  */
        -: 8980:#define MATCH_NULL_UNSET_VALUE 3
        -: 8981:    unsigned match_null_string_p : 2;
        -: 8982:    unsigned is_active : 1;
        -: 8983:    unsigned matched_something : 1;
        -: 8984:    unsigned ever_matched_something : 1;
        -: 8985:  } bits;
        -: 8986:} register_info_type;
        -: 8987:
        -: 8988:#define REG_MATCH_NULL_STRING_P(R)  ((R).bits.match_null_string_p)
        -: 8989:#define IS_ACTIVE(R)  ((R).bits.is_active)
        -: 8990:#define MATCHED_SOMETHING(R)  ((R).bits.matched_something)
        -: 8991:#define EVER_MATCHED_SOMETHING(R)  ((R).bits.ever_matched_something)
        -: 8992:
        -: 8993:
        -: 8994:/* Call this when have matched a real character; it sets `matched' flags
        -: 8995:   for the subexpressions which we are currently inside.  Also records
        -: 8996:   that those subexprs have matched.  */
        -: 8997:#define SET_REGS_MATCHED()						\
        -: 8998:  do									\
        -: 8999:    {									\
        -: 9000:      if (!set_regs_matched_done)					\
        -: 9001:	{								\
        -: 9002:	  active_reg_t r;						\
        -: 9003:	  set_regs_matched_done = 1;					\
        -: 9004:	  for (r = lowest_active_reg; r <= highest_active_reg; r++)	\
        -: 9005:	    {								\
        -: 9006:	      MATCHED_SOMETHING (reg_info[r])				\
        -: 9007:		= EVER_MATCHED_SOMETHING (reg_info[r])			\
        -: 9008:		= 1;							\
        -: 9009:	    }								\
        -: 9010:	}								\
        -: 9011:    }									\
        -: 9012:  while (0)
        -: 9013:
        -: 9014:/* Registers are set to a sentinel when they haven't yet matched.  */
        -: 9015:static char reg_unset_dummy;
        -: 9016:#define REG_UNSET_VALUE (&reg_unset_dummy)
        -: 9017:#define REG_UNSET(e) ((e) == REG_UNSET_VALUE)
        -: 9018:
        -: 9019:/* Subroutine declarations and macros for regex_compile.  */
        -: 9020:
        -: 9021:static reg_errcode_t regex_compile _RE_ARGS ((const char *pattern, size_t size,
        -: 9022:					      reg_syntax_t syntax,
        -: 9023:					      struct re_pattern_buffer *bufp));
        -: 9024:static void store_op1 _RE_ARGS ((re_opcode_t op, unsigned char *loc, int arg));
        -: 9025:static void store_op2 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 9026:				 int arg1, int arg2));
        -: 9027:static void insert_op1 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 9028:				  int arg, unsigned char *end));
        -: 9029:static void insert_op2 _RE_ARGS ((re_opcode_t op, unsigned char *loc,
        -: 9030:				  int arg1, int arg2, unsigned char *end));
        -: 9031:static boolean at_begline_loc_p _RE_ARGS ((const char *pattern, const char *p,
        -: 9032:					   reg_syntax_t syntax));
        -: 9033:static boolean at_endline_loc_p _RE_ARGS ((const char *p, const char *pend,
        -: 9034:					   reg_syntax_t syntax));
        -: 9035:static reg_errcode_t compile_range _RE_ARGS ((const char **p_ptr,
        -: 9036:					      const char *pend,
        -: 9037:					      char *translate,
        -: 9038:					      reg_syntax_t syntax,
        -: 9039:					      unsigned char *b));
        -: 9040:
        -: 9041:/* Fetch the next character in the uncompiled pattern---translating it
        -: 9042:   if necessary.  Also cast from a signed character in the constant
        -: 9043:   string passed to us by the user to an unsigned char that we can use
        -: 9044:   as an array index (in, e.g., `translate').  */
        -: 9045:#ifndef PATFETCH
        -: 9046:# define PATFETCH(c)							\
        -: 9047:  do {if (p == pend) return REG_EEND;					\
        -: 9048:    c = (unsigned char) *p++;						\
        -: 9049:    if (translate) c = (unsigned char) translate[c];			\
        -: 9050:  } while (0)
        -: 9051:#endif
        -: 9052:
        -: 9053:/* Fetch the next character in the uncompiled pattern, with no
        -: 9054:   translation.  */
        -: 9055:#define PATFETCH_RAW(c)							\
        -: 9056:  do {if (p == pend) return REG_EEND;					\
        -: 9057:    c = (unsigned char) *p++; 						\
        -: 9058:  } while (0)
        -: 9059:
        -: 9060:/* Go backwards one character in the pattern.  */
        -: 9061:#define PATUNFETCH p--
        -: 9062:
        -: 9063:
        -: 9064:/* If `translate' is non-null, return translate[D], else just D.  We
        -: 9065:   cast the subscript to translate because some data is declared as
        -: 9066:   `char *', to avoid warnings when a string constant is passed.  But
        -: 9067:   when we use a character as a subscript we must make it unsigned.  */
        -: 9068:#ifndef TRANSLATE
        -: 9069:# define TRANSLATE(d) \
        -: 9070:  (translate ? (char) translate[(unsigned char) (d)] : (d))
        -: 9071:#endif
        -: 9072:
        -: 9073:
        -: 9074:/* Macros for outputting the compiled pattern into `buffer'.  */
        -: 9075:
        -: 9076:/* If the buffer isn't allocated when it comes in, use this.  */
        -: 9077:#define INIT_BUF_SIZE  32
        -: 9078:
        -: 9079:/* Make sure we have at least N more bytes of space in buffer.  */
        -: 9080:#define GET_BUFFER_SPACE(n)						\
        -: 9081:    while ((unsigned long) (b - bufp->buffer + (n)) > bufp->allocated)	\
        -: 9082:      EXTEND_BUFFER ()
        -: 9083:
        -: 9084:/* Make sure we have one more byte of buffer space and then add C to it.  */
        -: 9085:#define BUF_PUSH(c)							\
        -: 9086:  do {									\
        -: 9087:    GET_BUFFER_SPACE (1);						\
        -: 9088:    *b++ = (unsigned char) (c);						\
        -: 9089:  } while (0)
        -: 9090:
        -: 9091:
        -: 9092:/* Ensure we have two more bytes of buffer space and then append C1 and C2.  */
        -: 9093:#define BUF_PUSH_2(c1, c2)						\
        -: 9094:  do {									\
        -: 9095:    GET_BUFFER_SPACE (2);						\
        -: 9096:    *b++ = (unsigned char) (c1);					\
        -: 9097:    *b++ = (unsigned char) (c2);					\
        -: 9098:  } while (0)
        -: 9099:
        -: 9100:
        -: 9101:/* As with BUF_PUSH_2, except for three bytes.  */
        -: 9102:#define BUF_PUSH_3(c1, c2, c3)						\
        -: 9103:  do {									\
        -: 9104:    GET_BUFFER_SPACE (3);						\
        -: 9105:    *b++ = (unsigned char) (c1);					\
        -: 9106:    *b++ = (unsigned char) (c2);					\
        -: 9107:    *b++ = (unsigned char) (c3);					\
        -: 9108:  } while (0)
        -: 9109:
        -: 9110:
        -: 9111:/* Store a jump with opcode OP at LOC to location TO.  We store a
        -: 9112:   relative address offset by the three bytes the jump itself occupies.  */
        -: 9113:#define STORE_JUMP(op, loc, to) \
        -: 9114:  store_op1 (op, loc, (int) ((to) - (loc) - 3))
        -: 9115:
        -: 9116:/* Likewise, for a two-argument jump.  */
        -: 9117:#define STORE_JUMP2(op, loc, to, arg) \
        -: 9118:  store_op2 (op, loc, (int) ((to) - (loc) - 3), arg)
        -: 9119:
        -: 9120:/* Like `STORE_JUMP', but for inserting.  Assume `b' is the buffer end.  */
        -: 9121:#define INSERT_JUMP(op, loc, to) \
        -: 9122:  insert_op1 (op, loc, (int) ((to) - (loc) - 3), b)
        -: 9123:
        -: 9124:/* Like `STORE_JUMP2', but for inserting.  Assume `b' is the buffer end.  */
        -: 9125:#define INSERT_JUMP2(op, loc, to, arg) \
        -: 9126:  insert_op2 (op, loc, (int) ((to) - (loc) - 3), arg, b)
        -: 9127:
        -: 9128:
        -: 9129:/* This is not an arbitrary limit: the arguments which represent offsets
        -: 9130:   into the pattern are two bytes long.  So if 2^16 bytes turns out to
        -: 9131:   be too small, many things would have to change.  */
        -: 9132:/* Any other compiler which, like MSC, has allocation limit below 2^16
        -: 9133:   bytes will have to use approach similar to what was done below for
        -: 9134:   MSC and drop MAX_BUF_SIZE a bit.  Otherwise you may end up
        -: 9135:   reallocating to 0 bytes.  Such thing is not going to work too well.
        -: 9136:   You have been warned!!  */
        -: 9137:#undef   REALLOC
        -: 9138:#if defined _MSC_VER  && !defined WIN32
        -: 9139:/* Microsoft C 16-bit versions limit malloc to approx 65512 bytes.
        -: 9140:   The REALLOC define eliminates a flurry of conversion warnings,
        -: 9141:   but is not required. */
        -: 9142:# define MAX_BUF_SIZE  65500L
        -: 9143:# define REALLOC(p,s) realloc ((p), (size_t) (s))
        -: 9144:#else
        -: 9145:# define MAX_BUF_SIZE (1L << 16)
        -: 9146:# define REALLOC(p,s) realloc ((p), (s))
        -: 9147:#endif
        -: 9148:
        -: 9149:/* Extend the buffer by twice its current size via realloc and
        -: 9150:   reset the pointers that pointed into the old block to point to the
        -: 9151:   correct places in the new one.  If extending the buffer results in it
        -: 9152:   being larger than MAX_BUF_SIZE, then flag memory exhausted.  */
        -: 9153:#define EXTEND_BUFFER()							\
        -: 9154:  do { 									\
        -: 9155:    unsigned char *old_buffer = bufp->buffer;				\
        -: 9156:    if (bufp->allocated == MAX_BUF_SIZE) 				\
        -: 9157:      return REG_ESIZE;							\
        -: 9158:    bufp->allocated <<= 1;						\
        -: 9159:    if (bufp->allocated > MAX_BUF_SIZE)					\
        -: 9160:      bufp->allocated = MAX_BUF_SIZE; 					\
        -: 9161:    bufp->buffer = (unsigned char *) REALLOC (bufp->buffer, bufp->allocated);\
        -: 9162:    if (bufp->buffer == NULL)						\
        -: 9163:      return REG_ESPACE;						\
        -: 9164:    /* If the buffer moved, move all the pointers into it.  */		\
        -: 9165:    if (old_buffer != bufp->buffer)					\
        -: 9166:      {									\
        -: 9167:        b = (b - old_buffer) + bufp->buffer;				\
        -: 9168:        begalt = (begalt - old_buffer) + bufp->buffer;			\
        -: 9169:        if (fixup_alt_jump)						\
        -: 9170:          fixup_alt_jump = (fixup_alt_jump - old_buffer) + bufp->buffer;\
        -: 9171:        if (laststart)							\
        -: 9172:          laststart = (laststart - old_buffer) + bufp->buffer;		\
        -: 9173:        if (pending_exact)						\
        -: 9174:          pending_exact = (pending_exact - old_buffer) + bufp->buffer;	\
        -: 9175:      }									\
        -: 9176:  } while (0)
        -: 9177:
        -: 9178:
        -: 9179:/* Since we have one byte reserved for the register number argument to
        -: 9180:   {start,stop}_memory, the maximum number of groups we can report
        -: 9181:   things about is what fits in that byte.  */
        -: 9182:#define MAX_REGNUM 255
        -: 9183:
        -: 9184:/* But patterns can have more than `MAX_REGNUM' registers.  We just
        -: 9185:   ignore the excess.  */
        -: 9186:typedef unsigned regnum_t;
        -: 9187:
        -: 9188:
        -: 9189:/* Macros for the compile stack.  */
        -: 9190:
        -: 9191:/* Since offsets can go either forwards or backwards, this type needs to
        -: 9192:   be able to hold values from -(MAX_BUF_SIZE - 1) to MAX_BUF_SIZE - 1.  */
        -: 9193:/* int may be not enough when sizeof(int) == 2.  */
        -: 9194:typedef long pattern_offset_t;
        -: 9195:
        -: 9196:typedef struct
        -: 9197:{
        -: 9198:  pattern_offset_t begalt_offset;
        -: 9199:  pattern_offset_t fixup_alt_jump;
        -: 9200:  pattern_offset_t inner_group_offset;
        -: 9201:  pattern_offset_t laststart_offset;
        -: 9202:  regnum_t regnum;
        -: 9203:} compile_stack_elt_t;
        -: 9204:
        -: 9205:
        -: 9206:typedef struct
        -: 9207:{
        -: 9208:  compile_stack_elt_t *stack;
        -: 9209:  unsigned size;
        -: 9210:  unsigned avail;			/* Offset of next open position.  */
        -: 9211:} compile_stack_type;
        -: 9212:
        -: 9213:
        -: 9214:#define INIT_COMPILE_STACK_SIZE 32
        -: 9215:
        -: 9216:#define COMPILE_STACK_EMPTY  (compile_stack.avail == 0)
        -: 9217:#define COMPILE_STACK_FULL  (compile_stack.avail == compile_stack.size)
        -: 9218:
        -: 9219:/* The next available element.  */
        -: 9220:#define COMPILE_STACK_TOP (compile_stack.stack[compile_stack.avail])
        -: 9221:
        -: 9222:
        -: 9223:/* Set the bit for character C in a list.  */
        -: 9224:#define SET_LIST_BIT(c)                               \
        -: 9225:  (b[((unsigned char) (c)) / BYTEWIDTH]               \
        -: 9226:   |= 1 << (((unsigned char) c) % BYTEWIDTH))
        -: 9227:
        -: 9228:
        -: 9229:/* Get the next unsigned number in the uncompiled pattern.  */
        -: 9230:#define GET_UNSIGNED_NUMBER(num) 					\
        -: 9231:  { if (p != pend)							\
        -: 9232:     {									\
        -: 9233:       PATFETCH (c); 							\
        -: 9234:       while ('0' <= c && c <= '9')					\
        -: 9235:         { 								\
        -: 9236:           if (num < 0)							\
        -: 9237:              num = 0;							\
        -: 9238:           num = num * 10 + c - '0'; 					\
        -: 9239:           if (p == pend) 						\
        -: 9240:              break; 							\
        -: 9241:           PATFETCH (c);						\
        -: 9242:         } 								\
        -: 9243:       } 								\
        -: 9244:    }
        -: 9245:
        -: 9246:#if defined _LIBC || WIDE_CHAR_SUPPORT
        -: 9247:/* The GNU C library provides support for user-defined character classes
        -: 9248:   and the functions from ISO C amendement 1.  */
        -: 9249:# ifdef CHARCLASS_NAME_MAX
        -: 9250:#  define CHAR_CLASS_MAX_LENGTH CHARCLASS_NAME_MAX
        -: 9251:# else
        -: 9252:/* This shouldn't happen but some implementation might still have this
        -: 9253:   problem.  Use a reasonable default value.  */
        -: 9254:#  define CHAR_CLASS_MAX_LENGTH 256
        -: 9255:# endif
        -: 9256:
        -: 9257:# ifdef _LIBC
        -: 9258:#  define IS_CHAR_CLASS(string) __wctype (string)
        -: 9259:# else
        -: 9260:#  define IS_CHAR_CLASS(string) wctype (string)
        -: 9261:# endif
        -: 9262:#else
        -: 9263:# define CHAR_CLASS_MAX_LENGTH  6 /* Namely, `xdigit'.  */
        -: 9264:
        -: 9265:# define IS_CHAR_CLASS(string)						\
        -: 9266:   (STREQ (string, "alpha") || STREQ (string, "upper")			\
        -: 9267:    || STREQ (string, "lower") || STREQ (string, "digit")		\
        -: 9268:    || STREQ (string, "alnum") || STREQ (string, "xdigit")		\
        -: 9269:    || STREQ (string, "space") || STREQ (string, "print")		\
        -: 9270:    || STREQ (string, "punct") || STREQ (string, "graph")		\
        -: 9271:    || STREQ (string, "cntrl") || STREQ (string, "blank"))
        -: 9272:#endif
        -: 9273:
        -: 9274:#ifndef MATCH_MAY_ALLOCATE
        -: 9275:
        -: 9276:/* If we cannot allocate large objects within re_match_2_internal,
        -: 9277:   we make the fail stack and register vectors global.
        -: 9278:   The fail stack, we grow to the maximum size when a regexp
        -: 9279:   is compiled.
        -: 9280:   The register vectors, we adjust in size each time we
        -: 9281:   compile a regexp, according to the number of registers it needs.  */
        -: 9282:
        -: 9283:static fail_stack_type fail_stack;
        -: 9284:
        -: 9285:/* Size with which the following vectors are currently allocated.
        -: 9286:   That is so we can make them bigger as needed,
        -: 9287:   but never make them smaller.  */
        -: 9288:static int regs_allocated_size;
        -: 9289:
        -: 9290:static const char **     regstart, **     regend;
        -: 9291:static const char ** old_regstart, ** old_regend;
        -: 9292:static const char **best_regstart, **best_regend;
        -: 9293:static register_info_type *reg_info;
        -: 9294:static const char **reg_dummy;
        -: 9295:static register_info_type *reg_info_dummy;
        -: 9296:
        -: 9297:/* Make the register vectors big enough for NUM_REGS registers,
        -: 9298:   but don't make them smaller.  */
        -: 9299:
        -: 9300:static
        -: 9301:regex_grow_registers (num_regs)
        -: 9302:     int num_regs;
        -: 9303:{
        -: 9304:  if (num_regs > regs_allocated_size)
        -: 9305:    {
        -: 9306:      RETALLOC_IF (regstart,	 num_regs, const char *);
        -: 9307:      RETALLOC_IF (regend,	 num_regs, const char *);
        -: 9308:      RETALLOC_IF (old_regstart, num_regs, const char *);
        -: 9309:      RETALLOC_IF (old_regend,	 num_regs, const char *);
        -: 9310:      RETALLOC_IF (best_regstart, num_regs, const char *);
        -: 9311:      RETALLOC_IF (best_regend,	 num_regs, const char *);
        -: 9312:      RETALLOC_IF (reg_info,	 num_regs, register_info_type);
        -: 9313:      RETALLOC_IF (reg_dummy,	 num_regs, const char *);
        -: 9314:      RETALLOC_IF (reg_info_dummy, num_regs, register_info_type);
        -: 9315:
        -: 9316:      regs_allocated_size = num_regs;
        -: 9317:    }
        -: 9318:}
        -: 9319:
        -: 9320:#endif /* not MATCH_MAY_ALLOCATE */
        -: 9321:
        -: 9322:static boolean group_in_compile_stack _RE_ARGS ((compile_stack_type
        -: 9323:						 compile_stack,
        -: 9324:						 regnum_t regnum));
        -: 9325:
        -: 9326:/* `regex_compile' compiles PATTERN (of length SIZE) according to SYNTAX.
        -: 9327:   Returns one of error codes defined in `regex.h', or zero for success.
        -: 9328:
        -: 9329:   Assumes the `allocated' (and perhaps `buffer') and `translate'
        -: 9330:   fields are set in BUFP on entry.
        -: 9331:
        -: 9332:   If it succeeds, results are put in BUFP (if it returns an error, the
        -: 9333:   contents of BUFP are undefined):
        -: 9334:     `buffer' is the compiled pattern;
        -: 9335:     `syntax' is set to SYNTAX;
        -: 9336:     `used' is set to the length of the compiled pattern;
        -: 9337:     `fastmap_accurate' is zero;
        -: 9338:     `re_nsub' is the number of subexpressions in PATTERN;
        -: 9339:     `not_bol' and `not_eol' are zero;
        -: 9340:
        -: 9341:   The `fastmap' and `newline_anchor' fields are neither
        -: 9342:   examined nor set.  */
        -: 9343:
        -: 9344:/* Return, freeing storage we allocated.  */
        -: 9345:#define FREE_STACK_RETURN(value)		\
        -: 9346:  return (free (compile_stack.stack), value)
        -: 9347:
        -: 9348:static reg_errcode_t
function regex_compile called 781 returned 100% blocks executed 52%
      781: 9349:regex_compile (pattern, size, syntax, bufp)
        -: 9350:     const char *pattern;
        -: 9351:     size_t size;
        -: 9352:     reg_syntax_t syntax;
        -: 9353:     struct re_pattern_buffer *bufp;
        -: 9354:{
        -: 9355:  /* We fetch characters from PATTERN here.  Even though PATTERN is
        -: 9356:     `char *' (i.e., signed), we declare these variables as unsigned, so
        -: 9357:     they can be reliably used as array indices.  */
        -: 9358:  register unsigned char c, c1;
        -: 9359:
        -: 9360:  /* A random temporary spot in PATTERN.  */
        -: 9361:  const char *p1;
        -: 9362:
        -: 9363:  /* Points to the end of the buffer, where we should append.  */
        -: 9364:  register unsigned char *b;
        -: 9365:
        -: 9366:  /* Keeps track of unclosed groups.  */
        -: 9367:  compile_stack_type compile_stack;
        -: 9368:
        -: 9369:  /* Points to the current (ending) position in the pattern.  */
      781: 9370:  const char *p = pattern;
      781: 9371:  const char *pend = pattern + size;
        -: 9372:
        -: 9373:  /* How to translate the characters in the pattern.  */
      781: 9374:  RE_TRANSLATE_TYPE translate = bufp->translate;
        -: 9375:
        -: 9376:  /* Address of the count-byte of the most recently inserted `exactn'
        -: 9377:     command.  This makes it possible to tell if a new exact-match
        -: 9378:     character can be added to that command or if the character requires
        -: 9379:     a new `exactn' command.  */
      781: 9380:  unsigned char *pending_exact = 0;
        -: 9381:
        -: 9382:  /* Address of start of the most recently finished expression.
        -: 9383:     This tells, e.g., postfix * where to find the start of its
        -: 9384:     operand.  Reset at the beginning of groups and alternatives.  */
      781: 9385:  unsigned char *laststart = 0;
        -: 9386:
        -: 9387:  /* Address of beginning of regexp, or inside of last group.  */
        -: 9388:  unsigned char *begalt;
        -: 9389:
        -: 9390:  /* Place in the uncompiled pattern (i.e., the {) to
        -: 9391:     which to go back if the interval is invalid.  */
        -: 9392:  const char *beg_interval;
        -: 9393:
        -: 9394:  /* Address of the place where a forward jump should go to the end of
        -: 9395:     the containing expression.  Each alternative of an `or' -- except the
        -: 9396:     last -- ends with a forward jump of this sort.  */
      781: 9397:  unsigned char *fixup_alt_jump = 0;
        -: 9398:
        -: 9399:  /* Counts open-groups as they are encountered.  Remembered for the
        -: 9400:     matching close-group on the compile stack, so the same register
        -: 9401:     number is put in the stop_memory as the start_memory.  */
      781: 9402:  regnum_t regnum = 0;
        -: 9403:
        -: 9404:#ifdef DEBUG
        -: 9405:  DEBUG_PRINT1 ("\nCompiling pattern: ");
        -: 9406:  if (debug)
        -: 9407:    {
        -: 9408:      unsigned debug_count;
        -: 9409:
        -: 9410:      for (debug_count = 0; debug_count < size; debug_count++)
        -: 9411:        putchar (pattern[debug_count]);
        -: 9412:      putchar ('\n');
        -: 9413:    }
        -: 9414:#endif /* DEBUG */
        -: 9415:
        -: 9416:  /* Initialize the compile stack.  */
      781: 9417:  compile_stack.stack = TALLOC (INIT_COMPILE_STACK_SIZE, compile_stack_elt_t);
call    0 returned 781
      781: 9418:  if (compile_stack.stack == NULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 781
    #####: 9419:    return REG_ESPACE;
        -: 9420:
      781: 9421:  compile_stack.size = INIT_COMPILE_STACK_SIZE;
      781: 9422:  compile_stack.avail = 0;
        -: 9423:
        -: 9424:  /* Initialize the pattern buffer.  */
      781: 9425:  bufp->syntax = syntax;
      781: 9426:  bufp->fastmap_accurate = 0;
      781: 9427:  bufp->not_bol = bufp->not_eol = 0;
        -: 9428:
        -: 9429:  /* Set `used' to zero, so that if we return an error, the pattern
        -: 9430:     printer (for debugging) will think there's no pattern.  We reset it
        -: 9431:     at the end.  */
      781: 9432:  bufp->used = 0;
        -: 9433:
        -: 9434:  /* Always count groups, whether or not bufp->no_sub is set.  */
      781: 9435:  bufp->re_nsub = 0;
        -: 9436:
        -: 9437:#if !defined emacs && !defined SYNTAX_TABLE
        -: 9438:  /* Initialize the syntax table.  */
      781: 9439:   init_syntax_once ();
call    0 returned 781
        -: 9440:#endif
        -: 9441:
      781: 9442:  if (bufp->allocated == 0)
branch  0 taken 781 (fallthrough)
branch  1 taken 0
        -: 9443:    {
      781: 9444:      if (bufp->buffer)
branch  0 taken 0 (fallthrough)
branch  1 taken 781
        -: 9445:	{ /* If zero allocated, but buffer is non-null, try to realloc
        -: 9446:             enough space.  This loses if buffer's address is bogus, but
        -: 9447:             that is the user's responsibility.  */
    #####: 9448:          RETALLOC (bufp->buffer, INIT_BUF_SIZE, unsigned char);
        -: 9449:        }
        -: 9450:      else
        -: 9451:        { /* Caller did not allocate a buffer.  Do it for them.  */
      781: 9452:          bufp->buffer = TALLOC (INIT_BUF_SIZE, unsigned char);
call    0 returned 781
        -: 9453:        }
     781*: 9454:      if (!bufp->buffer) FREE_STACK_RETURN (REG_ESPACE);
branch  0 taken 0 (fallthrough)
branch  1 taken 781
        -: 9455:
      781: 9456:      bufp->allocated = INIT_BUF_SIZE;
        -: 9457:    }
        -: 9458:
      781: 9459:  begalt = b = bufp->buffer;
        -: 9460:
        -: 9461:  /* Loop through the uncompiled pattern until we're at the end.  */
    54845: 9462:  while (p != pend)
branch  0 taken 54120
branch  1 taken 725 (fallthrough)
        -: 9463:    {
   54120*: 9464:      PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 54120
branch  2 taken 0 (fallthrough)
branch  3 taken 54120
        -: 9465:
    54120: 9466:      switch (c)
branch  0 taken 118
branch  1 taken 10
branch  2 taken 354
branch  3 taken 468
branch  4 taken 415
branch  5 taken 183
branch  6 taken 721
branch  7 taken 642
branch  8 taken 1881
branch  9 taken 188
branch 10 taken 186
branch 11 taken 1024
branch 12 taken 47930
        -: 9467:        {
      118: 9468:        case '^':
        -: 9469:          {
      118: 9470:            if (   /* If at start of pattern, it's an operator.  */
      118: 9471:                   p == pattern + 1
branch  0 taken 46 (fallthrough)
branch  1 taken 72
        -: 9472:                   /* If context independent, it's an operator.  */
       46: 9473:                || syntax & RE_CONTEXT_INDEP_ANCHORS
branch  0 taken 28 (fallthrough)
branch  1 taken 18
        -: 9474:                   /* Otherwise, depends on what's come before.  */
       28: 9475:                || at_begline_loc_p (pattern, p, syntax))
call    0 returned 28
branch  1 taken 26 (fallthrough)
branch  2 taken 2
     116*: 9476:              BUF_PUSH (begline);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 116 (fallthrough)
        -: 9477:            else
        2: 9478:              goto normal_char;
        -: 9479:          }
      116: 9480:          break;
        -: 9481:
        -: 9482:
       10: 9483:        case '$':
        -: 9484:          {
       10: 9485:            if (   /* If at end of pattern, it's an operator.  */
       10: 9486:                   p == pend
branch  0 taken 5 (fallthrough)
branch  1 taken 5
        -: 9487:                   /* If context independent, it's an operator.  */
        5: 9488:                || syntax & RE_CONTEXT_INDEP_ANCHORS
branch  0 taken 5 (fallthrough)
branch  1 taken 0
        -: 9489:                   /* Otherwise, depends on what's next.  */
        5: 9490:                || at_endline_loc_p (p, pend, syntax))
call    0 returned 5
branch  1 taken 0 (fallthrough)
branch  2 taken 5
       5*: 9491:               BUF_PUSH (endline);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 5 (fallthrough)
        -: 9492:             else
        5: 9493:               goto normal_char;
        -: 9494:           }
        5: 9495:           break;
        -: 9496:
        -: 9497:
      354: 9498:	case '+':
        -: 9499:        case '?':
      354: 9500:          if ((syntax & RE_BK_PLUS_QM)
branch  0 taken 176 (fallthrough)
branch  1 taken 178
      176: 9501:              || (syntax & RE_LIMITED_OPS))
branch  0 taken 0 (fallthrough)
branch  1 taken 176
      178: 9502:            goto normal_char;
      352: 9503:        handle_plus:
      820: 9504:        case '*':
        -: 9505:          /* If there is no previous pattern... */
      820: 9506:          if (!laststart)
branch  0 taken 45 (fallthrough)
branch  1 taken 775
        -: 9507:            {
       45: 9508:              if (syntax & RE_CONTEXT_INVALID_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 45
    #####: 9509:                FREE_STACK_RETURN (REG_BADRPT);
       45: 9510:              else if (!(syntax & RE_CONTEXT_INDEP_OPS))
branch  0 taken 5 (fallthrough)
branch  1 taken 40
        5: 9511:                goto normal_char;
        -: 9512:            }
        -: 9513:
        -: 9514:          {
        -: 9515:            /* Are we optimizing this jump?  */
      815: 9516:            boolean keep_string_p = false;
        -: 9517:
        -: 9518:            /* 1 means zero (many) matches is allowed.  */
      815: 9519:            char zero_times_ok = 0, many_times_ok = 0;
        -: 9520:
        -: 9521:            /* If there is a sequence of repetition chars, collapse it
        -: 9522:               down to just one (the right one).  We can't combine
        -: 9523:               interval operators with these because of, e.g., `a{2}*',
        -: 9524:               which should only match an even number of `a's.  */
        -: 9525:
        -: 9526:            for (;;)
        -: 9527:              {
      835: 9528:                zero_times_ok |= c != '+';
      835: 9529:                many_times_ok |= c != '?';
        -: 9530:
      835: 9531:                if (p == pend)
branch  0 taken 20 (fallthrough)
branch  1 taken 815
       20: 9532:                  break;
        -: 9533:
     815*: 9534:                PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 815
branch  2 taken 0 (fallthrough)
branch  3 taken 815
        -: 9535:
      815: 9536:                if (c == '*'
branch  0 taken 798 (fallthrough)
branch  1 taken 17
      798: 9537:                    || (!(syntax & RE_BK_PLUS_QM) && (c == '+' || c == '?')))
branch  0 taken 172 (fallthrough)
branch  1 taken 626
branch  2 taken 172 (fallthrough)
branch  3 taken 0
branch  4 taken 0 (fallthrough)
branch  5 taken 172
        -: 9538:                  ;
        -: 9539:
      798: 9540:                else if (syntax & RE_BK_PLUS_QM  &&  c == '\\')
branch  0 taken 626 (fallthrough)
branch  1 taken 172
branch  2 taken 29 (fallthrough)
branch  3 taken 597
        -: 9541:                  {
      29*: 9542:                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
branch  0 taken 0 (fallthrough)
branch  1 taken 29
        -: 9543:
      29*: 9544:                    PATFETCH (c1);
branch  0 taken 0 (fallthrough)
branch  1 taken 29
branch  2 taken 0 (fallthrough)
branch  3 taken 29
       29: 9545:                    if (!(c1 == '+' || c1 == '?'))
branch  0 taken 27 (fallthrough)
branch  1 taken 2
branch  2 taken 26 (fallthrough)
branch  3 taken 1
        -: 9546:                      {
       26: 9547:                        PATUNFETCH;
       26: 9548:                        PATUNFETCH;
       26: 9549:                        break;
        -: 9550:                      }
        -: 9551:
        3: 9552:                    c = c1;
        -: 9553:                  }
        -: 9554:                else
        -: 9555:                  {
      769: 9556:                    PATUNFETCH;
      769: 9557:                    break;
        -: 9558:                  }
        -: 9559:
        -: 9560:                /* If we get here, we found another repeat character.  */
        -: 9561:               }
        -: 9562:
        -: 9563:            /* Star, etc. applied to an empty pattern is equivalent
        -: 9564:               to an empty pattern.  */
      815: 9565:            if (!laststart)
branch  0 taken 40 (fallthrough)
branch  1 taken 775
       40: 9566:              break;
        -: 9567:
        -: 9568:            /* Now we know whether or not zero matches is allowed
        -: 9569:               and also whether or not two or more matches is allowed.  */
      775: 9570:            if (many_times_ok)
branch  0 taken 623 (fallthrough)
branch  1 taken 152
        -: 9571:              { /* More than one repetition is allowed, so put in at the
        -: 9572:                   end a backward relative jump from `b' to before the next
        -: 9573:                   jump we're going to put in below (which jumps from
        -: 9574:                   laststart to after this jump).
        -: 9575:
        -: 9576:                   But if we are at the `*' in the exact sequence `.*\n',
        -: 9577:                   insert an unconditional jump backwards to the .,
        -: 9578:                   instead of the beginning of the loop.  This way we only
        -: 9579:                   push a failure point once, instead of every time
        -: 9580:                   through the loop.  */
        -: 9581:                assert (p - 1 > pattern);
        -: 9582:
        -: 9583:                /* Allocate the space for the jump.  */
     624*: 9584:                GET_BUFFER_SPACE (3);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 0 (fallthrough)
branch  7 taken 1
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 1
branch 15 taken 623 (fallthrough)
        -: 9585:
        -: 9586:                /* We know we are not at the first character of the pattern,
        -: 9587:                   because laststart was nonzero.  And we've already
        -: 9588:                   incremented `p', by the way, to be the character after
        -: 9589:                   the `*'.  Do we have to do something analogous here
        -: 9590:                   for null bytes, because of RE_DOT_NOT_NULL?  */
     623*: 9591:                if (TRANSLATE (*(p - 2)) == TRANSLATE ('.')
branch  0 taken 0 (fallthrough)
branch  1 taken 623
branch  2 taken 0 (fallthrough)
branch  3 taken 623
branch  4 taken 0 (fallthrough)
branch  5 taken 623
    #####: 9592:		    && zero_times_ok
branch  0 never executed
branch  1 never executed
    #####: 9593:                    && p < pend && TRANSLATE (*p) == TRANSLATE ('\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####: 9594:                    && !(syntax & RE_DOT_NEWLINE))
branch  0 never executed
branch  1 never executed
        -: 9595:                  { /* We have .*\n.  */
    #####: 9596:                    STORE_JUMP (jump, b, laststart);
call    0 never executed
    #####: 9597:                    keep_string_p = true;
        -: 9598:                  }
        -: 9599:                else
        -: 9600:                  /* Anything else.  */
      623: 9601:                  STORE_JUMP (maybe_pop_jump, b, laststart - 3);
call    0 returned 623
        -: 9602:
        -: 9603:                /* We've added more stuff to the buffer.  */
      623: 9604:                b += 3;
        -: 9605:              }
        -: 9606:
        -: 9607:            /* On failure, jump from laststart to b + 3, which will be the
        -: 9608:               end of the buffer after this jump is inserted.  */
     788*: 9609:            GET_BUFFER_SPACE (3);
branch  0 taken 0 (fallthrough)
branch  1 taken 13
branch  2 taken 0 (fallthrough)
branch  3 taken 13
branch  4 taken 0 (fallthrough)
branch  5 taken 13
branch  6 taken 0 (fallthrough)
branch  7 taken 13
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 13
branch 15 taken 775 (fallthrough)
     775*: 9610:            INSERT_JUMP (keep_string_p ? on_failure_keep_string_jump
branch  0 taken 0 (fallthrough)
branch  1 taken 775
call    2 returned 775
        -: 9611:                                       : on_failure_jump,
        -: 9612:                         laststart, b + 3);
      775: 9613:            pending_exact = 0;
      775: 9614:            b += 3;
        -: 9615:
      775: 9616:            if (!zero_times_ok)
branch  0 taken 156 (fallthrough)
branch  1 taken 619
        -: 9617:              {
        -: 9618:                /* At least one repetition is required, so insert a
        -: 9619:                   `dummy_failure_jump' before the initial
        -: 9620:                   `on_failure_jump' instruction of the loop. This
        -: 9621:                   effects a skip over that instruction the first time
        -: 9622:                   we hit that loop.  */
     156*: 9623:                GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 156 (fallthrough)
      156: 9624:                INSERT_JUMP (dummy_failure_jump, laststart, laststart + 6);
call    0 returned 156
      156: 9625:                b += 3;
        -: 9626:              }
        -: 9627:            }
      775: 9628:	  break;
        -: 9629:
        -: 9630:
      415: 9631:	case '.':
      415: 9632:          laststart = b;
     415*: 9633:          BUF_PUSH (anychar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 415 (fallthrough)
      415: 9634:          break;
        -: 9635:
        -: 9636:
      183: 9637:        case '[':
        -: 9638:          {
      183: 9639:            boolean had_char_class = false;
        -: 9640:
      183: 9641:            if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
branch  0 taken 3 (fallthrough)
branch  1 taken 180
        -: 9642:
        -: 9643:            /* Ensure that we have enough space to push a charset: the
        -: 9644:               opcode, the length count, and the bitset; 34 bytes in all.  */
     264*: 9645:	    GET_BUFFER_SPACE (34);
branch  0 taken 0 (fallthrough)
branch  1 taken 84
branch  2 taken 0 (fallthrough)
branch  3 taken 84
branch  4 taken 0 (fallthrough)
branch  5 taken 84
branch  6 taken 0 (fallthrough)
branch  7 taken 84
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 84
branch 15 taken 180 (fallthrough)
        -: 9646:
      180: 9647:            laststart = b;
        -: 9648:
        -: 9649:            /* We test `*p == '^' twice, instead of using an if
        -: 9650:               statement, so we only need one BUF_PUSH.  */
     180*: 9651:            BUF_PUSH (*p == '^' ? charset_not : charset);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 180 (fallthrough)
branch 16 taken 7 (fallthrough)
branch 17 taken 173
      180: 9652:            if (*p == '^')
branch  0 taken 7 (fallthrough)
branch  1 taken 173
        7: 9653:              p++;
        -: 9654:
        -: 9655:            /* Remember the first position in the bracket expression.  */
      180: 9656:            p1 = p;
        -: 9657:
        -: 9658:            /* Push the number of bytes in the bitmap.  */
     180*: 9659:            BUF_PUSH ((1 << BYTEWIDTH) / BYTEWIDTH);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 180 (fallthrough)
        -: 9660:
        -: 9661:            /* Clear the whole map.  */
      180: 9662:            bzero (b, (1 << BYTEWIDTH) / BYTEWIDTH);
        -: 9663:
        -: 9664:            /* charset_not matches newline according to a syntax bit.  */
      180: 9665:            if ((re_opcode_t) b[-2] == charset_not
branch  0 taken 7 (fallthrough)
branch  1 taken 173
        7: 9666:                && (syntax & RE_HAT_LISTS_NOT_NEWLINE))
branch  0 taken 7 (fallthrough)
branch  1 taken 0
        7: 9667:              SET_LIST_BIT ('\n');
        -: 9668:
        -: 9669:            /* Read in characters and ranges, setting map bits.  */
        -: 9670:            for (;;)
        -: 9671:              {
     1652: 9672:                if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
branch  0 taken 3 (fallthrough)
branch  1 taken 1649
        -: 9673:
    1649*: 9674:                PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 1649
branch  2 taken 0 (fallthrough)
branch  3 taken 1649
        -: 9675:
        -: 9676:                /* \ might escape characters inside [...] and [^...].  */
    1649*: 9677:                if ((syntax & RE_BACKSLASH_ESCAPE_IN_LISTS) && c == '\\')
branch  0 taken 0 (fallthrough)
branch  1 taken 1649
branch  2 never executed
branch  3 never executed
        -: 9678:                  {
    #####: 9679:                    if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
branch  0 never executed
branch  1 never executed
        -: 9680:
    #####: 9681:                    PATFETCH (c1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9682:                    SET_LIST_BIT (c1);
    #####: 9683:                    continue;
        -: 9684:                  }
        -: 9685:
        -: 9686:                /* Could be the end of the bracket expression.  If it's
        -: 9687:                   not (i.e., when the bracket expression is `[]' so
        -: 9688:                   far), the ']' character bit gets set way below.  */
     1649: 9689:                if (c == ']' && p != p1 + 1)
branch  0 taken 168 (fallthrough)
branch  1 taken 1481
branch  2 taken 156 (fallthrough)
branch  3 taken 12
      156: 9690:                  break;
        -: 9691:
        -: 9692:                /* Look ahead to see if it's a range when the last thing
        -: 9693:                   was a character class.  */
     1493: 9694:                if (had_char_class && c == '-' && *p != ']')
branch  0 taken 6 (fallthrough)
branch  1 taken 1487
branch  2 taken 6 (fallthrough)
branch  3 taken 0
branch  4 taken 6 (fallthrough)
branch  5 taken 0
        6: 9695:                  FREE_STACK_RETURN (REG_ERANGE);
        -: 9696:
        -: 9697:                /* Look ahead to see if it's a range when the last thing
        -: 9698:                   was a character: if this is a hyphen not at the
        -: 9699:                   beginning or the end of a list, then it's the range
        -: 9700:                   operator.  */
     1487: 9701:                if (c == '-'
branch  0 taken 16 (fallthrough)
branch  1 taken 1471
       16: 9702:                    && !(p - 2 >= pattern && p[-2] == '[')
branch  0 taken 16 (fallthrough)
branch  1 taken 0
branch  2 taken 10 (fallthrough)
branch  3 taken 6
       10: 9703:                    && !(p - 3 >= pattern && p[-3] == '[' && p[-2] == '^')
branch  0 taken 10 (fallthrough)
branch  1 taken 0
branch  2 taken 3 (fallthrough)
branch  3 taken 7
branch  4 taken 3 (fallthrough)
branch  5 taken 0
       10: 9704:                    && *p != ']')
branch  0 taken 6 (fallthrough)
branch  1 taken 4
        3: 9705:                  {
        -: 9706:                    reg_errcode_t ret
        6: 9707:                      = compile_range (&p, pend, translate, syntax, b);
call    0 returned 6
        6: 9708:                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
branch  0 taken 3 (fallthrough)
branch  1 taken 3
        -: 9709:                  }
        -: 9710:
     1481: 9711:                else if (p[0] == '-' && p[1] != ']')
branch  0 taken 38 (fallthrough)
branch  1 taken 1443
branch  2 taken 34 (fallthrough)
branch  3 taken 4
       31: 9712:                  { /* This handles ranges made up of characters only.  */
        -: 9713:                    reg_errcode_t ret;
        -: 9714:
        -: 9715:		    /* Move past the `-'.  */
      34*: 9716:                    PATFETCH (c1);
branch  0 taken 0 (fallthrough)
branch  1 taken 34
branch  2 taken 0 (fallthrough)
branch  3 taken 34
        -: 9717:
       34: 9718:                    ret = compile_range (&p, pend, translate, syntax, b);
call    0 returned 34
       34: 9719:                    if (ret != REG_NOERROR) FREE_STACK_RETURN (ret);
branch  0 taken 3 (fallthrough)
branch  1 taken 31
        -: 9720:                  }
        -: 9721:
        -: 9722:                /* See if we're at the beginning of a possible character
        -: 9723:                   class.  */
        -: 9724:
     1447: 9725:                else if (syntax & RE_CHAR_CLASSES && c == '[' && *p == ':')
branch  0 taken 1447 (fallthrough)
branch  1 taken 0
branch  2 taken 41 (fallthrough)
branch  3 taken 1406
branch  4 taken 34 (fallthrough)
branch  5 taken 7
       25: 9726:                  { /* Leave room for the null.  */
        -: 9727:                    char str[CHAR_CLASS_MAX_LENGTH + 1];
        -: 9728:
      43*: 9729:                    PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 34
branch  2 taken 0 (fallthrough)
branch  3 taken 34
       34: 9730:                    c1 = 0;
        -: 9731:
        -: 9732:                    /* If pattern is `[[:'.  */
       34: 9733:                    if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
branch  0 taken 3 (fallthrough)
branch  1 taken 31
        -: 9734:
        -: 9735:                    for (;;)
        -: 9736:                      {
     181*: 9737:                        PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 181
branch  2 taken 0 (fallthrough)
branch  3 taken 181
      181: 9738:                        if ((c == ':' && *p == ']') || p == pend)
branch  0 taken 31 (fallthrough)
branch  1 taken 150
branch  2 taken 0 (fallthrough)
branch  3 taken 31
branch  4 taken 150 (fallthrough)
branch  5 taken 0
        -: 9739:                          break;
      150: 9740:			if (c1 < CHAR_CLASS_MAX_LENGTH)
branch  0 taken 149 (fallthrough)
branch  1 taken 1
      149: 9741:			  str[c1++] = c;
        -: 9742:			else
        -: 9743:			  /* This is in any case an invalid class name.  */
        1: 9744:			  str[0] = '\0';
        -: 9745:                      }
       31: 9746:                    str[c1] = '\0';
        -: 9747:
        -: 9748:                    /* If isn't a word bracketed by `[:' and `:]':
        -: 9749:                       undo the ending character, the letters, and leave
        -: 9750:                       the leading `:' and `[' (but set bits for them).  */
       31: 9751:                    if (c == ':' && *p == ']')
branch  0 taken 31 (fallthrough)
branch  1 taken 0
branch  2 taken 31 (fallthrough)
branch  3 taken 0
       25: 9752:                      {
        -: 9753:#if defined _LIBC || WIDE_CHAR_SUPPORT
        -: 9754:                        boolean is_lower = STREQ (str, "lower");
        -: 9755:                        boolean is_upper = STREQ (str, "upper");
        -: 9756:			wctype_t wt;
        -: 9757:                        int ch;
        -: 9758:
        -: 9759:			wt = IS_CHAR_CLASS (str);
        -: 9760:			if (wt == 0)
        -: 9761:			  FREE_STACK_RETURN (REG_ECTYPE);
        -: 9762:
        -: 9763:                        /* Throw away the ] at the end of the character
        -: 9764:                           class.  */
        -: 9765:                        PATFETCH (c);
        -: 9766:
        -: 9767:                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
        -: 9768:
        -: 9769:                        for (ch = 0; ch < 1 << BYTEWIDTH; ++ch)
        -: 9770:			  {
        -: 9771:# ifdef _LIBC
        -: 9772:			    if (__iswctype (__btowc (ch), wt))
        -: 9773:			      SET_LIST_BIT (ch);
        -: 9774:# else
        -: 9775:			    if (iswctype (btowc (ch), wt))
        -: 9776:			      SET_LIST_BIT (ch);
        -: 9777:# endif
        -: 9778:
        -: 9779:			    if (translate && (is_upper || is_lower)
        -: 9780:				&& (ISUPPER (ch) || ISLOWER (ch)))
        -: 9781:			      SET_LIST_BIT (ch);
        -: 9782:			  }
        -: 9783:
        -: 9784:                        had_char_class = true;
        -: 9785:#else
        -: 9786:                        int ch;
       31: 9787:                        boolean is_alnum = STREQ (str, "alnum");
       31: 9788:                        boolean is_alpha = STREQ (str, "alpha");
       31: 9789:                        boolean is_blank = STREQ (str, "blank");
       31: 9790:                        boolean is_cntrl = STREQ (str, "cntrl");
       31: 9791:                        boolean is_digit = STREQ (str, "digit");
       31: 9792:                        boolean is_graph = STREQ (str, "graph");
       31: 9793:                        boolean is_lower = STREQ (str, "lower");
       31: 9794:                        boolean is_print = STREQ (str, "print");
       31: 9795:                        boolean is_punct = STREQ (str, "punct");
       31: 9796:                        boolean is_space = STREQ (str, "space");
       31: 9797:                        boolean is_upper = STREQ (str, "upper");
       31: 9798:                        boolean is_xdigit = STREQ (str, "xdigit");
        -: 9799:
       31: 9800:                        if (!IS_CHAR_CLASS (str))
branch  0 taken 28 (fallthrough)
branch  1 taken 3
branch  2 taken 27 (fallthrough)
branch  3 taken 1
branch  4 taken 26 (fallthrough)
branch  5 taken 1
branch  6 taken 20 (fallthrough)
branch  7 taken 6
branch  8 taken 9 (fallthrough)
branch  9 taken 11
branch 10 taken 8 (fallthrough)
branch 11 taken 1
branch 12 taken 7 (fallthrough)
branch 13 taken 1
branch 14 taken 6 (fallthrough)
branch 15 taken 1
branch 16 taken 5 (fallthrough)
branch 17 taken 1
branch 18 taken 4 (fallthrough)
branch 19 taken 1
branch 20 taken 3 (fallthrough)
branch 21 taken 1
branch 22 taken 3 (fallthrough)
branch 23 taken 0
        3: 9801:			  FREE_STACK_RETURN (REG_ECTYPE);
        -: 9802:
        -: 9803:                        /* Throw away the ] at the end of the character
        -: 9804:                           class.  */
      28*: 9805:                        PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 28
branch  2 taken 0 (fallthrough)
branch  3 taken 28
        -: 9806:
       28: 9807:                        if (p == pend) FREE_STACK_RETURN (REG_EBRACK);
branch  0 taken 3 (fallthrough)
branch  1 taken 25
        -: 9808:
     6425: 9809:                        for (ch = 0; ch < 1 << BYTEWIDTH; ch++)
branch  0 taken 6400
branch  1 taken 25 (fallthrough)
        -: 9810:                          {
        -: 9811:			    /* This was split into 3 if's to
        -: 9812:			       avoid an arbitrary limit in some compiler.  */
     6400: 9813:                            if (   (is_alnum  && ISALNUM (ch))
branch  0 taken 2560 (fallthrough)
branch  1 taken 3840
branch  2 taken 1940 (fallthrough)
branch  3 taken 620
     5780: 9814:                                || (is_alpha  && ISALPHA (ch))
branch  0 taken 512 (fallthrough)
branch  1 taken 5268
branch  2 taken 408 (fallthrough)
branch  3 taken 104
    5676*: 9815:                                || (is_blank  && ISBLANK (ch))
branch  0 taken 0 (fallthrough)
branch  1 taken 5676
branch  2 never executed
branch  3 never executed
     5676: 9816:                                || (is_cntrl  && ISCNTRL (ch)))
branch  0 taken 256 (fallthrough)
branch  1 taken 5420
branch  2 taken 33 (fallthrough)
branch  3 taken 223
      757: 9817:			      SET_LIST_BIT (ch);
     6400: 9818:			    if (   (is_digit  && ISDIGIT (ch))
branch  0 taken 1280 (fallthrough)
branch  1 taken 5120
branch  2 taken 1230 (fallthrough)
branch  3 taken 50
     6350: 9819:                                || (is_graph  && ISGRAPH (ch))
branch  0 taken 256 (fallthrough)
branch  1 taken 6094
branch  2 taken 162 (fallthrough)
branch  3 taken 94
     6256: 9820:                                || (is_lower  && ISLOWER (ch))
branch  0 taken 256 (fallthrough)
branch  1 taken 6000
branch  2 taken 230 (fallthrough)
branch  3 taken 26
     6230: 9821:                                || (is_print  && ISPRINT (ch)))
branch  0 taken 256 (fallthrough)
branch  1 taken 5974
branch  2 taken 95 (fallthrough)
branch  3 taken 161
      265: 9822:			      SET_LIST_BIT (ch);
     6400: 9823:			    if (   (is_punct  && ISPUNCT (ch))
branch  0 taken 256 (fallthrough)
branch  1 taken 6144
branch  2 taken 224 (fallthrough)
branch  3 taken 32
     6368: 9824:                                || (is_space  && ISSPACE (ch))
branch  0 taken 256 (fallthrough)
branch  1 taken 6112
branch  2 taken 250 (fallthrough)
branch  3 taken 6
     6362: 9825:                                || (is_upper  && ISUPPER (ch))
branch  0 taken 256 (fallthrough)
branch  1 taken 6106
branch  2 taken 230 (fallthrough)
branch  3 taken 26
     6336: 9826:                                || (is_xdigit && ISXDIGIT (ch)))
branch  0 taken 256 (fallthrough)
branch  1 taken 6080
branch  2 taken 22 (fallthrough)
branch  3 taken 234
       86: 9827:			      SET_LIST_BIT (ch);
    6400*: 9828:			    if (   translate && (is_upper || is_lower)
branch  0 taken 0 (fallthrough)
branch  1 taken 6400
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####: 9829:				&& (ISUPPER (ch) || ISLOWER (ch)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####: 9830:			      SET_LIST_BIT (ch);
        -: 9831:                          }
       25: 9832:                        had_char_class = true;
        -: 9833:#endif	/* libc || wctype.h */
        -: 9834:                      }
        -: 9835:                    else
        -: 9836:                      {
    #####: 9837:                        c1++;
    #####: 9838:                        while (c1--)
branch  0 never executed
branch  1 never executed
    #####: 9839:                          PATUNFETCH;
    #####: 9840:                        SET_LIST_BIT ('[');
    #####: 9841:                        SET_LIST_BIT (':');
    #####: 9842:                        had_char_class = false;
        -: 9843:                      }
        -: 9844:                  }
        -: 9845:                else
        -: 9846:                  {
     1413: 9847:                    had_char_class = false;
     1413: 9848:                    SET_LIST_BIT (c);
        -: 9849:                  }
        -: 9850:              }
        -: 9851:
        -: 9852:            /* Discard any (non)matching list bytes that are all 0 at the
        -: 9853:               end of the map.  Decrease the map-length byte too.  */
     3284: 9854:            while ((int) b[-1] > 0 && b[b[-1] - 1] == 0)
branch  0 taken 3281 (fallthrough)
branch  1 taken 3
branch  2 taken 3128
branch  3 taken 153 (fallthrough)
     3128: 9855:              b[-1]--;
      156: 9856:            b += b[-1];
        -: 9857:          }
      156: 9858:          break;
        -: 9859:
        -: 9860:
      721: 9861:	case '(':
      721: 9862:          if (syntax & RE_NO_BK_PARENS)
branch  0 taken 60 (fallthrough)
branch  1 taken 661
       60: 9863:            goto handle_open;
        -: 9864:          else
      661: 9865:            goto normal_char;
        -: 9866:
        -: 9867:
      642: 9868:        case ')':
      642: 9869:          if (syntax & RE_NO_BK_PARENS)
branch  0 taken 60 (fallthrough)
branch  1 taken 582
       60: 9870:            goto handle_close;
        -: 9871:          else
      582: 9872:            goto normal_char;
        -: 9873:
        -: 9874:
     1881: 9875:        case '\n':
     1881: 9876:          if (syntax & RE_NEWLINE_ALT)
branch  0 taken 1881 (fallthrough)
branch  1 taken 0
     1881: 9877:            goto handle_alt;
        -: 9878:          else
    #####: 9879:            goto normal_char;
        -: 9880:
        -: 9881:
      188: 9882:	case '|':
      188: 9883:          if (syntax & RE_NO_BK_VBAR)
branch  0 taken 130 (fallthrough)
branch  1 taken 58
      130: 9884:            goto handle_alt;
        -: 9885:          else
       58: 9886:            goto normal_char;
        -: 9887:
        -: 9888:
      186: 9889:        case '{':
      186: 9890:           if (syntax & RE_INTERVALS && syntax & RE_NO_BK_BRACES)
branch  0 taken 186 (fallthrough)
branch  1 taken 0
branch  2 taken 91 (fallthrough)
branch  3 taken 95
       91: 9891:             goto handle_interval;
        -: 9892:           else
       95: 9893:             goto normal_char;
        -: 9894:
        -: 9895:
     1024: 9896:        case '\\':
     1024: 9897:          if (p == pend) FREE_STACK_RETURN (REG_EESCAPE);
branch  0 taken 6 (fallthrough)
branch  1 taken 1018
        -: 9898:
        -: 9899:          /* Do not translate the character after the \, so that we can
        -: 9900:             distinguish, e.g., \B from \b, even if we normally would
        -: 9901:             translate, e.g., B to b.  */
    1018*: 9902:          PATFETCH_RAW (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 1018
        -: 9903:
     1018: 9904:          switch (c)
branch  0 taken 139
branch  1 taken 49
branch  2 taken 147
branch  3 taken 101
branch  4 taken 1
branch  5 taken 3
branch  6 taken 115
branch  7 taken 2
branch  8 taken 140
branch  9 taken 1
branch 10 taken 3
branch 11 taken 3
branch 12 taken 9
branch 13 taken 211
branch 14 taken 94
        -: 9905:            {
      139: 9906:            case '(':
      139: 9907:              if (syntax & RE_NO_BK_PARENS)
branch  0 taken 90 (fallthrough)
branch  1 taken 49
       90: 9908:                goto normal_backslash;
        -: 9909:
       49: 9910:            handle_open:
      109: 9911:              bufp->re_nsub++;
      109: 9912:              regnum++;
        -: 9913:
      109: 9914:              if (COMPILE_STACK_FULL)
branch  0 taken 0 (fallthrough)
branch  1 taken 109
        -: 9915:                {
    #####: 9916:                  RETALLOC (compile_stack.stack, compile_stack.size << 1,
        -: 9917:                            compile_stack_elt_t);
    #####: 9918:                  if (compile_stack.stack == NULL) return REG_ESPACE;
branch  0 never executed
branch  1 never executed
        -: 9919:
    #####: 9920:                  compile_stack.size <<= 1;
        -: 9921:                }
        -: 9922:
        -: 9923:              /* These are the values to restore when we hit end of this
        -: 9924:                 group.  They are all relative offsets, so that if the
        -: 9925:                 whole pattern moves because of realloc, they will still
        -: 9926:                 be valid.  */
      109: 9927:              COMPILE_STACK_TOP.begalt_offset = begalt - bufp->buffer;
      109: 9928:              COMPILE_STACK_TOP.fixup_alt_jump
      109: 9929:                = fixup_alt_jump ? fixup_alt_jump - bufp->buffer + 1 : 0;
branch  0 taken 33 (fallthrough)
branch  1 taken 76
      109: 9930:              COMPILE_STACK_TOP.laststart_offset = b - bufp->buffer;
      109: 9931:              COMPILE_STACK_TOP.regnum = regnum;
        -: 9932:
        -: 9933:              /* We will eventually replace the 0 with the number of
        -: 9934:                 groups inner to this one.  But do not push a
        -: 9935:                 start_memory for groups beyond the last one we can
        -: 9936:                 represent in the compiled pattern.  */
      109: 9937:              if (regnum <= MAX_REGNUM)
branch  0 taken 109 (fallthrough)
branch  1 taken 0
        -: 9938:                {
      109: 9939:                  COMPILE_STACK_TOP.inner_group_offset = b - bufp->buffer + 2;
     109*: 9940:                  BUF_PUSH_3 (start_memory, regnum, 0);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 109 (fallthrough)
        -: 9941:                }
        -: 9942:
      109: 9943:              compile_stack.avail++;
        -: 9944:
      109: 9945:              fixup_alt_jump = 0;
      109: 9946:              laststart = 0;
      109: 9947:              begalt = b;
        -: 9948:	      /* If we've reached MAX_REGNUM groups, then this open
        -: 9949:		 won't actually generate any code, so we'll have to
        -: 9950:		 clear pending_exact explicitly.  */
      109: 9951:	      pending_exact = 0;
      109: 9952:              break;
        -: 9953:
        -: 9954:
       49: 9955:            case ')':
      49*: 9956:              if (syntax & RE_NO_BK_PARENS) goto normal_backslash;
branch  0 taken 0 (fallthrough)
branch  1 taken 49
        -: 9957:
       49: 9958:              if (COMPILE_STACK_EMPTY)
branch  0 taken 3 (fallthrough)
branch  1 taken 46
        -: 9959:		{
        3: 9960:		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####: 9961:		    goto normal_backslash;
        -: 9962:		  else
        3: 9963:		    FREE_STACK_RETURN (REG_ERPAREN);
        -: 9964:		}
        -: 9965:
       46: 9966:            handle_close:
      106: 9967:              if (fixup_alt_jump)
branch  0 taken 41 (fallthrough)
branch  1 taken 65
        -: 9968:                { /* Push a dummy failure point at the end of the
        -: 9969:                     alternative for a possible future
        -: 9970:                     `pop_failure_jump' to pop.  See comments at
        -: 9971:                     `push_dummy_failure' in `re_match_2'.  */
      42*: 9972:                  BUF_PUSH (push_dummy_failure);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 0 (fallthrough)
branch  7 taken 1
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 1
branch 15 taken 41 (fallthrough)
        -: 9973:
        -: 9974:                  /* We allocated space for this jump when we assigned
        -: 9975:                     to `fixup_alt_jump', in the `handle_alt' case below.  */
       41: 9976:                  STORE_JUMP (jump_past_alt, fixup_alt_jump, b - 1);
call    0 returned 41
        -: 9977:                }
        -: 9978:
        -: 9979:              /* See similar code for backslashed left paren above.  */
      106: 9980:              if (COMPILE_STACK_EMPTY)
branch  0 taken 0 (fallthrough)
branch  1 taken 106
        -: 9981:		{
    #####: 9982:		  if (syntax & RE_UNMATCHED_RIGHT_PAREN_ORD)
branch  0 never executed
branch  1 never executed
    #####: 9983:		    goto normal_char;
        -: 9984:		  else
    #####: 9985:		    FREE_STACK_RETURN (REG_ERPAREN);
        -: 9986:		}
        -: 9987:
        -: 9988:              /* Since we just checked for an empty stack above, this
        -: 9989:                 ``can't happen''.  */
        -: 9990:              assert (compile_stack.avail != 0);
        -: 9991:              {
        -: 9992:                /* We don't just want to restore into `regnum', because
        -: 9993:                   later groups should continue to be numbered higher,
        -: 9994:                   as in `(ab)c(de)' -- the second group is #2.  */
        -: 9995:                regnum_t this_group_regnum;
        -: 9996:
      106: 9997:                compile_stack.avail--;
      106: 9998:                begalt = bufp->buffer + COMPILE_STACK_TOP.begalt_offset;
        -: 9999:                fixup_alt_jump
      212:10000:                  = COMPILE_STACK_TOP.fixup_alt_jump
       33:10001:                    ? bufp->buffer + COMPILE_STACK_TOP.fixup_alt_jump - 1
      106:10002:                    : 0;
branch  0 taken 33 (fallthrough)
branch  1 taken 73
      106:10003:                laststart = bufp->buffer + COMPILE_STACK_TOP.laststart_offset;
      106:10004:                this_group_regnum = COMPILE_STACK_TOP.regnum;
        -:10005:		/* If we've reached MAX_REGNUM groups, then this open
        -:10006:		   won't actually generate any code, so we'll have to
        -:10007:		   clear pending_exact explicitly.  */
      106:10008:		pending_exact = 0;
        -:10009:
        -:10010:                /* We're at the end of the group, so now we know how many
        -:10011:                   groups were inside this one.  */
      106:10012:                if (this_group_regnum <= MAX_REGNUM)
branch  0 taken 106 (fallthrough)
branch  1 taken 0
        -:10013:                  {
      106:10014:                    unsigned char *inner_group_loc
      106:10015:                      = bufp->buffer + COMPILE_STACK_TOP.inner_group_offset;
        -:10016:
      106:10017:                    *inner_group_loc = regnum - this_group_regnum;
     111*:10018:                    BUF_PUSH_3 (stop_memory, this_group_regnum,
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 taken 0 (fallthrough)
branch  3 taken 5
branch  4 taken 0 (fallthrough)
branch  5 taken 5
branch  6 taken 0 (fallthrough)
branch  7 taken 5
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 5
branch 15 taken 106 (fallthrough)
        -:10019:                                regnum - this_group_regnum);
        -:10020:                  }
        -:10021:              }
      106:10022:              break;
        -:10023:
        -:10024:
      147:10025:            case '|':					/* `\|'.  */
      147:10026:              if (syntax & RE_LIMITED_OPS || syntax & RE_NO_BK_VBAR)
branch  0 taken 147 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 147
    #####:10027:                goto normal_backslash;
      147:10028:            handle_alt:
     2158:10029:              if (syntax & RE_LIMITED_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 2158
    #####:10030:                goto normal_char;
        -:10031:
        -:10032:              /* Insert before the previous alternative a jump which
        -:10033:                 jumps to this alternative if the former fails.  */
    2158*:10034:              GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 2158 (fallthrough)
     2158:10035:              INSERT_JUMP (on_failure_jump, begalt, b + 6);
call    0 returned 2158
     2158:10036:              pending_exact = 0;
     2158:10037:              b += 3;
        -:10038:
        -:10039:              /* The alternative before this one has a jump after it
        -:10040:                 which gets executed if it gets matched.  Adjust that
        -:10041:                 jump so it will jump to this alternative's analogous
        -:10042:                 jump (put in below, which in turn will jump to the next
        -:10043:                 (if any) alternative's such jump, etc.).  The last such
        -:10044:                 jump jumps to the correct final destination.  A picture:
        -:10045:                          _____ _____
        -:10046:                          |   | |   |
        -:10047:                          |   v |   v
        -:10048:                         a | b   | c
        -:10049:
        -:10050:                 If we are at `b', then fixup_alt_jump right now points to a
        -:10051:                 three-byte space after `a'.  We'll put in the jump, set
        -:10052:                 fixup_alt_jump to right after `b', and leave behind three
        -:10053:                 bytes which we'll fill in when we get to after `c'.  */
        -:10054:
     2158:10055:              if (fixup_alt_jump)
branch  0 taken 1877 (fallthrough)
branch  1 taken 281
     1877:10056:                STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
call    0 returned 1877
        -:10057:
        -:10058:              /* Mark and leave space for a jump after this alternative,
        -:10059:                 to be filled in later either by next alternative or
        -:10060:                 when know we're at the end of a series of alternatives.  */
     2158:10061:              fixup_alt_jump = b;
    2159*:10062:              GET_BUFFER_SPACE (3);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
branch  4 taken 0 (fallthrough)
branch  5 taken 1
branch  6 taken 0 (fallthrough)
branch  7 taken 1
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 1
branch 15 taken 2158 (fallthrough)
     2158:10063:              b += 3;
        -:10064:
     2158:10065:              laststart = 0;
     2158:10066:              begalt = b;
     2158:10067:              break;
        -:10068:
        -:10069:
      101:10070:            case '{':
        -:10071:              /* If \{ is a literal.  */
      101:10072:              if (!(syntax & RE_INTERVALS)
branch  0 taken 101 (fallthrough)
branch  1 taken 0
        -:10073:                     /* If we're at `\{' and it's not the open-interval
        -:10074:                        operator.  */
      101:10075:                  || ((syntax & RE_INTERVALS) && (syntax & RE_NO_BK_BRACES))
branch  0 taken 101 (fallthrough)
branch  1 taken 0
branch  2 taken 101 (fallthrough)
branch  3 taken 0
      101:10076:                  || (p - 2 == pattern  &&  p == pend))
branch  0 taken 6 (fallthrough)
branch  1 taken 95
branch  2 taken 5 (fallthrough)
branch  3 taken 1
        1:10077:                goto normal_backslash;
        -:10078:
      100:10079:            handle_interval:
        -:10080:              {
        -:10081:                /* If got here, then the syntax allows intervals.  */
        -:10082:
        -:10083:                /* At least (most) this many matches must be made.  */
      191:10084:                int lower_bound = -1, upper_bound = -1;
        -:10085:
      191:10086:                beg_interval = p - 1;
        -:10087:
      191:10088:                if (p == pend)
branch  0 taken 2 (fallthrough)
branch  1 taken 189
        -:10089:                  {
        2:10090:                    if (syntax & RE_NO_BK_BRACES)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:10091:                      goto unfetch_interval;
        -:10092:                    else
        2:10093:                      FREE_STACK_RETURN (REG_EBRACE);
        -:10094:                  }
        -:10095:
     378*:10096:                GET_UNSIGNED_NUMBER (lower_bound);
branch  0 taken 189 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 189
branch  4 taken 0 (fallthrough)
branch  5 taken 189
branch  6 taken 188 (fallthrough)
branch  7 taken 3
branch  8 taken 2 (fallthrough)
branch  9 taken 189
branch 10 taken 0 (fallthrough)
branch 11 taken 189
branch 12 taken 0 (fallthrough)
branch 13 taken 189
branch 14 taken 364 (fallthrough)
branch 15 taken 14
branch 16 taken 191
branch 17 taken 173 (fallthrough)
        -:10097:
      189:10098:                if (c == ',')
branch  0 taken 14 (fallthrough)
branch  1 taken 175
        -:10099:                  {
      29*:10100:                    GET_UNSIGNED_NUMBER (upper_bound);
branch  0 taken 14 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 14
branch  4 taken 0 (fallthrough)
branch  5 taken 14
branch  6 taken 13 (fallthrough)
branch  7 taken 3
branch  8 taken 1 (fallthrough)
branch  9 taken 15
branch 10 taken 0 (fallthrough)
branch 11 taken 15
branch 12 taken 0 (fallthrough)
branch 13 taken 15
branch 14 taken 29 (fallthrough)
branch 15 taken 0
branch 16 taken 16
branch 17 taken 13 (fallthrough)
       14:10101:                    if (upper_bound < 0) upper_bound = RE_DUP_MAX;
branch  0 taken 1 (fallthrough)
branch  1 taken 13
        -:10102:                  }
        -:10103:                else
        -:10104:                  /* Interval such as `{1}' => match exactly once. */
      175:10105:                  upper_bound = lower_bound;
        -:10106:
      189:10107:                if (lower_bound < 0 || upper_bound > RE_DUP_MAX
branch  0 taken 188 (fallthrough)
branch  1 taken 1
branch  2 taken 188 (fallthrough)
branch  3 taken 0
      188:10108:                    || lower_bound > upper_bound)
branch  0 taken 2 (fallthrough)
branch  1 taken 186
        -:10109:                  {
        3:10110:                    if (syntax & RE_NO_BK_BRACES)
branch  0 taken 1 (fallthrough)
branch  1 taken 2
        1:10111:                      goto unfetch_interval;
        -:10112:                    else
        2:10113:                      FREE_STACK_RETURN (REG_BADBR);
        -:10114:                  }
        -:10115:
      186:10116:                if (!(syntax & RE_NO_BK_BRACES))
branch  0 taken 96 (fallthrough)
branch  1 taken 90
        -:10117:                  {
       96:10118:                    if (c != '\\') FREE_STACK_RETURN (REG_EBRACE);
branch  0 taken 3 (fallthrough)
branch  1 taken 93
        -:10119:
      93*:10120:                    PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 93
branch  2 taken 0 (fallthrough)
branch  3 taken 93
        -:10121:                  }
        -:10122:
      183:10123:                if (c != '}')
branch  0 taken 3 (fallthrough)
branch  1 taken 180
        -:10124:                  {
        3:10125:                    if (syntax & RE_NO_BK_BRACES)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:10126:                      goto unfetch_interval;
        -:10127:                    else
        3:10128:                      FREE_STACK_RETURN (REG_BADBR);
        -:10129:                  }
        -:10130:
        -:10131:                /* We just parsed a valid interval.  */
        -:10132:
        -:10133:                /* If it's invalid to have no preceding re.  */
      180:10134:                if (!laststart)
branch  0 taken 20 (fallthrough)
branch  1 taken 160
        -:10135:                  {
       20:10136:                    if (syntax & RE_CONTEXT_INVALID_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 20
    #####:10137:                      FREE_STACK_RETURN (REG_BADRPT);
       20:10138:                    else if (syntax & RE_CONTEXT_INDEP_OPS)
branch  0 taken 20 (fallthrough)
branch  1 taken 0
       20:10139:                      laststart = b;
        -:10140:                    else
    #####:10141:                      goto unfetch_interval;
        -:10142:                  }
        -:10143:
        -:10144:                /* If the upper bound is zero, don't want to succeed at
        -:10145:                   all; jump from `laststart' to `b + 3', which will be
        -:10146:                   the end of the buffer after we insert the jump.  */
      180:10147:                 if (upper_bound == 0)
branch  0 taken 3 (fallthrough)
branch  1 taken 177
        -:10148:                   {
       3*:10149:                     GET_BUFFER_SPACE (3);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 3 (fallthrough)
        3:10150:                     INSERT_JUMP (jump, laststart, b + 3);
call    0 returned 3
        3:10151:                     b += 3;
        -:10152:                   }
        -:10153:
        -:10154:                 /* Otherwise, we have a nontrivial interval.  When
        -:10155:                    we're all done, the pattern will look like:
        -:10156:                      set_number_at <jump count> <upper bound>
        -:10157:                      set_number_at <succeed_n count> <lower bound>
        -:10158:                      succeed_n <after jump addr> <succeed_n count>
        -:10159:                      <body of loop>
        -:10160:                      jump_n <succeed_n addr> <jump count>
        -:10161:                    (The upper bound and `jump_n' are omitted if
        -:10162:                    `upper_bound' is 1, though.)  */
        -:10163:                 else
        -:10164:                   { /* If the upper bound is > 1, we need to insert
        -:10165:                        more at the end of the loop.  */
      177:10166:                     unsigned nbytes = 10 + (upper_bound > 1) * 10;
branch  0 taken 8 (fallthrough)
branch  1 taken 169
        -:10167:
     181*:10168:                     GET_BUFFER_SPACE (nbytes);
branch  0 taken 0 (fallthrough)
branch  1 taken 4
branch  2 taken 0 (fallthrough)
branch  3 taken 4
branch  4 taken 0 (fallthrough)
branch  5 taken 4
branch  6 taken 0 (fallthrough)
branch  7 taken 4
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 4
branch 15 taken 177 (fallthrough)
        -:10169:
        -:10170:                     /* Initialize lower bound of the `succeed_n', even
        -:10171:                        though it will be set during matching by its
        -:10172:                        attendant `set_number_at' (inserted next),
        -:10173:                        because `re_compile_fastmap' needs to know.
        -:10174:                        Jump to the `jump_n' we might insert below.  */
      177:10175:                     INSERT_JUMP2 (succeed_n, laststart,
branch  0 taken 8 (fallthrough)
branch  1 taken 169
call    2 returned 177
        -:10176:                                   b + 5 + (upper_bound > 1) * 5,
        -:10177:                                   lower_bound);
      177:10178:                     b += 5;
        -:10179:
        -:10180:                     /* Code to initialize the lower bound.  Insert
        -:10181:                        before the `succeed_n'.  The `5' is the last two
        -:10182:                        bytes of this `set_number_at', plus 3 bytes of
        -:10183:                        the following `succeed_n'.  */
      177:10184:                     insert_op2 (set_number_at, laststart, 5, lower_bound, b);
call    0 returned 177
      177:10185:                     b += 5;
        -:10186:
      177:10187:                     if (upper_bound > 1)
branch  0 taken 8 (fallthrough)
branch  1 taken 169
        -:10188:                       { /* More than one repetition is allowed, so
        -:10189:                            append a backward jump to the `succeed_n'
        -:10190:                            that starts this interval.
        -:10191:
        -:10192:                            When we've reached this during matching,
        -:10193:                            we'll have matched the interval once, so
        -:10194:                            jump back only `upper_bound - 1' times.  */
        8:10195:                         STORE_JUMP2 (jump_n, b, laststart + 5,
call    0 returned 8
        -:10196:                                      upper_bound - 1);
        8:10197:                         b += 5;
        -:10198:
        -:10199:                         /* The location we want to set is the second
        -:10200:                            parameter of the `jump_n'; that is `b-2' as
        -:10201:                            an absolute address.  `laststart' will be
        -:10202:                            the `set_number_at' we're about to insert;
        -:10203:                            `laststart+3' the number to set, the source
        -:10204:                            for the relative address.  But we are
        -:10205:                            inserting into the middle of the pattern --
        -:10206:                            so everything is getting moved up by 5.
        -:10207:                            Conclusion: (b - 2) - (laststart + 3) + 5,
        -:10208:                            i.e., b - laststart.
        -:10209:
        -:10210:                            We insert this at the beginning of the loop
        -:10211:                            so that if we fail during matching, we'll
        -:10212:                            reinitialize the bounds.  */
        8:10213:                         insert_op2 (set_number_at, laststart, b - laststart,
call    0 returned 8
        -:10214:                                     upper_bound - 1, b);
        8:10215:                         b += 5;
        -:10216:                       }
        -:10217:                   }
      180:10218:                pending_exact = 0;
      180:10219:                beg_interval = NULL;
        -:10220:              }
      180:10221:              break;
        -:10222:
        1:10223:            unfetch_interval:
        -:10224:              /* If an invalid interval, match the characters as literals.  */
        -:10225:               assert (beg_interval);
        1:10226:               p = beg_interval;
        1:10227:               beg_interval = NULL;
        -:10228:
        -:10229:               /* normal_char and normal_backslash need `c'.  */
       1*:10230:               PATFETCH (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 1
branch  2 taken 0 (fallthrough)
branch  3 taken 1
        -:10231:
        1:10232:               if (!(syntax & RE_NO_BK_BRACES))
branch  0 taken 0 (fallthrough)
branch  1 taken 1
        -:10233:                 {
    #####:10234:                   if (p > pattern  &&  p[-1] == '\\')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:10235:                     goto normal_backslash;
        -:10236:                 }
        1:10237:               goto normal_char;
        -:10238:
        -:10239:#ifdef emacs
        -:10240:            /* There is no way to specify the before_dot and after_dot
        -:10241:               operators.  rms says this is ok.  --karl  */
        -:10242:            case '=':
        -:10243:              BUF_PUSH (at_dot);
        -:10244:              break;
        -:10245:
        -:10246:            case 's':
        -:10247:              laststart = b;
        -:10248:              PATFETCH (c);
        -:10249:              BUF_PUSH_2 (syntaxspec, syntax_spec_code[c]);
        -:10250:              break;
        -:10251:
        -:10252:            case 'S':
        -:10253:              laststart = b;
        -:10254:              PATFETCH (c);
        -:10255:              BUF_PUSH_2 (notsyntaxspec, syntax_spec_code[c]);
        -:10256:              break;
        -:10257:#endif /* emacs */
        -:10258:
        -:10259:
        1:10260:            case 'w':
        1:10261:	      if (syntax & RE_NO_GNU_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:10262:		goto normal_char;
        1:10263:              laststart = b;
       1*:10264:              BUF_PUSH (wordchar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 1 (fallthrough)
        1:10265:              break;
        -:10266:
        -:10267:
        3:10268:            case 'W':
        3:10269:	      if (syntax & RE_NO_GNU_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:10270:		goto normal_char;
        3:10271:              laststart = b;
       3*:10272:              BUF_PUSH (notwordchar);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 3 (fallthrough)
        3:10273:              break;
        -:10274:
        -:10275:
      115:10276:            case '<':
      115:10277:	      if (syntax & RE_NO_GNU_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 115
    #####:10278:		goto normal_char;
     115*:10279:              BUF_PUSH (wordbeg);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 115 (fallthrough)
      115:10280:              break;
        -:10281:
        2:10282:            case '>':
        2:10283:	      if (syntax & RE_NO_GNU_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 2
    #####:10284:		goto normal_char;
       2*:10285:              BUF_PUSH (wordend);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 2 (fallthrough)
        2:10286:              break;
        -:10287:
      140:10288:            case 'b':
      140:10289:	      if (syntax & RE_NO_GNU_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 140
    #####:10290:		goto normal_char;
     140*:10291:              BUF_PUSH (wordbound);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 140 (fallthrough)
      140:10292:              break;
        -:10293:
        1:10294:            case 'B':
        1:10295:	      if (syntax & RE_NO_GNU_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    #####:10296:		goto normal_char;
       1*:10297:              BUF_PUSH (notwordbound);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 1 (fallthrough)
        1:10298:              break;
        -:10299:
        3:10300:            case '`':
        3:10301:	      if (syntax & RE_NO_GNU_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:10302:		goto normal_char;
       3*:10303:              BUF_PUSH (begbuf);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 3 (fallthrough)
        3:10304:              break;
        -:10305:
        3:10306:            case '\'':
        3:10307:	      if (syntax & RE_NO_GNU_OPS)
branch  0 taken 0 (fallthrough)
branch  1 taken 3
    #####:10308:		goto normal_char;
       3*:10309:              BUF_PUSH (endbuf);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 0
branch 15 taken 3 (fallthrough)
        3:10310:              break;
        -:10311:
        9:10312:            case '1': case '2': case '3': case '4': case '5':
        -:10313:            case '6': case '7': case '8': case '9':
        9:10314:              if (syntax & RE_NO_BK_REFS)
branch  0 taken 0 (fallthrough)
branch  1 taken 9
    #####:10315:                goto normal_char;
        -:10316:
        9:10317:              c1 = c - '0';
        -:10318:
        9:10319:              if (c1 > regnum)
branch  0 taken 9 (fallthrough)
branch  1 taken 0
        9:10320:                FREE_STACK_RETURN (REG_ESUBREG);
        -:10321:
        -:10322:              /* Can't back reference to a subexpression if inside of it.  */
    #####:10323:              if (group_in_compile_stack (compile_stack, (regnum_t) c1))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:10324:                goto normal_char;
        -:10325:
    #####:10326:              laststart = b;
    #####:10327:              BUF_PUSH_2 (duplicate, c1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
    #####:10328:              break;
        -:10329:
        -:10330:
      211:10331:            case '+':
        -:10332:            case '?':
      211:10333:              if (syntax & RE_BK_PLUS_QM)
branch  0 taken 176 (fallthrough)
branch  1 taken 35
      176:10334:                goto handle_plus;
        -:10335:              else
       35:10336:                goto normal_backslash;
        -:10337:
        -:10338:            default:
      220:10339:            normal_backslash:
        -:10340:              /* You might think it would be useful for \ to mean
        -:10341:                 not to translate; but if we don't translate it
        -:10342:                 it will never match anything.  */
     220*:10343:              c = TRANSLATE (c);
branch  0 taken 0 (fallthrough)
branch  1 taken 220
      220:10344:              goto normal_char;
        -:10345:            }
     2821:10346:          break;
        -:10347:
        -:10348:
        -:10349:	default:
        -:10350:        /* Expects the character in `c'.  */
    49737:10351:	normal_char:
        -:10352:	      /* If no exactn currently being built.  */
    49737:10353:          if (!pending_exact
branch  0 taken 46198 (fallthrough)
branch  1 taken 3539
        -:10354:
        -:10355:              /* If last exactn not at current position.  */
    46198:10356:              || pending_exact + *pending_exact + 1 != b
branch  0 taken 45836 (fallthrough)
branch  1 taken 362
        -:10357:
        -:10358:              /* We have only one byte following the exactn for the count.  */
    45836:10359:	      || *pending_exact == (1 << BYTEWIDTH) - 1
branch  0 taken 45836 (fallthrough)
branch  1 taken 0
        -:10360:
        -:10361:              /* If followed by a repetition operator.  */
    45836:10362:              || *p == '*' || *p == '^'
branch  0 taken 45497 (fallthrough)
branch  1 taken 339
branch  2 taken 45496 (fallthrough)
branch  3 taken 1
    90992:10363:	      || ((syntax & RE_BK_PLUS_QM)
branch  0 taken 44114 (fallthrough)
branch  1 taken 1382
branch  2 taken 43998
branch  3 taken 116
branch  4 taken 1285 (fallthrough)
branch  5 taken 97
    44114:10364:		  ? *p == '\\' && (p[1] == '+' || p[1] == '?')
branch  0 taken 311 (fallthrough)
branch  1 taken 43803
branch  2 taken 253 (fallthrough)
branch  3 taken 58
branch  4 taken 58 (fallthrough)
branch  5 taken 195
     1382:10365:		  : (*p == '+' || *p == '?'))
branch  0 taken 1334 (fallthrough)
branch  1 taken 48
branch  2 taken 49 (fallthrough)
branch  3 taken 1285
    45283:10366:	      || ((syntax & RE_INTERVALS)
branch  0 taken 45283 (fallthrough)
branch  1 taken 0
    89281:10367:                  && ((syntax & RE_NO_BK_BRACES)
branch  0 taken 1285 (fallthrough)
branch  1 taken 43998
branch  2 taken 55 (fallthrough)
branch  3 taken 43943
     1285:10368:		      ? *p == '{'
branch  0 taken 48
branch  1 taken 1237
    43998:10369:                      : (p[0] == '\\' && p[1] == '{'))))
branch  0 taken 195 (fallthrough)
branch  1 taken 43803
branch  2 taken 55 (fallthrough)
branch  3 taken 140
        -:10370:	    {
        -:10371:	      /* Start building a new exactn.  */
        -:10372:
     4557:10373:              laststart = b;
        -:10374:
    4602*:10375:	      BUF_PUSH_2 (exactn, 0);
branch  0 taken 0 (fallthrough)
branch  1 taken 45
branch  2 taken 0 (fallthrough)
branch  3 taken 45
branch  4 taken 0 (fallthrough)
branch  5 taken 45
branch  6 taken 0 (fallthrough)
branch  7 taken 45
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 45
branch 15 taken 4557 (fallthrough)
     4557:10376:	      pending_exact = b - 1;
        -:10377:            }
        -:10378:
   49859*:10379:	  BUF_PUSH (c);
branch  0 taken 1 (fallthrough)
branch  1 taken 122
branch  2 taken 0 (fallthrough)
branch  3 taken 122
branch  4 taken 0 (fallthrough)
branch  5 taken 122
branch  6 taken 0 (fallthrough)
branch  7 taken 122
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 taken 123
branch 15 taken 49736 (fallthrough)
    49736:10380:          (*pending_exact)++;
    49736:10381:	  break;
        -:10382:        } /* switch (c) */
        -:10383:    } /* while p != pend */
        -:10384:
        -:10385:
        -:10386:  /* Through the pattern now.  */
        -:10387:
      725:10388:  if (fixup_alt_jump)
branch  0 taken 239 (fallthrough)
branch  1 taken 486
      239:10389:    STORE_JUMP (jump_past_alt, fixup_alt_jump, b);
call    0 returned 239
        -:10390:
      725:10391:  if (!COMPILE_STACK_EMPTY)
branch  0 taken 3 (fallthrough)
branch  1 taken 722
        3:10392:    FREE_STACK_RETURN (REG_EPAREN);
        -:10393:
        -:10394:  /* If we don't want backtracking, force success
        -:10395:     the first time we reach the end of the compiled pattern.  */
      722:10396:  if (syntax & RE_NO_POSIX_BACKTRACKING)
branch  0 taken 0 (fallthrough)
branch  1 taken 722
    #####:10397:    BUF_PUSH (succeed);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
        -:10398:
      722:10399:  free (compile_stack.stack);
        -:10400:
        -:10401:  /* We have succeeded; set the length of the buffer.  */
      722:10402:  bufp->used = b - bufp->buffer;
        -:10403:
        -:10404:#ifdef DEBUG
        -:10405:  if (debug)
        -:10406:    {
        -:10407:      DEBUG_PRINT1 ("\nCompiled pattern: \n");
        -:10408:      print_compiled_pattern (bufp);
        -:10409:    }
        -:10410:#endif /* DEBUG */
        -:10411:
        -:10412:#ifndef MATCH_MAY_ALLOCATE
        -:10413:  /* Initialize the failure stack to the largest possible stack.  This
        -:10414:     isn't necessary unless we're trying to avoid calling alloca in
        -:10415:     the search and match routines.  */
        -:10416:  {
        -:10417:    int num_regs = bufp->re_nsub + 1;
        -:10418:
        -:10419:    /* Since DOUBLE_FAIL_STACK refuses to double only if the current size
        -:10420:       is strictly greater than re_max_failures, the largest possible stack
        -:10421:       is 2 * re_max_failures failure points.  */
        -:10422:    if (fail_stack.size < (2 * re_max_failures * MAX_FAILURE_ITEMS))
        -:10423:      {
        -:10424:	fail_stack.size = (2 * re_max_failures * MAX_FAILURE_ITEMS);
        -:10425:
        -:10426:# ifdef emacs
        -:10427:	if (! fail_stack.stack)
        -:10428:	  fail_stack.stack
        -:10429:	    = (fail_stack_elt_t *) xmalloc (fail_stack.size
        -:10430:					    * sizeof (fail_stack_elt_t));
        -:10431:	else
        -:10432:	  fail_stack.stack
        -:10433:	    = (fail_stack_elt_t *) xrealloc (fail_stack.stack,
        -:10434:					     (fail_stack.size
        -:10435:					      * sizeof (fail_stack_elt_t)));
        -:10436:# else /* not emacs */
        -:10437:	if (! fail_stack.stack)
        -:10438:	  fail_stack.stack
        -:10439:	    = (fail_stack_elt_t *) malloc (fail_stack.size
        -:10440:					   * sizeof (fail_stack_elt_t));
        -:10441:	else
        -:10442:	  fail_stack.stack
        -:10443:	    = (fail_stack_elt_t *) realloc (fail_stack.stack,
        -:10444:					    (fail_stack.size
        -:10445:					     * sizeof (fail_stack_elt_t)));
        -:10446:# endif /* not emacs */
        -:10447:      }
        -:10448:
        -:10449:    regex_grow_registers (num_regs);
        -:10450:  }
        -:10451:#endif /* not MATCH_MAY_ALLOCATE */
        -:10452:
      722:10453:  return REG_NOERROR;
        -:10454:} /* regex_compile */
        -:10455:
        -:10456:/* Subroutines for `regex_compile'.  */
        -:10457:
        -:10458:/* Store OP at LOC followed by two-byte integer parameter ARG.  */
        -:10459:
        -:10460:static void
function store_op1 called 5872 returned 100% blocks executed 100%
     5872:10461:store_op1 (op, loc, arg)
        -:10462:    re_opcode_t op;
        -:10463:    unsigned char *loc;
        -:10464:    int arg;
        -:10465:{
     5872:10466:  *loc = (unsigned char) op;
     5872:10467:  STORE_NUMBER (loc + 1, arg);
     5872:10468:}
        -:10469:
        -:10470:
        -:10471:/* Like `store_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -:10472:
        -:10473:static void
function store_op2 called 370 returned 100% blocks executed 100%
      370:10474:store_op2 (op, loc, arg1, arg2)
        -:10475:    re_opcode_t op;
        -:10476:    unsigned char *loc;
        -:10477:    int arg1, arg2;
        -:10478:{
      370:10479:  *loc = (unsigned char) op;
      370:10480:  STORE_NUMBER (loc + 1, arg1);
      370:10481:  STORE_NUMBER (loc + 3, arg2);
      370:10482:}
        -:10483:
        -:10484:
        -:10485:/* Copy the bytes from LOC to END to open up three bytes of space at LOC
        -:10486:   for OP followed by two-byte integer parameter ARG.  */
        -:10487:
        -:10488:static void
function insert_op1 called 3092 returned 100% blocks executed 100%
     3092:10489:insert_op1 (op, loc, arg, end)
        -:10490:    re_opcode_t op;
        -:10491:    unsigned char *loc;
        -:10492:    int arg;
        -:10493:    unsigned char *end;
        -:10494:{
     3092:10495:  register unsigned char *pfrom = end;
     3092:10496:  register unsigned char *pto = end + 3;
        -:10497:
    67033:10498:  while (pfrom != loc)
branch  0 taken 63941
branch  1 taken 3092 (fallthrough)
    63941:10499:    *--pto = *--pfrom;
        -:10500:
     3092:10501:  store_op1 (op, loc, arg);
call    0 returned 3092
     3092:10502:}
        -:10503:
        -:10504:
        -:10505:/* Like `insert_op1', but for two two-byte parameters ARG1 and ARG2.  */
        -:10506:
        -:10507:static void
function insert_op2 called 362 returned 100% blocks executed 100%
      362:10508:insert_op2 (op, loc, arg1, arg2, end)
        -:10509:    re_opcode_t op;
        -:10510:    unsigned char *loc;
        -:10511:    int arg1, arg2;
        -:10512:    unsigned char *end;
        -:10513:{
      362:10514:  register unsigned char *pfrom = end;
      362:10515:  register unsigned char *pto = end + 5;
        -:10516:
     2662:10517:  while (pfrom != loc)
branch  0 taken 2300
branch  1 taken 362 (fallthrough)
     2300:10518:    *--pto = *--pfrom;
        -:10519:
      362:10520:  store_op2 (op, loc, arg1, arg2);
call    0 returned 362
      362:10521:}
        -:10522:
        -:10523:
        -:10524:/* P points to just after a ^ in PATTERN.  Return true if that ^ comes
        -:10525:   after an alternative or a begin-subexpression.  We assume there is at
        -:10526:   least one character before the ^.  */
        -:10527:
        -:10528:static boolean
function at_begline_loc_p called 28 returned 100% blocks executed 100%
       28:10529:at_begline_loc_p (pattern, p, syntax)
        -:10530:    const char *pattern, *p;
        -:10531:    reg_syntax_t syntax;
        -:10532:{
       28:10533:  const char *prev = p - 2;
       28:10534:  boolean prev_prev_backslash = prev > pattern && prev[-1] == '\\';
branch  0 taken 28 (fallthrough)
branch  1 taken 0
branch  2 taken 27 (fallthrough)
branch  3 taken 1
        -:10535:
        -:10536:  return
        -:10537:       /* After a subexpression?  */
        6:10538:       (*prev == '(' && (syntax & RE_NO_BK_PARENS || prev_prev_backslash))
branch  0 taken 6 (fallthrough)
branch  1 taken 0
branch  2 taken 0 (fallthrough)
branch  3 taken 6
        -:10539:       /* After an alternative?  */
       34:10540:    || (*prev == '|' && (syntax & RE_NO_BK_VBAR || prev_prev_backslash));
branch  0 taken 6 (fallthrough)
branch  1 taken 22
branch  2 taken 20 (fallthrough)
branch  3 taken 2
branch  4 taken 20 (fallthrough)
branch  5 taken 0
branch  6 taken 20 (fallthrough)
branch  7 taken 0
        -:10541:}
        -:10542:
        -:10543:
        -:10544:/* The dual of at_begline_loc_p.  This one is for $.  We assume there is
        -:10545:   at least one character after the $, i.e., `P < PEND'.  */
        -:10546:
        -:10547:static boolean
function at_endline_loc_p called 5 returned 100% blocks executed 61%
        5:10548:at_endline_loc_p (p, pend, syntax)
        -:10549:    const char *p, *pend;
        -:10550:    reg_syntax_t syntax;
        -:10551:{
        5:10552:  const char *next = p;
        5:10553:  boolean next_backslash = *next == '\\';
        5:10554:  const char *next_next = p + 1 < pend ? p + 1 : 0;
branch  0 taken 4 (fallthrough)
branch  1 taken 1
        -:10555:
        -:10556:  return
        -:10557:       /* Before a subexpression?  */
       5*:10558:       (syntax & RE_NO_BK_PARENS ? *next == ')'
       5*:10559:        : next_backslash && next_next && *next_next == ')')
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:10560:       /* Before an alternative?  */
      15*:10561:    || (syntax & RE_NO_BK_VBAR ? *next == '|'
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 never executed
branch  3 never executed
branch  4 taken 5 (fallthrough)
branch  5 taken 0
branch  6 taken 0 (fallthrough)
branch  7 taken 5
branch  8 never executed
branch  9 never executed
branch 10 taken 0 (fallthrough)
branch 11 taken 5
       5*:10562:        : next_backslash && next_next && *next_next == '|');
branch  0 taken 0 (fallthrough)
branch  1 taken 5
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:10563:}
        -:10564:
        -:10565:
        -:10566:/* Returns true if REGNUM is in one of COMPILE_STACK's elements and
        -:10567:   false if it's not.  */
        -:10568:
        -:10569:static boolean
function group_in_compile_stack called 0 returned 0% blocks executed 0%
    #####:10570:group_in_compile_stack (compile_stack, regnum)
        -:10571:    compile_stack_type compile_stack;
        -:10572:    regnum_t regnum;
        -:10573:{
        -:10574:  int this_element;
        -:10575:
    #####:10576:  for (this_element = compile_stack.avail - 1;
    #####:10577:       this_element >= 0;
branch  0 never executed
branch  1 never executed
    #####:10578:       this_element--)
    #####:10579:    if (compile_stack.stack[this_element].regnum == regnum)
branch  0 never executed
branch  1 never executed
    #####:10580:      return true;
        -:10581:
    #####:10582:  return false;
        -:10583:}
        -:10584:
        -:10585:
        -:10586:/* Read the ending character of a range (in a bracket expression) from the
        -:10587:   uncompiled pattern *P_PTR (which ends at PEND).  We assume the
        -:10588:   starting character is in `P[-2]'.  (`P[-1]' is the character `-'.)
        -:10589:   Then we set the translation of all bits between the starting and
        -:10590:   ending characters (inclusive) in the compiled pattern B.
        -:10591:
        -:10592:   Return an error code.
        -:10593:
        -:10594:   We use these short variable names so we can use the same macros as
        -:10595:   `regex_compile' itself.  */
        -:10596:
        -:10597:static reg_errcode_t
function compile_range called 40 returned 100% blocks executed 83%
       40:10598:compile_range (p_ptr, pend, translate, syntax, b)
        -:10599:    const char **p_ptr, *pend;
        -:10600:    RE_TRANSLATE_TYPE translate;
        -:10601:    reg_syntax_t syntax;
        -:10602:    unsigned char *b;
        -:10603:{
        -:10604:  unsigned this_char;
        -:10605:
       40:10606:  const char *p = *p_ptr;
        -:10607:  reg_errcode_t ret;
        -:10608:  char range_start[2];
        -:10609:  char range_end[2];
        -:10610:
       40:10611:  if (p == pend)
branch  0 taken 6 (fallthrough)
branch  1 taken 34
        6:10612:    return REG_ERANGE;
        -:10613:
        -:10614:  /* Fetch the endpoints without translating them; the
        -:10615:     appropriate translation is done in the bit-setting loop below.  */
        -:10616:  #ifndef FAULTY_F_DG_2
       34:10617:  range_start[0] = p[-2];  range_start[1] = '\0';
       34:10618:  range_end[0]   = p[ 0];  range_end[1]   = '\0';
        -:10619:  #else
        -:10620:  range_start[0] = p[-2];  
        -:10621:  range_end[0]   = p[ 0];  
        -:10622:  #endif
        -:10623:
        -:10624:  /* Have to increment the pointer into the pattern string, so the
        -:10625:     caller isn't still at the ending character.  */
       34:10626:  (*p_ptr)++;
        -:10627:
        -:10628:  /* Report an error if the range is empty and the syntax prohibits this.  */
      34*:10629:  ret = syntax & RE_NO_EMPTY_RANGES ? REG_ERANGE : REG_NOERROR;
branch  0 taken 0 (fallthrough)
branch  1 taken 34
        -:10630:
        -:10631:  /* Here we see why `this_char' has to be larger than an `unsigned
        -:10632:     char' -- we would otherwise go into an infinite
        -:10633:     loop, since all characters <= 0xff.  */
     8738:10634:  for (this_char = 0; this_char <= (unsigned char) -1; this_char++)
branch  0 taken 8704
branch  1 taken 34 (fallthrough)
        -:10635:    {
        -:10636:      char ch[2];
     8704:10637:      ch[0] = this_char;  ch[1] = '\0';
     8704:10638:      if (strcoll (range_start, ch) <= 0 && strcoll (ch, range_end) <= 0)
branch  0 taken 1911 (fallthrough)
branch  1 taken 6793
branch  2 taken 615 (fallthrough)
branch  3 taken 1296
        -:10639:	{
     615*:10640:	  SET_LIST_BIT (TRANSLATE (this_char));
branch  0 taken 0 (fallthrough)
branch  1 taken 615
branch  2 taken 0 (fallthrough)
branch  3 taken 615
branch  4 taken 0 (fallthrough)
branch  5 taken 615
        -:10641:	  #ifndef FAULTY_F_KP_3
      615:10642:	  ret = REG_NOERROR;
        -:10643:	  #else
        -:10644:	  ret = syntax & REG_NOERROR;
        -:10645:	  #endif
        -:10646:	}
        -:10647:    }
        -:10648:
       34:10649:  return ret;
        -:10650:}
        -:10651:
        -:10652:/* re_compile_fastmap computes a ``fastmap'' for the compiled pattern in
        -:10653:   BUFP.  A fastmap records which of the (1 << BYTEWIDTH) possible
        -:10654:   characters can start a string that matches the pattern.  This fastmap
        -:10655:   is used by re_search to skip quickly over impossible starting points.
        -:10656:
        -:10657:   The caller must supply the address of a (1 << BYTEWIDTH)-byte data
        -:10658:   area as BUFP->fastmap.
        -:10659:
        -:10660:   We set the `fastmap', `fastmap_accurate', and `can_be_null' fields in
        -:10661:   the pattern buffer.
        -:10662:
        -:10663:   Returns 0 if we succeed, -2 if an internal error.   */
        -:10664:
        -:10665:int
function re_compile_fastmap called 0 returned 0% blocks executed 0%
    #####:10666:re_compile_fastmap (bufp)
        -:10667:     struct re_pattern_buffer *bufp;
        -:10668:{
        -:10669:  int j, k;
        -:10670:#ifdef MATCH_MAY_ALLOCATE
        -:10671:  fail_stack_type fail_stack;
        -:10672:#endif
        -:10673:#ifndef REGEX_MALLOC
        -:10674:  char *destination;
        -:10675:#endif
        -:10676:
    #####:10677:  register char *fastmap = bufp->fastmap;
    #####:10678:  unsigned char *pattern = bufp->buffer;
    #####:10679:  unsigned char *p = pattern;
    #####:10680:  register unsigned char *pend = pattern + bufp->used;
        -:10681:
        -:10682:#ifdef REL_ALLOC
        -:10683:  /* This holds the pointer to the failure stack, when
        -:10684:     it is allocated relocatably.  */
        -:10685:  fail_stack_elt_t *failure_stack_ptr;
        -:10686:#endif
        -:10687:
        -:10688:  /* Assume that each path through the pattern can be null until
        -:10689:     proven otherwise.  We set this false at the bottom of switch
        -:10690:     statement, to which we get only if a particular path doesn't
        -:10691:     match the empty string.  */
    #####:10692:  boolean path_can_be_null = true;
        -:10693:
        -:10694:  /* We aren't doing a `succeed_n' to begin with.  */
    #####:10695:  boolean succeed_n_p = false;
        -:10696:
        -:10697:  assert (fastmap != NULL && p != NULL);
        -:10698:
    #####:10699:  INIT_FAIL_STACK ();
branch  0 never executed
branch  1 never executed
    #####:10700:  bzero (fastmap, 1 << BYTEWIDTH);  /* Assume nothing's valid.  */
    #####:10701:  bufp->fastmap_accurate = 1;	    /* It will be when we're done.  */
    #####:10702:  bufp->can_be_null = 0;
        -:10703:
        -:10704:  while (1)
        -:10705:    {
    #####:10706:      if (p == pend || *p == succeed)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:10707:	{
        -:10708:	  /* We have reached the (effective) end of pattern.  */
    #####:10709:	  if (!FAIL_STACK_EMPTY ())
branch  0 never executed
branch  1 never executed
        -:10710:	    {
    #####:10711:	      bufp->can_be_null |= path_can_be_null;
        -:10712:
        -:10713:	      /* Reset for next path.  */
    #####:10714:	      path_can_be_null = true;
        -:10715:
    #####:10716:	      p = fail_stack.stack[--fail_stack.avail].pointer;
        -:10717:
    #####:10718:	      continue;
        -:10719:	    }
        -:10720:	  else
    #####:10721:	    break;
        -:10722:	}
        -:10723:
        -:10724:      /* We should never be about to go beyond the end of the pattern.  */
        -:10725:      assert (p < pend);
        -:10726:
    #####:10727:      switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
        -:10728:	{
        -:10729:
        -:10730:        /* I guess the idea here is to simply not bother with a fastmap
        -:10731:           if a backreference is used, since it's too hard to figure out
        -:10732:           the fastmap for the corresponding group.  Setting
        -:10733:           `can_be_null' stops `re_search_2' from using the fastmap, so
        -:10734:           that is all we do.  */
    #####:10735:	case duplicate:
    #####:10736:	  bufp->can_be_null = 1;
    #####:10737:          goto done;
        -:10738:
        -:10739:
        -:10740:      /* Following are the cases which match a character.  These end
        -:10741:         with `break'.  */
        -:10742:
    #####:10743:	case exactn:
    #####:10744:          fastmap[p[1]] = 1;
    #####:10745:	  break;
        -:10746:
        -:10747:
    #####:10748:        case charset:
    #####:10749:          for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
branch  0 never executed
branch  1 never executed
    #####:10750:	    if (p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH)))
branch  0 never executed
branch  1 never executed
    #####:10751:              fastmap[j] = 1;
    #####:10752:	  break;
        -:10753:
        -:10754:
    #####:10755:	case charset_not:
        -:10756:	  /* Chars beyond end of map must be allowed.  */
    #####:10757:	  for (j = *p * BYTEWIDTH; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####:10758:            fastmap[j] = 1;
        -:10759:
    #####:10760:	  for (j = *p++ * BYTEWIDTH - 1; j >= 0; j--)
branch  0 never executed
branch  1 never executed
    #####:10761:	    if (!(p[j / BYTEWIDTH] & (1 << (j % BYTEWIDTH))))
branch  0 never executed
branch  1 never executed
    #####:10762:              fastmap[j] = 1;
    #####:10763:          break;
        -:10764:
        -:10765:
    #####:10766:	case wordchar:
    #####:10767:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####:10768:	    if (SYNTAX (j) == Sword)
branch  0 never executed
branch  1 never executed
    #####:10769:	      fastmap[j] = 1;
    #####:10770:	  break;
        -:10771:
        -:10772:
    #####:10773:	case notwordchar:
    #####:10774:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####:10775:	    if (SYNTAX (j) != Sword)
branch  0 never executed
branch  1 never executed
    #####:10776:	      fastmap[j] = 1;
    #####:10777:	  break;
        -:10778:
        -:10779:
    #####:10780:        case anychar:
        -:10781:	  {
    #####:10782:	    int fastmap_newline = fastmap['\n'];
        -:10783:
        -:10784:	    /* `.' matches anything ...  */
    #####:10785:	    for (j = 0; j < (1 << BYTEWIDTH); j++)
branch  0 never executed
branch  1 never executed
    #####:10786:	      fastmap[j] = 1;
        -:10787:
        -:10788:	    /* ... except perhaps newline.  */
    #####:10789:	    if (!(bufp->syntax & RE_DOT_NEWLINE))
branch  0 never executed
branch  1 never executed
    #####:10790:	      fastmap['\n'] = fastmap_newline;
        -:10791:
        -:10792:	    /* Return if we have already set `can_be_null'; if we have,
        -:10793:	       then the fastmap is irrelevant.  Something's wrong here.  */
    #####:10794:	    else if (bufp->can_be_null)
branch  0 never executed
branch  1 never executed
    #####:10795:	      goto done;
        -:10796:
        -:10797:	    /* Otherwise, have to check alternative paths.  */
    #####:10798:	    break;
        -:10799:	  }
        -:10800:
        -:10801:#ifdef emacs
        -:10802:        case syntaxspec:
        -:10803:	  k = *p++;
        -:10804:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -:10805:	    if (SYNTAX (j) == (enum syntaxcode) k)
        -:10806:	      fastmap[j] = 1;
        -:10807:	  break;
        -:10808:
        -:10809:
        -:10810:	case notsyntaxspec:
        -:10811:	  k = *p++;
        -:10812:	  for (j = 0; j < (1 << BYTEWIDTH); j++)
        -:10813:	    if (SYNTAX (j) != (enum syntaxcode) k)
        -:10814:	      fastmap[j] = 1;
        -:10815:	  break;
        -:10816:
        -:10817:
        -:10818:      /* All cases after this match the empty string.  These end with
        -:10819:         `continue'.  */
        -:10820:
        -:10821:
        -:10822:	case before_dot:
        -:10823:	case at_dot:
        -:10824:	case after_dot:
        -:10825:          continue;
        -:10826:#endif /* emacs */
        -:10827:
        -:10828:
    #####:10829:        case no_op:
        -:10830:        case begline:
        -:10831:        case endline:
        -:10832:	case begbuf:
        -:10833:	case endbuf:
        -:10834:	case wordbound:
        -:10835:	case notwordbound:
        -:10836:	case wordbeg:
        -:10837:	case wordend:
        -:10838:        case push_dummy_failure:
    #####:10839:          continue;
        -:10840:
        -:10841:
    #####:10842:	case jump_n:
        -:10843:        case pop_failure_jump:
        -:10844:	case maybe_pop_jump:
        -:10845:	case jump:
        -:10846:        case jump_past_alt:
        -:10847:	case dummy_failure_jump:
    #####:10848:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####:10849:	  p += j;
    #####:10850:	  if (j > 0)
branch  0 never executed
branch  1 never executed
    #####:10851:	    continue;
        -:10852:
        -:10853:          /* Jump backward implies we just went through the body of a
        -:10854:             loop and matched nothing.  Opcode jumped to should be
        -:10855:             `on_failure_jump' or `succeed_n'.  Just treat it like an
        -:10856:             ordinary jump.  For a * loop, it has pushed its failure
        -:10857:             point already; if so, discard that as redundant.  */
    #####:10858:          if ((re_opcode_t) *p != on_failure_jump
branch  0 never executed
branch  1 never executed
    #####:10859:	      && (re_opcode_t) *p != succeed_n)
branch  0 never executed
branch  1 never executed
    #####:10860:	    continue;
        -:10861:
    #####:10862:          p++;
    #####:10863:          EXTRACT_NUMBER_AND_INCR (j, p);
    #####:10864:          p += j;
        -:10865:
        -:10866:          /* If what's on the stack is where we are now, pop it.  */
    #####:10867:          if (!FAIL_STACK_EMPTY ()
branch  0 never executed
branch  1 never executed
    #####:10868:	      && fail_stack.stack[fail_stack.avail - 1].pointer == p)
branch  0 never executed
branch  1 never executed
    #####:10869:            fail_stack.avail--;
        -:10870:
    #####:10871:          continue;
        -:10872:
        -:10873:
        -:10874:        case on_failure_jump:
        -:10875:        case on_failure_keep_string_jump:
    #####:10876:	handle_on_failure_jump:
    #####:10877:          EXTRACT_NUMBER_AND_INCR (j, p);
        -:10878:
        -:10879:          /* For some patterns, e.g., `(a?)?', `p+j' here points to the
        -:10880:             end of the pattern.  We don't want to push such a point,
        -:10881:             since when we restore it above, entering the switch will
        -:10882:             increment `p' past the end of the pattern.  We don't need
        -:10883:             to push such a point since we obviously won't find any more
        -:10884:             fastmap entries beyond `pend'.  Such a pattern can match
        -:10885:             the null string, though.  */
    #####:10886:          if (p + j < pend)
branch  0 never executed
branch  1 never executed
        -:10887:            {
    #####:10888:              if (!PUSH_PATTERN_OP (p + j, fail_stack))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:10889:		{
        -:10890:		  RESET_FAIL_STACK ();
    #####:10891:		  return -2;
        -:10892:		}
        -:10893:            }
        -:10894:          else
    #####:10895:            bufp->can_be_null = 1;
        -:10896:
    #####:10897:          if (succeed_n_p)
branch  0 never executed
branch  1 never executed
        -:10898:            {
    #####:10899:              EXTRACT_NUMBER_AND_INCR (k, p);	/* Skip the n.  */
    #####:10900:              succeed_n_p = false;
        -:10901:	    }
        -:10902:
    #####:10903:          continue;
        -:10904:
        -:10905:
    #####:10906:	case succeed_n:
        -:10907:          /* Get to the number of times to succeed.  */
    #####:10908:          p += 2;
        -:10909:
        -:10910:          /* Increment p past the n for when k != 0.  */
    #####:10911:          EXTRACT_NUMBER_AND_INCR (k, p);
    #####:10912:          if (k == 0)
branch  0 never executed
branch  1 never executed
        -:10913:	    {
    #####:10914:              p -= 4;
    #####:10915:  	      succeed_n_p = true;  /* Spaghetti code alert.  */
    #####:10916:              goto handle_on_failure_jump;
        -:10917:            }
    #####:10918:          continue;
        -:10919:
        -:10920:
    #####:10921:	case set_number_at:
    #####:10922:          p += 4;
    #####:10923:          continue;
        -:10924:
        -:10925:
    #####:10926:	case start_memory:
        -:10927:        case stop_memory:
    #####:10928:	  p += 2;
    #####:10929:	  continue;
        -:10930:
        -:10931:
    #####:10932:	default:
    #####:10933:          abort (); /* We have listed all the cases.  */
call    0 never executed
        -:10934:        } /* switch *p++ */
        -:10935:
        -:10936:      /* Getting here means we have found the possible starting
        -:10937:         characters for one path of the pattern -- and that the empty
        -:10938:         string does not match.  We need not follow this path further.
        -:10939:         Instead, look at the next alternative (remembered on the
        -:10940:         stack), or quit if no more.  The test at the top of the loop
        -:10941:         does these things.  */
    #####:10942:      path_can_be_null = false;
    #####:10943:      p = pend;
        -:10944:    } /* while p */
        -:10945:
        -:10946:  /* Set `can_be_null' for the last path (also the first path, if the
        -:10947:     pattern is empty).  */
    #####:10948:  bufp->can_be_null |= path_can_be_null;
        -:10949:
    #####:10950: done:
        -:10951:  RESET_FAIL_STACK ();
    #####:10952:  return 0;
        -:10953:} /* re_compile_fastmap */
        -:10954:#ifdef _LIBC
        -:10955:weak_alias (__re_compile_fastmap, re_compile_fastmap)
        -:10956:#endif
        -:10957:
        -:10958:/* Set REGS to hold NUM_REGS registers, storing them in STARTS and
        -:10959:   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use
        -:10960:   this memory for recording register information.  STARTS and ENDS
        -:10961:   must be allocated using the malloc library routine, and must each
        -:10962:   be at least NUM_REGS * sizeof (regoff_t) bytes long.
        -:10963:
        -:10964:   If NUM_REGS == 0, then subsequent matches should allocate their own
        -:10965:   register data.
        -:10966:
        -:10967:   Unless this function is called, the first search or match using
        -:10968:   PATTERN_BUFFER will allocate its own register data, without
        -:10969:   freeing the old data.  */
        -:10970:
        -:10971:void
function re_set_registers called 0 returned 0% blocks executed 0%
    #####:10972:re_set_registers (bufp, regs, num_regs, starts, ends)
        -:10973:    struct re_pattern_buffer *bufp;
        -:10974:    struct re_registers *regs;
        -:10975:    unsigned num_regs;
        -:10976:    regoff_t *starts, *ends;
        -:10977:{
    #####:10978:  if (num_regs)
branch  0 never executed
branch  1 never executed
        -:10979:    {
    #####:10980:      bufp->regs_allocated = REGS_REALLOCATE;
    #####:10981:      regs->num_regs = num_regs;
    #####:10982:      regs->start = starts;
    #####:10983:      regs->end = ends;
        -:10984:    }
        -:10985:  else
        -:10986:    {
    #####:10987:      bufp->regs_allocated = REGS_UNALLOCATED;
    #####:10988:      regs->num_regs = 0;
    #####:10989:      regs->start = regs->end = (regoff_t *) 0;
        -:10990:    }
    #####:10991:}
        -:10992:#ifdef _LIBC
        -:10993:weak_alias (__re_set_registers, re_set_registers)
        -:10994:#endif
        -:10995:
        -:10996:/* Searching routines.  */
        -:10997:
        -:10998:/* Like re_search_2, below, but only one string is specified, and
        -:10999:   doesn't let you say where to stop matching. */
        -:11000:
        -:11001:int
function re_search called 0 returned 0% blocks executed 0%
    #####:11002:re_search (bufp, string, size, startpos, range, regs)
        -:11003:     struct re_pattern_buffer *bufp;
        -:11004:     const char *string;
        -:11005:     int size, startpos, range;
        -:11006:     struct re_registers *regs;
        -:11007:{
    #####:11008:  return re_search_2 (bufp, NULL, 0, string, size, startpos, range,
call    0 never executed
        -:11009:		      regs, size);
        -:11010:}
        -:11011:#ifdef _LIBC
        -:11012:weak_alias (__re_search, re_search)
        -:11013:#endif
        -:11014:
        -:11015:
        -:11016:/* Using the compiled pattern in BUFP->buffer, first tries to match the
        -:11017:   virtual concatenation of STRING1 and STRING2, starting first at index
        -:11018:   STARTPOS, then at STARTPOS + 1, and so on.
        -:11019:
        -:11020:   STRING1 and STRING2 have length SIZE1 and SIZE2, respectively.
        -:11021:
        -:11022:   RANGE is how far to scan while trying to match.  RANGE = 0 means try
        -:11023:   only at STARTPOS; in general, the last start tried is STARTPOS +
        -:11024:   RANGE.
        -:11025:
        -:11026:   In REGS, return the indices of the virtual concatenation of STRING1
        -:11027:   and STRING2 that matched the entire BUFP->buffer and its contained
        -:11028:   subexpressions.
        -:11029:
        -:11030:   Do not consider matching one past the index STOP in the virtual
        -:11031:   concatenation of STRING1 and STRING2.
        -:11032:
        -:11033:   We return either the position in the strings at which the match was
        -:11034:   found, -1 if no match, or -2 if error (such as failure
        -:11035:   stack overflow).  */
        -:11036:
        -:11037:int
function re_search_2 called 0 returned 0% blocks executed 0%
    #####:11038:re_search_2 (bufp, string1, size1, string2, size2, startpos, range, regs, stop)
        -:11039:     struct re_pattern_buffer *bufp;
        -:11040:     const char *string1, *string2;
        -:11041:     int size1, size2;
        -:11042:     int startpos;
        -:11043:     int range;
        -:11044:     struct re_registers *regs;
        -:11045:     int stop;
        -:11046:{
        -:11047:  int val;
    #####:11048:  register char *fastmap = bufp->fastmap;
    #####:11049:  register RE_TRANSLATE_TYPE translate = bufp->translate;
    #####:11050:  int total_size = size1 + size2;
    #####:11051:  int endpos = startpos + range;
        -:11052:
        -:11053:  /* Check for out-of-range STARTPOS.  */
    #####:11054:  if (startpos < 0 || startpos > total_size)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11055:    return -1;
        -:11056:
        -:11057:  /* Fix up RANGE if it might eventually take us outside
        -:11058:     the virtual concatenation of STRING1 and STRING2.
        -:11059:     Make sure we won't move STARTPOS below 0 or above TOTAL_SIZE.  */
    #####:11060:  if (endpos < 0)
branch  0 never executed
branch  1 never executed
    #####:11061:    range = 0 - startpos;
    #####:11062:  else if (endpos > total_size)
branch  0 never executed
branch  1 never executed
    #####:11063:    range = total_size - startpos;
        -:11064:
        -:11065:  /* If the search isn't to be a backwards one, don't waste time in a
        -:11066:     search for a pattern that must be anchored.  */
    #####:11067:  if (bufp->used > 0 && range > 0
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11068:      && ((re_opcode_t) bufp->buffer[0] == begbuf
branch  0 never executed
branch  1 never executed
        -:11069:	  /* `begline' is like `begbuf' if it cannot match at newlines.  */
    #####:11070:	  || ((re_opcode_t) bufp->buffer[0] == begline
branch  0 never executed
branch  1 never executed
    #####:11071:	      && !bufp->newline_anchor)))
branch  0 never executed
branch  1 never executed
        -:11072:    {
    #####:11073:      if (startpos > 0)
branch  0 never executed
branch  1 never executed
    #####:11074:	return -1;
        -:11075:      else
    #####:11076:	range = 1;
        -:11077:    }
        -:11078:
        -:11079:#ifdef emacs
        -:11080:  /* In a forward search for something that starts with \=.
        -:11081:     don't keep searching past point.  */
        -:11082:  if (bufp->used > 0 && (re_opcode_t) bufp->buffer[0] == at_dot && range > 0)
        -:11083:    {
        -:11084:      range = PT - startpos;
        -:11085:      if (range <= 0)
        -:11086:	return -1;
        -:11087:    }
        -:11088:#endif /* emacs */
        -:11089:
        -:11090:  /* Update the fastmap now if not correct already.  */
    #####:11091:  if (fastmap && !bufp->fastmap_accurate)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11092:    if (re_compile_fastmap (bufp) == -2)
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:11093:      return -2;
        -:11094:
        -:11095:  /* Loop through the string, looking for a place to start matching.  */
        -:11096:  for (;;)
        -:11097:    {
        -:11098:      /* If a fastmap is supplied, skip quickly over characters that
        -:11099:         cannot be the start of a match.  If the pattern can match the
        -:11100:         null string, however, we don't need to skip characters; we want
        -:11101:         the first null string.  */
    #####:11102:      if (fastmap && startpos < total_size && !bufp->can_be_null)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:11103:	{
    #####:11104:	  if (range > 0)	/* Searching forwards.  */
branch  0 never executed
branch  1 never executed
        -:11105:	    {
        -:11106:	      register const char *d;
    #####:11107:	      register int lim = 0;
    #####:11108:	      int irange = range;
        -:11109:
    #####:11110:              if (startpos < size1 && startpos + range >= size1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11111:                lim = range - (size1 - startpos);
        -:11112:
    #####:11113:	      d = (startpos >= size1 ? string2 - size1 : string1) + startpos;
branch  0 never executed
branch  1 never executed
        -:11114:
        -:11115:              /* Written out as an if-else to avoid testing `translate'
        -:11116:                 inside the loop.  */
    #####:11117:	      if (translate)
branch  0 never executed
branch  1 never executed
    #####:11118:                while (range > lim
    #####:11119:                       && !fastmap[(unsigned char)
branch  0 never executed
branch  1 never executed
    #####:11120:				   translate[(unsigned char) *d++]])
branch  0 never executed
branch  1 never executed
    #####:11121:                  range--;
        -:11122:	      else
    #####:11123:                while (range > lim && !fastmap[(unsigned char) *d++])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11124:                  range--;
        -:11125:
    #####:11126:	      startpos += irange - range;
        -:11127:	    }
        -:11128:	  else				/* Searching backwards.  */
        -:11129:	    {
    #####:11130:	      register char c = (size1 == 0 || startpos >= size1
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11131:                                 ? string2[startpos - size1]
    #####:11132:                                 : string1[startpos]);
        -:11133:
    #####:11134:	      if (!fastmap[(unsigned char) TRANSLATE (c)])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11135:		goto advance;
        -:11136:	    }
        -:11137:	}
        -:11138:
        -:11139:      /* If can't match the null string, and that's all we have left, fail.  */
    #####:11140:      if (range >= 0 && startpos == total_size && fastmap
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:11141:          && !bufp->can_be_null)
branch  0 never executed
branch  1 never executed
    #####:11142:	return -1;
        -:11143:
    #####:11144:      val = re_match_2_internal (bufp, string1, size1, string2, size2,
call    0 never executed
        -:11145:				 startpos, regs, stop);
        -:11146:#ifndef REGEX_MALLOC
        -:11147:# ifdef C_ALLOCA
        -:11148:      alloca (0);
        -:11149:# endif
        -:11150:#endif
        -:11151:
    #####:11152:      if (val >= 0)
branch  0 never executed
branch  1 never executed
    #####:11153:	return startpos;
        -:11154:
    #####:11155:      if (val == -2)
branch  0 never executed
branch  1 never executed
    #####:11156:	return -2;
        -:11157:
    #####:11158:    advance:
    #####:11159:      if (!range)
branch  0 never executed
branch  1 never executed
    #####:11160:        break;
    #####:11161:      else if (range > 0)
branch  0 never executed
branch  1 never executed
        -:11162:        {
    #####:11163:          range--;
    #####:11164:          startpos++;
        -:11165:        }
        -:11166:      else
        -:11167:        {
    #####:11168:          range++;
    #####:11169:          startpos--;
        -:11170:        }
        -:11171:    }
    #####:11172:  return -1;
        -:11173:} /* re_search_2 */
        -:11174:#ifdef _LIBC
        -:11175:weak_alias (__re_search_2, re_search_2)
        -:11176:#endif
        -:11177:
        -:11178:/* This converts PTR, a pointer into one of the search strings `string1'
        -:11179:   and `string2' into an offset from the beginning of that string.  */
        -:11180:#define POINTER_TO_OFFSET(ptr)			\
        -:11181:  (FIRST_STRING_P (ptr)				\
        -:11182:   ? ((regoff_t) ((ptr) - string1))		\
        -:11183:   : ((regoff_t) ((ptr) - string2 + size1)))
        -:11184:
        -:11185:/* Macros for dealing with the split strings in re_match_2.  */
        -:11186:
        -:11187:#define MATCHING_IN_FIRST_STRING  (dend == end_match_1)
        -:11188:
        -:11189:/* Call before fetching a character with *d.  This switches over to
        -:11190:   string2 if necessary.  */
        -:11191:#define PREFETCH()							\
        -:11192:  while (d == dend)						    	\
        -:11193:    {									\
        -:11194:      /* End of string2 => fail.  */					\
        -:11195:      if (dend == end_match_2) 						\
        -:11196:        goto fail;							\
        -:11197:      /* End of string1 => advance to string2.  */ 			\
        -:11198:      d = string2;						        \
        -:11199:      dend = end_match_2;						\
        -:11200:    }
        -:11201:
        -:11202:
        -:11203:/* Test if at very beginning or at very end of the virtual concatenation
        -:11204:   of `string1' and `string2'.  If only one string, it's `string2'.  */
        -:11205:#define AT_STRINGS_BEG(d) ((d) == (size1 ? string1 : string2) || !size2)
        -:11206:#define AT_STRINGS_END(d) ((d) == end2)
        -:11207:
        -:11208:
        -:11209:/* Test if D points to a character which is word-constituent.  We have
        -:11210:   two special cases to check for: if past the end of string1, look at
        -:11211:   the first character in string2; and if before the beginning of
        -:11212:   string2, look at the last character in string1.  */
        -:11213:#define WORDCHAR_P(d)							\
        -:11214:  (SYNTAX ((d) == end1 ? *string2					\
        -:11215:           : (d) == string2 - 1 ? *(end1 - 1) : *(d))			\
        -:11216:   == Sword)
        -:11217:
        -:11218:/* Disabled due to a compiler bug -- see comment at case wordbound */
        -:11219:#if 0
        -:11220:/* Test if the character before D and the one at D differ with respect
        -:11221:   to being word-constituent.  */
        -:11222:#define AT_WORD_BOUNDARY(d)						\
        -:11223:  (AT_STRINGS_BEG (d) || AT_STRINGS_END (d)				\
        -:11224:   || WORDCHAR_P (d - 1) != WORDCHAR_P (d))
        -:11225:#endif
        -:11226:
        -:11227:/* Free everything we malloc.  */
        -:11228:#ifdef MATCH_MAY_ALLOCATE
        -:11229:# define FREE_VAR(var) if (var) REGEX_FREE (var); var = NULL
        -:11230:# define FREE_VARIABLES()						\
        -:11231:  do {									\
        -:11232:    REGEX_FREE_STACK (fail_stack.stack);				\
        -:11233:    FREE_VAR (regstart);						\
        -:11234:    FREE_VAR (regend);							\
        -:11235:    FREE_VAR (old_regstart);						\
        -:11236:    FREE_VAR (old_regend);						\
        -:11237:    FREE_VAR (best_regstart);						\
        -:11238:    FREE_VAR (best_regend);						\
        -:11239:    FREE_VAR (reg_info);						\
        -:11240:    FREE_VAR (reg_dummy);						\
        -:11241:    FREE_VAR (reg_info_dummy);						\
        -:11242:  } while (0)
        -:11243:#else
        -:11244:# define FREE_VARIABLES() ((void)0) /* Do nothing!  But inhibit gcc warning. */
        -:11245:#endif /* not MATCH_MAY_ALLOCATE */
        -:11246:
        -:11247:/* These values must meet several constraints.  They must not be valid
        -:11248:   register values; since we have a limit of 255 registers (because
        -:11249:   we use only one byte in the pattern for the register number), we can
        -:11250:   use numbers larger than 255.  They must differ by 1, because of
        -:11251:   NUM_FAILURE_ITEMS above.  And the value for the lowest register must
        -:11252:   be larger than the value for the highest register, so we do not try
        -:11253:   to actually save any registers when none are active.  */
        -:11254:#define NO_HIGHEST_ACTIVE_REG (1 << BYTEWIDTH)
        -:11255:#define NO_LOWEST_ACTIVE_REG (NO_HIGHEST_ACTIVE_REG + 1)
        -:11256:
        -:11257:/* Matching routines.  */
        -:11258:
        -:11259:#ifndef emacs   /* Emacs never uses this.  */
        -:11260:/* re_match is like re_match_2 except it takes only a single string.  */
        -:11261:
        -:11262:int
function re_match called 0 returned 0% blocks executed 0%
    #####:11263:re_match (bufp, string, size, pos, regs)
        -:11264:     struct re_pattern_buffer *bufp;
        -:11265:     const char *string;
        -:11266:     int size, pos;
        -:11267:     struct re_registers *regs;
        -:11268:{
    #####:11269:  int result = re_match_2_internal (bufp, NULL, 0, string, size,
call    0 never executed
        -:11270:				    pos, regs, size);
        -:11271:# ifndef REGEX_MALLOC
        -:11272:#  ifdef C_ALLOCA
        -:11273:  alloca (0);
        -:11274:#  endif
        -:11275:# endif
    #####:11276:  return result;
        -:11277:}
        -:11278:# ifdef _LIBC
        -:11279:weak_alias (__re_match, re_match)
        -:11280:# endif
        -:11281:#endif /* not emacs */
        -:11282:
        -:11283:static boolean group_match_null_string_p _RE_ARGS ((unsigned char **p,
        -:11284:						    unsigned char *end,
        -:11285:						register_info_type *reg_info));
        -:11286:static boolean alt_match_null_string_p _RE_ARGS ((unsigned char *p,
        -:11287:						  unsigned char *end,
        -:11288:						register_info_type *reg_info));
        -:11289:static boolean common_op_match_null_string_p _RE_ARGS ((unsigned char **p,
        -:11290:							unsigned char *end,
        -:11291:						register_info_type *reg_info));
        -:11292:static int bcmp_translate _RE_ARGS ((const char *s1, const char *s2,
        -:11293:				     int len, char *translate));
        -:11294:
        -:11295:/* re_match_2 matches the compiled pattern in BUFP against the
        -:11296:   the (virtual) concatenation of STRING1 and STRING2 (of length SIZE1
        -:11297:   and SIZE2, respectively).  We start matching at POS, and stop
        -:11298:   matching at STOP.
        -:11299:
        -:11300:   If REGS is non-null and the `no_sub' field of BUFP is nonzero, we
        -:11301:   store offsets for the substring each group matched in REGS.  See the
        -:11302:   documentation for exactly how many groups we fill.
        -:11303:
        -:11304:   We return -1 if no match, -2 if an internal error (such as the
        -:11305:   failure stack overflowing).  Otherwise, we return the length of the
        -:11306:   matched substring.  */
        -:11307:
        -:11308:int
function re_match_2 called 0 returned 0% blocks executed 0%
    #####:11309:re_match_2 (bufp, string1, size1, string2, size2, pos, regs, stop)
        -:11310:     struct re_pattern_buffer *bufp;
        -:11311:     const char *string1, *string2;
        -:11312:     int size1, size2;
        -:11313:     int pos;
        -:11314:     struct re_registers *regs;
        -:11315:     int stop;
        -:11316:{
    #####:11317:  int result = re_match_2_internal (bufp, string1, size1, string2, size2,
call    0 never executed
        -:11318:				    pos, regs, stop);
        -:11319:#ifndef REGEX_MALLOC
        -:11320:# ifdef C_ALLOCA
        -:11321:  alloca (0);
        -:11322:# endif
        -:11323:#endif
    #####:11324:  return result;
        -:11325:}
        -:11326:#ifdef _LIBC
        -:11327:weak_alias (__re_match_2, re_match_2)
        -:11328:#endif
        -:11329:
        -:11330:/* This is a separate function so that we can force an alloca cleanup
        -:11331:   afterwards.  */
        -:11332:static int
function re_match_2_internal called 0 returned 0% blocks executed 0%
    #####:11333:re_match_2_internal (bufp, string1, size1, string2, size2, pos, regs, stop)
        -:11334:     struct re_pattern_buffer *bufp;
        -:11335:     const char *string1, *string2;
        -:11336:     int size1, size2;
        -:11337:     int pos;
        -:11338:     struct re_registers *regs;
        -:11339:     int stop;
    #####:11340:{
        -:11341:  /* General temporaries.  */
        -:11342:  int mcnt;
        -:11343:  unsigned char *p1;
        -:11344:
        -:11345:  /* Just past the end of the corresponding string.  */
        -:11346:  const char *end1, *end2;
        -:11347:
        -:11348:  /* Pointers into string1 and string2, just past the last characters in
        -:11349:     each to consider matching.  */
        -:11350:  const char *end_match_1, *end_match_2;
        -:11351:
        -:11352:  /* Where we are in the data, and the end of the current string.  */
        -:11353:  const char *d, *dend;
        -:11354:
        -:11355:  /* Where we are in the pattern, and the end of the pattern.  */
    #####:11356:  unsigned char *p = bufp->buffer;
    #####:11357:  register unsigned char *pend = p + bufp->used;
        -:11358:
        -:11359:  /* Mark the opcode just after a start_memory, so we can test for an
        -:11360:     empty subpattern when we get to the stop_memory.  */
    #####:11361:  unsigned char *just_past_start_mem = 0;
        -:11362:
        -:11363:  /* We use this to map every character in the string.  */
    #####:11364:  RE_TRANSLATE_TYPE translate = bufp->translate;
        -:11365:
        -:11366:  /* Failure point stack.  Each place that can handle a failure further
        -:11367:     down the line pushes a failure point on this stack.  It consists of
        -:11368:     restart, regend, and reg_info for all registers corresponding to
        -:11369:     the subexpressions we're currently inside, plus the number of such
        -:11370:     registers, and, finally, two char *'s.  The first char * is where
        -:11371:     to resume scanning the pattern; the second one is where to resume
        -:11372:     scanning the strings.  If the latter is zero, the failure point is
        -:11373:     a ``dummy''; if a failure happens and the failure point is a dummy,
        -:11374:     it gets discarded and the next next one is tried.  */
        -:11375:#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
        -:11376:  fail_stack_type fail_stack;
        -:11377:#endif
        -:11378:#ifdef DEBUG
        -:11379:  static unsigned failure_id;
        -:11380:  unsigned nfailure_points_pushed = 0, nfailure_points_popped = 0;
        -:11381:#endif
        -:11382:
        -:11383:#ifdef REL_ALLOC
        -:11384:  /* This holds the pointer to the failure stack, when
        -:11385:     it is allocated relocatably.  */
        -:11386:  fail_stack_elt_t *failure_stack_ptr;
        -:11387:#endif
        -:11388:
        -:11389:  /* We fill all the registers internally, independent of what we
        -:11390:     return, for use in backreferences.  The number here includes
        -:11391:     an element for register zero.  */
    #####:11392:  size_t num_regs = bufp->re_nsub + 1;
        -:11393:
        -:11394:  /* The currently active registers.  */
    #####:11395:  active_reg_t lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####:11396:  active_reg_t highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -:11397:
        -:11398:  /* Information on the contents of registers. These are pointers into
        -:11399:     the input strings; they record just what was matched (on this
        -:11400:     attempt) by a subexpression part of the pattern, that is, the
        -:11401:     regnum-th regstart pointer points to where in the pattern we began
        -:11402:     matching and the regnum-th regend points to right after where we
        -:11403:     stopped matching the regnum-th subexpression.  (The zeroth register
        -:11404:     keeps track of what the whole pattern matches.)  */
        -:11405:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -:11406:  const char **regstart, **regend;
        -:11407:#endif
        -:11408:
        -:11409:  /* If a group that's operated upon by a repetition operator fails to
        -:11410:     match anything, then the register for its start will need to be
        -:11411:     restored because it will have been set to wherever in the string we
        -:11412:     are when we last see its open-group operator.  Similarly for a
        -:11413:     register's end.  */
        -:11414:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -:11415:  const char **old_regstart, **old_regend;
        -:11416:#endif
        -:11417:
        -:11418:  /* The is_active field of reg_info helps us keep track of which (possibly
        -:11419:     nested) subexpressions we are currently in. The matched_something
        -:11420:     field of reg_info[reg_num] helps us tell whether or not we have
        -:11421:     matched any of the pattern so far this time through the reg_num-th
        -:11422:     subexpression.  These two fields get reset each time through any
        -:11423:     loop their register is in.  */
        -:11424:#ifdef MATCH_MAY_ALLOCATE /* otherwise, this is global.  */
        -:11425:  register_info_type *reg_info;
        -:11426:#endif
        -:11427:
        -:11428:  /* The following record the register info as found in the above
        -:11429:     variables when we find a match better than any we've seen before.
        -:11430:     This happens as we backtrack through the failure points, which in
        -:11431:     turn happens only if we have not yet matched the entire string. */
    #####:11432:  unsigned best_regs_set = false;
        -:11433:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -:11434:  const char **best_regstart, **best_regend;
        -:11435:#endif
        -:11436:
        -:11437:  /* Logically, this is `best_regend[0]'.  But we don't want to have to
        -:11438:     allocate space for that if we're not allocating space for anything
        -:11439:     else (see below).  Also, we never need info about register 0 for
        -:11440:     any of the other register vectors, and it seems rather a kludge to
        -:11441:     treat `best_regend' differently than the rest.  So we keep track of
        -:11442:     the end of the best match so far in a separate variable.  We
        -:11443:     initialize this to NULL so that when we backtrack the first time
        -:11444:     and need to test it, it's not garbage.  */
    #####:11445:  const char *match_end = NULL;
        -:11446:
        -:11447:  /* This helps SET_REGS_MATCHED avoid doing redundant work.  */
    #####:11448:  int set_regs_matched_done = 0;
        -:11449:
        -:11450:  /* Used when we pop values we don't care about.  */
        -:11451:#ifdef MATCH_MAY_ALLOCATE /* otherwise, these are global.  */
        -:11452:  const char **reg_dummy;
        -:11453:  register_info_type *reg_info_dummy;
        -:11454:#endif
        -:11455:
        -:11456:#ifdef DEBUG
        -:11457:  /* Counts the total number of registers pushed.  */
        -:11458:  unsigned num_regs_pushed = 0;
        -:11459:#endif
        -:11460:
        -:11461:  DEBUG_PRINT1 ("\n\nEntering re_match_2.\n");
        -:11462:
    #####:11463:  INIT_FAIL_STACK ();
branch  0 never executed
branch  1 never executed
        -:11464:
        -:11465:#ifdef MATCH_MAY_ALLOCATE
        -:11466:  /* Do not bother to initialize all the register variables if there are
        -:11467:     no groups in the pattern, as it takes a fair amount of time.  If
        -:11468:     there are groups, we include space for register 0 (the whole
        -:11469:     pattern), even though we never use it, since it simplifies the
        -:11470:     array indexing.  We should fix this.  */
    #####:11471:  if (bufp->re_nsub)
branch  0 never executed
branch  1 never executed
        -:11472:    {
    #####:11473:      regstart = REGEX_TALLOC (num_regs, const char *);
    #####:11474:      regend = REGEX_TALLOC (num_regs, const char *);
    #####:11475:      old_regstart = REGEX_TALLOC (num_regs, const char *);
    #####:11476:      old_regend = REGEX_TALLOC (num_regs, const char *);
    #####:11477:      best_regstart = REGEX_TALLOC (num_regs, const char *);
    #####:11478:      best_regend = REGEX_TALLOC (num_regs, const char *);
    #####:11479:      reg_info = REGEX_TALLOC (num_regs, register_info_type);
    #####:11480:      reg_dummy = REGEX_TALLOC (num_regs, const char *);
    #####:11481:      reg_info_dummy = REGEX_TALLOC (num_regs, register_info_type);
        -:11482:
    #####:11483:      if (!(regstart && regend && old_regstart && old_regend && reg_info
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:11484:            && best_regstart && best_regend && reg_dummy && reg_info_dummy))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:11485:        {
    #####:11486:          FREE_VARIABLES ();
    #####:11487:          return -2;
        -:11488:        }
        -:11489:    }
        -:11490:  else
        -:11491:    {
        -:11492:      /* We must initialize all our variables to NULL, so that
        -:11493:         `FREE_VARIABLES' doesn't try to free them.  */
    #####:11494:      regstart = regend = old_regstart = old_regend = best_regstart
    #####:11495:        = best_regend = reg_dummy = NULL;
    #####:11496:      reg_info = reg_info_dummy = (register_info_type *) NULL;
        -:11497:    }
        -:11498:#endif /* MATCH_MAY_ALLOCATE */
        -:11499:
        -:11500:  /* The starting position is bogus.  */
    #####:11501:  if (pos < 0 || pos > size1 + size2)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11502:    {
    #####:11503:      FREE_VARIABLES ();
    #####:11504:      return -1;
        -:11505:    }
        -:11506:
        -:11507:  /* Initialize subexpression text positions to -1 to mark ones that no
        -:11508:     start_memory/stop_memory has been seen for. Also initialize the
        -:11509:     register information struct.  */
    #####:11510:  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
branch  0 never executed
branch  1 never executed
        -:11511:    {
    #####:11512:      regstart[mcnt] = regend[mcnt]
    #####:11513:        = old_regstart[mcnt] = old_regend[mcnt] = REG_UNSET_VALUE;
        -:11514:
    #####:11515:      REG_MATCH_NULL_STRING_P (reg_info[mcnt]) = MATCH_NULL_UNSET_VALUE;
    #####:11516:      IS_ACTIVE (reg_info[mcnt]) = 0;
    #####:11517:      MATCHED_SOMETHING (reg_info[mcnt]) = 0;
    #####:11518:      EVER_MATCHED_SOMETHING (reg_info[mcnt]) = 0;
        -:11519:    }
        -:11520:
        -:11521:  /* We move `string1' into `string2' if the latter's empty -- but not if
        -:11522:     `string1' is null.  */
    #####:11523:  if (size2 == 0 && string1 != NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11524:    {
    #####:11525:      string2 = string1;
    #####:11526:      size2 = size1;
    #####:11527:      string1 = 0;
    #####:11528:      size1 = 0;
        -:11529:    }
    #####:11530:  end1 = string1 + size1;
    #####:11531:  end2 = string2 + size2;
        -:11532:
        -:11533:  /* Compute where to stop matching, within the two strings.  */
    #####:11534:  if (stop <= size1)
branch  0 never executed
branch  1 never executed
        -:11535:    {
    #####:11536:      end_match_1 = string1 + stop;
    #####:11537:      end_match_2 = string2;
        -:11538:    }
        -:11539:  else
        -:11540:    {
    #####:11541:      end_match_1 = end1;
    #####:11542:      end_match_2 = string2 + stop - size1;
        -:11543:    }
        -:11544:
        -:11545:  /* `p' scans through the pattern as `d' scans through the data.
        -:11546:     `dend' is the end of the input string that `d' points within.  `d'
        -:11547:     is advanced into the following input string whenever necessary, but
        -:11548:     this happens before fetching; therefore, at the beginning of the
        -:11549:     loop, `d' can be pointing at the end of a string, but it cannot
        -:11550:     equal `string2'.  */
    #####:11551:  if (size1 > 0 && pos <= size1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11552:    {
    #####:11553:      d = string1 + pos;
    #####:11554:      dend = end_match_1;
        -:11555:    }
        -:11556:  else
        -:11557:    {
    #####:11558:      d = string2 + pos - size1;
    #####:11559:      dend = end_match_2;
        -:11560:    }
        -:11561:
        -:11562:  DEBUG_PRINT1 ("The compiled pattern is:\n");
        -:11563:  DEBUG_PRINT_COMPILED_PATTERN (bufp, p, pend);
        -:11564:  DEBUG_PRINT1 ("The string to match is: `");
        -:11565:  DEBUG_PRINT_DOUBLE_STRING (d, string1, size1, string2, size2);
        -:11566:  DEBUG_PRINT1 ("'\n");
        -:11567:
        -:11568:  /* This loops over pattern commands.  It exits by returning from the
        -:11569:     function if the match is complete, or it drops through if the match
        -:11570:     fails at this starting point in the input data.  */
        -:11571:  for (;;)
        -:11572:    {
        -:11573:#ifdef _LIBC
        -:11574:      DEBUG_PRINT2 ("\n%p: ", p);
        -:11575:#else
        -:11576:      DEBUG_PRINT2 ("\n0x%x: ", p);
        -:11577:#endif
        -:11578:
    #####:11579:      if (p == pend)
branch  0 never executed
branch  1 never executed
        -:11580:	{ /* End of pattern means we might have succeeded.  */
        -:11581:          DEBUG_PRINT1 ("end of pattern ... ");
        -:11582:
        -:11583:	  /* If we haven't matched the entire string, and we want the
        -:11584:             longest match, try backtracking.  */
    #####:11585:          if (d != end_match_2)
branch  0 never executed
branch  1 never executed
        -:11586:	    {
        -:11587:	      /* 1 if this match ends in the same string (string1 or string2)
        -:11588:		 as the best previous match.  */
    #####:11589:	      boolean same_str_p = (FIRST_STRING_P (match_end)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:11590:				    == MATCHING_IN_FIRST_STRING);
        -:11591:	      /* 1 if this match is the best seen so far.  */
        -:11592:	      boolean best_match_p;
        -:11593:
        -:11594:	      /* AIX compiler got confused when this was combined
        -:11595:		 with the previous declaration.  */
    #####:11596:	      if (same_str_p)
branch  0 never executed
branch  1 never executed
    #####:11597:		best_match_p = d > match_end;
        -:11598:	      else
    #####:11599:		best_match_p = !MATCHING_IN_FIRST_STRING;
        -:11600:
        -:11601:              DEBUG_PRINT1 ("backtracking.\n");
        -:11602:
    #####:11603:              if (!FAIL_STACK_EMPTY ())
branch  0 never executed
branch  1 never executed
        -:11604:                { /* More failure points to try.  */
        -:11605:
        -:11606:                  /* If exceeds best match so far, save it.  */
    #####:11607:                  if (!best_regs_set || best_match_p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11608:                    {
    #####:11609:                      best_regs_set = true;
    #####:11610:                      match_end = d;
        -:11611:
        -:11612:                      DEBUG_PRINT1 ("\nSAVING match as best so far.\n");
        -:11613:
    #####:11614:                      for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
branch  0 never executed
branch  1 never executed
        -:11615:                        {
    #####:11616:                          best_regstart[mcnt] = regstart[mcnt];
    #####:11617:                          best_regend[mcnt] = regend[mcnt];
        -:11618:                        }
        -:11619:                    }
    #####:11620:                  goto fail;
        -:11621:                }
        -:11622:
        -:11623:              /* If no failure points, don't restore garbage.  And if
        -:11624:                 last match is real best match, don't restore second
        -:11625:                 best one. */
    #####:11626:              else if (best_regs_set && !best_match_p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11627:                {
    #####:11628:  	        restore_best_regs:
        -:11629:                  /* Restore best match.  It may happen that `dend ==
        -:11630:                     end_match_1' while the restored d is in string2.
        -:11631:                     For example, the pattern `x.*y.*z' against the
        -:11632:                     strings `x-' and `y-z-', if the two strings are
        -:11633:                     not consecutive in memory.  */
        -:11634:                  DEBUG_PRINT1 ("Restoring best registers.\n");
        -:11635:
    #####:11636:                  d = match_end;
    #####:11637:                  dend = ((d >= string1 && d <= end1)
branch  0 never executed
branch  1 never executed
    #####:11638:		           ? end_match_1 : end_match_2);
branch  0 never executed
branch  1 never executed
        -:11639:
    #####:11640:		  for (mcnt = 1; (unsigned) mcnt < num_regs; mcnt++)
branch  0 never executed
branch  1 never executed
        -:11641:		    {
    #####:11642:		      regstart[mcnt] = best_regstart[mcnt];
    #####:11643:		      regend[mcnt] = best_regend[mcnt];
        -:11644:		    }
        -:11645:                }
        -:11646:            } /* d != end_match_2 */
        -:11647:
    #####:11648:	succeed_label:
        -:11649:          DEBUG_PRINT1 ("Accepting match.\n");
        -:11650:
        -:11651:          /* If caller wants register contents data back, do it.  */
    #####:11652:          if (regs && !bufp->no_sub)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11653:	    {
        -:11654:              /* Have the register data arrays been allocated?  */
    #####:11655:              if (bufp->regs_allocated == REGS_UNALLOCATED)
branch  0 never executed
branch  1 never executed
        -:11656:                { /* No.  So allocate them with malloc.  We need one
        -:11657:                     extra element beyond `num_regs' for the `-1' marker
        -:11658:                     GNU code uses.  */
    #####:11659:                  regs->num_regs = MAX (RE_NREGS, num_regs + 1);
    #####:11660:                  regs->start = TALLOC (regs->num_regs, regoff_t);
call    0 never executed
    #####:11661:                  regs->end = TALLOC (regs->num_regs, regoff_t);
call    0 never executed
    #####:11662:                  if (regs->start == NULL || regs->end == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11663:		    {
    #####:11664:		      FREE_VARIABLES ();
    #####:11665:		      return -2;
        -:11666:		    }
    #####:11667:                  bufp->regs_allocated = REGS_REALLOCATE;
        -:11668:                }
    #####:11669:              else if (bufp->regs_allocated == REGS_REALLOCATE)
branch  0 never executed
branch  1 never executed
        -:11670:                { /* Yes.  If we need more elements than were already
        -:11671:                     allocated, reallocate them.  If we need fewer, just
        -:11672:                     leave it alone.  */
    #####:11673:                  if (regs->num_regs < num_regs + 1)
branch  0 never executed
branch  1 never executed
        -:11674:                    {
    #####:11675:                      regs->num_regs = num_regs + 1;
    #####:11676:                      RETALLOC (regs->start, regs->num_regs, regoff_t);
    #####:11677:                      RETALLOC (regs->end, regs->num_regs, regoff_t);
    #####:11678:                      if (regs->start == NULL || regs->end == NULL)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11679:			{
    #####:11680:			  FREE_VARIABLES ();
    #####:11681:			  return -2;
        -:11682:			}
        -:11683:                    }
        -:11684:                }
        -:11685:              else
        -:11686:		{
        -:11687:		  /* These braces fend off a "empty body in an else-statement"
        -:11688:		     warning under GCC when assert expands to nothing.  */
        -:11689:		  assert (bufp->regs_allocated == REGS_FIXED);
        -:11690:		}
        -:11691:
        -:11692:              /* Convert the pointer data in `regstart' and `regend' to
        -:11693:                 indices.  Register zero has to be set differently,
        -:11694:                 since we haven't kept track of any info for it.  */
    #####:11695:              if (regs->num_regs > 0)
branch  0 never executed
branch  1 never executed
        -:11696:                {
    #####:11697:                  regs->start[0] = pos;
    #####:11698:                  regs->end[0] = (MATCHING_IN_FIRST_STRING
    #####:11699:				  ? ((regoff_t) (d - string1))
    #####:11700:			          : ((regoff_t) (d - string2 + size1)));
branch  0 never executed
branch  1 never executed
        -:11701:                }
        -:11702:
        -:11703:              /* Go through the first `min (num_regs, regs->num_regs)'
        -:11704:                 registers, since that is all we initialized.  */
    #####:11705:	      for (mcnt = 1; (unsigned) mcnt < MIN (num_regs, regs->num_regs);
branch  0 never executed
branch  1 never executed
    #####:11706:		   mcnt++)
        -:11707:		{
    #####:11708:                  if (REG_UNSET (regstart[mcnt]) || REG_UNSET (regend[mcnt]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11709:                    regs->start[mcnt] = regs->end[mcnt] = -1;
        -:11710:                  else
        -:11711:                    {
    #####:11712:		      regs->start[mcnt]
    #####:11713:			= (regoff_t) POINTER_TO_OFFSET (regstart[mcnt]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:11714:                      regs->end[mcnt]
    #####:11715:			= (regoff_t) POINTER_TO_OFFSET (regend[mcnt]);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:11716:                    }
        -:11717:		}
        -:11718:
        -:11719:              /* If the regs structure we return has more elements than
        -:11720:                 were in the pattern, set the extra elements to -1.  If
        -:11721:                 we (re)allocated the registers, this is the case,
        -:11722:                 because we always allocate enough to have at least one
        -:11723:                 -1 at the end.  */
    #####:11724:              for (mcnt = num_regs; (unsigned) mcnt < regs->num_regs; mcnt++)
branch  0 never executed
branch  1 never executed
    #####:11725:                regs->start[mcnt] = regs->end[mcnt] = -1;
        -:11726:	    } /* regs && !bufp->no_sub */
        -:11727:
        -:11728:          DEBUG_PRINT4 ("%u failure points pushed, %u popped (%u remain).\n",
        -:11729:                        nfailure_points_pushed, nfailure_points_popped,
        -:11730:                        nfailure_points_pushed - nfailure_points_popped);
        -:11731:          DEBUG_PRINT2 ("%u registers pushed.\n", num_regs_pushed);
        -:11732:
    #####:11733:          mcnt = d - pos - (MATCHING_IN_FIRST_STRING
        -:11734:			    ? string1
    #####:11735:			    : string2 - size1);
branch  0 never executed
branch  1 never executed
        -:11736:
        -:11737:          DEBUG_PRINT2 ("Returning %d from re_match_2.\n", mcnt);
        -:11738:
    #####:11739:          FREE_VARIABLES ();
    #####:11740:          return mcnt;
        -:11741:        }
        -:11742:
        -:11743:      /* Otherwise match next pattern command.  */
    #####:11744:      switch (SWITCH_ENUM_CAST ((re_opcode_t) *p++))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
branch 18 never executed
branch 19 never executed
branch 20 never executed
branch 21 never executed
branch 22 never executed
branch 23 never executed
branch 24 never executed
branch 25 never executed
branch 26 never executed
branch 27 never executed
branch 28 never executed
branch 29 never executed
        -:11745:	{
        -:11746:        /* Ignore these.  Used to ignore the n of succeed_n's which
        -:11747:           currently have n == 0.  */
    #####:11748:        case no_op:
        -:11749:          DEBUG_PRINT1 ("EXECUTING no_op.\n");
    #####:11750:          break;
        -:11751:
    #####:11752:	case succeed:
        -:11753:          DEBUG_PRINT1 ("EXECUTING succeed.\n");
    #####:11754:	  goto succeed_label;
        -:11755:
        -:11756:        /* Match the next n pattern characters exactly.  The following
        -:11757:           byte in the pattern defines n, and the n bytes after that
        -:11758:           are the characters to match.  */
    #####:11759:	case exactn:
    #####:11760:	  mcnt = *p++;
        -:11761:          DEBUG_PRINT2 ("EXECUTING exactn %d.\n", mcnt);
        -:11762:
        -:11763:          /* This is written out as an if-else so we don't waste time
        -:11764:             testing `translate' inside the loop.  */
    #####:11765:          if (translate)
branch  0 never executed
branch  1 never executed
        -:11766:	    {
        -:11767:	      do
        -:11768:		{
    #####:11769:		  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11770:		  if ((unsigned char) translate[(unsigned char) *d++]
    #####:11771:		      != (unsigned char) *p++)
branch  0 never executed
branch  1 never executed
    #####:11772:                    goto fail;
        -:11773:		}
    #####:11774:	      while (--mcnt);
branch  0 never executed
branch  1 never executed
        -:11775:	    }
        -:11776:	  else
        -:11777:	    {
        -:11778:	      do
        -:11779:		{
    #####:11780:		  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11781:		  if (*d++ != (char) *p++) goto fail;
branch  0 never executed
branch  1 never executed
        -:11782:		}
    #####:11783:	      while (--mcnt);
branch  0 never executed
branch  1 never executed
        -:11784:	    }
    #####:11785:	  SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11786:          break;
        -:11787:
        -:11788:
        -:11789:        /* Match any character except possibly a newline or a null.  */
    #####:11790:	case anychar:
        -:11791:          DEBUG_PRINT1 ("EXECUTING anychar.\n");
        -:11792:
    #####:11793:          PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11794:
    #####:11795:          if ((!(bufp->syntax & RE_DOT_NEWLINE) && TRANSLATE (*d) == '\n')
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:11796:              || (bufp->syntax & RE_DOT_NOT_NULL && TRANSLATE (*d) == '\000'))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:11797:	    goto fail;
        -:11798:
    #####:11799:          SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11800:          DEBUG_PRINT2 ("  Matched `%d'.\n", *d);
    #####:11801:          d++;
    #####:11802:	  break;
        -:11803:
        -:11804:
    #####:11805:	case charset:
        -:11806:	case charset_not:
        -:11807:	  {
        -:11808:	    register unsigned char c;
    #####:11809:	    boolean not = (re_opcode_t) *(p - 1) == charset_not;
        -:11810:
        -:11811:            DEBUG_PRINT2 ("EXECUTING charset%s.\n", not ? "_not" : "");
        -:11812:
    #####:11813:	    PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11814:	    c = TRANSLATE (*d); /* The character to match.  */
branch  0 never executed
branch  1 never executed
        -:11815:
        -:11816:            /* Cast to `unsigned' instead of `unsigned char' in case the
        -:11817:               bit list is a full 32 bytes long.  */
    #####:11818:	    if (c < (unsigned) (*p * BYTEWIDTH)
branch  0 never executed
branch  1 never executed
    #####:11819:		&& p[1 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
branch  0 never executed
branch  1 never executed
    #####:11820:	      not = !not;
        -:11821:
    #####:11822:	    p += 1 + *p;
        -:11823:
    #####:11824:	    if (!not) goto fail;
branch  0 never executed
branch  1 never executed
        -:11825:
    #####:11826:	    SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11827:            d++;
    #####:11828:	    break;
        -:11829:	  }
        -:11830:
        -:11831:
        -:11832:        /* The beginning of a group is represented by start_memory.
        -:11833:           The arguments are the register number in the next byte, and the
        -:11834:           number of groups inner to this one in the next.  The text
        -:11835:           matched within the group is recorded (in the internal
        -:11836:           registers data structure) under the register number.  */
    #####:11837:        case start_memory:
        -:11838:	  DEBUG_PRINT3 ("EXECUTING start_memory %d (%d):\n", *p, p[1]);
        -:11839:
        -:11840:          /* Find out if this group can match the empty string.  */
    #####:11841:	  p1 = p;		/* To send to group_match_null_string_p.  */
        -:11842:
    #####:11843:          if (REG_MATCH_NULL_STRING_P (reg_info[*p]) == MATCH_NULL_UNSET_VALUE)
branch  0 never executed
branch  1 never executed
    #####:11844:            REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####:11845:              = group_match_null_string_p (&p1, pend, reg_info);
call    0 never executed
        -:11846:
        -:11847:          /* Save the position in the string where we were the last time
        -:11848:             we were at this open-group operator in case the group is
        -:11849:             operated upon by a repetition operator, e.g., with `(a*)*b'
        -:11850:             against `ab'; then we want to ignore where we are now in
        -:11851:             the string in case this attempt to match fails.  */
    #####:11852:          old_regstart[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####:11853:                             ? REG_UNSET (regstart[*p]) ? d : regstart[*p]
branch  0 never executed
branch  1 never executed
    #####:11854:                             : regstart[*p];
branch  0 never executed
branch  1 never executed
        -:11855:	  DEBUG_PRINT2 ("  old_regstart: %d\n",
        -:11856:			 POINTER_TO_OFFSET (old_regstart[*p]));
        -:11857:
    #####:11858:          regstart[*p] = d;
        -:11859:	  DEBUG_PRINT2 ("  regstart: %d\n", POINTER_TO_OFFSET (regstart[*p]));
        -:11860:
    #####:11861:          IS_ACTIVE (reg_info[*p]) = 1;
    #####:11862:          MATCHED_SOMETHING (reg_info[*p]) = 0;
        -:11863:
        -:11864:	  /* Clear this whenever we change the register activity status.  */
    #####:11865:	  set_regs_matched_done = 0;
        -:11866:
        -:11867:          /* This is the new highest active register.  */
    #####:11868:          highest_active_reg = *p;
        -:11869:
        -:11870:          /* If nothing was active before, this is the new lowest active
        -:11871:             register.  */
    #####:11872:          if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
branch  0 never executed
branch  1 never executed
    #####:11873:            lowest_active_reg = *p;
        -:11874:
        -:11875:          /* Move past the register number and inner group count.  */
    #####:11876:          p += 2;
    #####:11877:	  just_past_start_mem = p;
        -:11878:
    #####:11879:          break;
        -:11880:
        -:11881:
        -:11882:        /* The stop_memory opcode represents the end of a group.  Its
        -:11883:           arguments are the same as start_memory's: the register
        -:11884:           number, and the number of inner groups.  */
    #####:11885:	case stop_memory:
        -:11886:	  DEBUG_PRINT3 ("EXECUTING stop_memory %d (%d):\n", *p, p[1]);
        -:11887:
        -:11888:          /* We need to save the string position the last time we were at
        -:11889:             this close-group operator in case the group is operated
        -:11890:             upon by a repetition operator, e.g., with `((a*)*(b*)*)*'
        -:11891:             against `aba'; then we want to ignore where we are now in
        -:11892:             the string in case this attempt to match fails.  */
    #####:11893:          old_regend[*p] = REG_MATCH_NULL_STRING_P (reg_info[*p])
    #####:11894:                           ? REG_UNSET (regend[*p]) ? d : regend[*p]
branch  0 never executed
branch  1 never executed
    #####:11895:			   : regend[*p];
branch  0 never executed
branch  1 never executed
        -:11896:	  DEBUG_PRINT2 ("      old_regend: %d\n",
        -:11897:			 POINTER_TO_OFFSET (old_regend[*p]));
        -:11898:
    #####:11899:          regend[*p] = d;
        -:11900:	  DEBUG_PRINT2 ("      regend: %d\n", POINTER_TO_OFFSET (regend[*p]));
        -:11901:
        -:11902:          /* This register isn't active anymore.  */
    #####:11903:          IS_ACTIVE (reg_info[*p]) = 0;
        -:11904:
        -:11905:	  /* Clear this whenever we change the register activity status.  */
    #####:11906:	  set_regs_matched_done = 0;
        -:11907:
        -:11908:          /* If this was the only register active, nothing is active
        -:11909:             anymore.  */
    #####:11910:          if (lowest_active_reg == highest_active_reg)
branch  0 never executed
branch  1 never executed
        -:11911:            {
    #####:11912:              lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####:11913:              highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -:11914:            }
        -:11915:          else
        -:11916:            { /* We must scan for the new highest active register, since
        -:11917:                 it isn't necessarily one less than now: consider
        -:11918:                 (a(b)c(d(e)f)g).  When group 3 ends, after the f), the
        -:11919:                 new highest active register is 1.  */
    #####:11920:              unsigned char r = *p - 1;
    #####:11921:              while (r > 0 && !IS_ACTIVE (reg_info[r]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11922:                r--;
        -:11923:
        -:11924:              /* If we end up at register zero, that means that we saved
        -:11925:                 the registers as the result of an `on_failure_jump', not
        -:11926:                 a `start_memory', and we jumped to past the innermost
        -:11927:                 `stop_memory'.  For example, in ((.)*) we save
        -:11928:                 registers 1 and 2 as a result of the *, but when we pop
        -:11929:                 back to the second ), we are at the stop_memory 1.
        -:11930:                 Thus, nothing is active.  */
    #####:11931:	      if (r == 0)
branch  0 never executed
branch  1 never executed
        -:11932:                {
    #####:11933:                  lowest_active_reg = NO_LOWEST_ACTIVE_REG;
    #####:11934:                  highest_active_reg = NO_HIGHEST_ACTIVE_REG;
        -:11935:                }
        -:11936:              else
    #####:11937:                highest_active_reg = r;
        -:11938:            }
        -:11939:
        -:11940:          /* If just failed to match something this time around with a
        -:11941:             group that's operated on by a repetition operator, try to
        -:11942:             force exit from the ``loop'', and restore the register
        -:11943:             information for this group that we had before trying this
        -:11944:             last match.  */
    #####:11945:          if ((!MATCHED_SOMETHING (reg_info[*p])
branch  0 never executed
branch  1 never executed
    #####:11946:               || just_past_start_mem == p - 1)
branch  0 never executed
branch  1 never executed
    #####:11947:	      && (p + 2) < pend)
branch  0 never executed
branch  1 never executed
        -:11948:            {
    #####:11949:              boolean is_a_jump_n = false;
        -:11950:
    #####:11951:              p1 = p + 2;
    #####:11952:              mcnt = 0;
    #####:11953:              switch ((re_opcode_t) *p1++)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:11954:                {
    #####:11955:                  case jump_n:
    #####:11956:		    is_a_jump_n = true;
    #####:11957:                  case pop_failure_jump:
        -:11958:		  case maybe_pop_jump:
        -:11959:		  case jump:
        -:11960:		  case dummy_failure_jump:
    #####:11961:                    EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:11962:		    if (is_a_jump_n)
branch  0 never executed
branch  1 never executed
    #####:11963:		      p1 += 2;
    #####:11964:                    break;
        -:11965:
    #####:11966:                  default:
        -:11967:                    /* do nothing */ ;
        -:11968:                }
    #####:11969:	      p1 += mcnt;
        -:11970:
        -:11971:              /* If the next operation is a jump backwards in the pattern
        -:11972:	         to an on_failure_jump right before the start_memory
        -:11973:                 corresponding to this stop_memory, exit from the loop
        -:11974:                 by forcing a failure after pushing on the stack the
        -:11975:                 on_failure_jump's jump in the pattern, and d.  */
    #####:11976:              if (mcnt < 0 && (re_opcode_t) *p1 == on_failure_jump
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:11977:                  && (re_opcode_t) p1[3] == start_memory && p1[4] == *p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:11978:		{
        -:11979:                  /* If this group ever matched anything, then restore
        -:11980:                     what its registers were before trying this last
        -:11981:                     failed match, e.g., with `(a*)*b' against `ab' for
        -:11982:                     regstart[1], and, e.g., with `((a*)*(b*)*)*'
        -:11983:                     against `aba' for regend[3].
        -:11984:
        -:11985:                     Also restore the registers for inner groups for,
        -:11986:                     e.g., `((a*)(b*))*' against `aba' (register 3 would
        -:11987:                     otherwise get trashed).  */
        -:11988:
    #####:11989:                  if (EVER_MATCHED_SOMETHING (reg_info[*p]))
branch  0 never executed
branch  1 never executed
        -:11990:		    {
        -:11991:		      unsigned r;
        -:11992:
    #####:11993:                      EVER_MATCHED_SOMETHING (reg_info[*p]) = 0;
        -:11994:
        -:11995:		      /* Restore this and inner groups' (if any) registers.  */
    #####:11996:                      for (r = *p; r < (unsigned) *p + (unsigned) *(p + 1);
branch  0 never executed
branch  1 never executed
    #####:11997:			   r++)
        -:11998:                        {
    #####:11999:                          regstart[r] = old_regstart[r];
        -:12000:
        -:12001:                          /* xx why this test?  */
    #####:12002:                          if (old_regend[r] >= regstart[r])
branch  0 never executed
branch  1 never executed
    #####:12003:                            regend[r] = old_regend[r];
        -:12004:                        }
        -:12005:                    }
    #####:12006:		  p1++;
    #####:12007:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12008:                  PUSH_FAILURE_POINT (p1 + mcnt, d, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
        -:12009:
    #####:12010:                  goto fail;
        -:12011:                }
        -:12012:            }
        -:12013:
        -:12014:          /* Move past the register number and the inner group count.  */
    #####:12015:          p += 2;
    #####:12016:          break;
        -:12017:
        -:12018:
        -:12019:	/* \<digit> has been turned into a `duplicate' command which is
        -:12020:           followed by the numeric value of <digit> as the register number.  */
    #####:12021:        case duplicate:
        -:12022:	  {
        -:12023:	    register const char *d2, *dend2;
    #####:12024:	    int regno = *p++;   /* Get which register to match against.  */
        -:12025:	    DEBUG_PRINT2 ("EXECUTING duplicate %d.\n", regno);
        -:12026:
        -:12027:	    /* Can't back reference a group which we've never matched.  */
    #####:12028:            if (REG_UNSET (regstart[regno]) || REG_UNSET (regend[regno]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12029:              goto fail;
        -:12030:
        -:12031:            /* Where in input to try to start matching.  */
    #####:12032:            d2 = regstart[regno];
        -:12033:
        -:12034:            /* Where to stop matching; if both the place to start and
        -:12035:               the place to stop matching are in the same string, then
        -:12036:               set to the place to stop, otherwise, for now have to use
        -:12037:               the end of the first string.  */
        -:12038:
    #####:12039:            dend2 = ((FIRST_STRING_P (regstart[regno])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:12040:		      == FIRST_STRING_P (regend[regno]))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:12041:		     ? regend[regno] : end_match_1);
branch  0 never executed
branch  1 never executed
        -:12042:	    for (;;)
        -:12043:	      {
        -:12044:		/* If necessary, advance to next segment in register
        -:12045:                   contents.  */
    #####:12046:		while (d2 == dend2)
branch  0 never executed
branch  1 never executed
        -:12047:		  {
    #####:12048:		    if (dend2 == end_match_2) break;
branch  0 never executed
branch  1 never executed
    #####:12049:		    if (dend2 == regend[regno]) break;
branch  0 never executed
branch  1 never executed
        -:12050:
        -:12051:                    /* End of string1 => advance to string2. */
    #####:12052:                    d2 = string2;
    #####:12053:                    dend2 = regend[regno];
        -:12054:		  }
        -:12055:		/* At end of register contents => success */
    #####:12056:		if (d2 == dend2) break;
branch  0 never executed
branch  1 never executed
        -:12057:
        -:12058:		/* If necessary, advance to next segment in data.  */
    #####:12059:		PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12060:
        -:12061:		/* How many characters left in this segment to match.  */
    #####:12062:		mcnt = dend - d;
        -:12063:
        -:12064:		/* Want how many consecutive characters we can match in
        -:12065:                   one shot, so, if necessary, adjust the count.  */
    #####:12066:                if (mcnt > dend2 - d2)
branch  0 never executed
branch  1 never executed
    #####:12067:		  mcnt = dend2 - d2;
        -:12068:
        -:12069:		/* Compare that many; failure if mismatch, else move
        -:12070:                   past them.  */
    #####:12071:		if (translate
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12072:                    ? bcmp_translate (d, d2, mcnt, translate)
call    0 never executed
    #####:12073:                    : memcmp (d, d2, mcnt))
    #####:12074:		  goto fail;
    #####:12075:		d += mcnt, d2 += mcnt;
        -:12076:
        -:12077:		/* Do this because we've match some characters.  */
    #####:12078:		SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12079:	      }
        -:12080:	  }
    #####:12081:	  break;
        -:12082:
        -:12083:
        -:12084:        /* begline matches the empty string at the beginning of the string
        -:12085:           (unless `not_bol' is set in `bufp'), and, if
        -:12086:           `newline_anchor' is set, after newlines.  */
    #####:12087:	case begline:
        -:12088:          DEBUG_PRINT1 ("EXECUTING begline.\n");
        -:12089:
    #####:12090:          if (AT_STRINGS_BEG (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:12091:            {
    #####:12092:              if (!bufp->not_bol) break;
branch  0 never executed
branch  1 never executed
        -:12093:            }
    #####:12094:          else if (d[-1] == '\n' && bufp->newline_anchor)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12095:            {
    #####:12096:              break;
        -:12097:            }
        -:12098:          /* In all other cases, we fail.  */
    #####:12099:          goto fail;
        -:12100:
        -:12101:
        -:12102:        /* endline is the dual of begline.  */
    #####:12103:	case endline:
        -:12104:          DEBUG_PRINT1 ("EXECUTING endline.\n");
        -:12105:
    #####:12106:          if (AT_STRINGS_END (d))
branch  0 never executed
branch  1 never executed
        -:12107:            {
    #####:12108:              if (!bufp->not_eol) break;
branch  0 never executed
branch  1 never executed
        -:12109:            }
        -:12110:
        -:12111:          /* We have to ``prefetch'' the next character.  */
    #####:12112:          else if ((d == end1 ? *string2 : *d) == '\n'
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12113:                   && bufp->newline_anchor)
branch  0 never executed
branch  1 never executed
        -:12114:            {
    #####:12115:              break;
        -:12116:            }
    #####:12117:          goto fail;
        -:12118:
        -:12119:
        -:12120:	/* Match at the very beginning of the data.  */
    #####:12121:        case begbuf:
        -:12122:          DEBUG_PRINT1 ("EXECUTING begbuf.\n");
    #####:12123:          if (AT_STRINGS_BEG (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
        -:12124:            break;
    #####:12125:          goto fail;
        -:12126:
        -:12127:
        -:12128:	/* Match at the very end of the data.  */
    #####:12129:        case endbuf:
        -:12130:          DEBUG_PRINT1 ("EXECUTING endbuf.\n");
    #####:12131:	  if (AT_STRINGS_END (d))
branch  0 never executed
branch  1 never executed
    #####:12132:	    break;
    #####:12133:          goto fail;
        -:12134:
        -:12135:
        -:12136:        /* on_failure_keep_string_jump is used to optimize `.*\n'.  It
        -:12137:           pushes NULL as the value for the string on the stack.  Then
        -:12138:           `pop_failure_point' will keep the current value for the
        -:12139:           string, instead of restoring it.  To see why, consider
        -:12140:           matching `foo\nbar' against `.*\n'.  The .* matches the foo;
        -:12141:           then the . fails against the \n.  But the next thing we want
        -:12142:           to do is match the \n against the \n; if we restored the
        -:12143:           string value, we would be back at the foo.
        -:12144:
        -:12145:           Because this is used only in specific cases, we don't need to
        -:12146:           check all the things that `on_failure_jump' does, to make
        -:12147:           sure the right things get saved on the stack.  Hence we don't
        -:12148:           share its code.  The only reason to push anything on the
        -:12149:           stack at all is that otherwise we would have to change
        -:12150:           `anychar's code to do something besides goto fail in this
        -:12151:           case; that seems worse than this.  */
    #####:12152:        case on_failure_keep_string_jump:
        -:12153:          DEBUG_PRINT1 ("EXECUTING on_failure_keep_string_jump");
        -:12154:
    #####:12155:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -:12156:#ifdef _LIBC
        -:12157:          DEBUG_PRINT3 (" %d (to %p):\n", mcnt, p + mcnt);
        -:12158:#else
        -:12159:          DEBUG_PRINT3 (" %d (to 0x%x):\n", mcnt, p + mcnt);
        -:12160:#endif
        -:12161:
    #####:12162:          PUSH_FAILURE_POINT (p + mcnt, NULL, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:12163:          break;
        -:12164:
        -:12165:
        -:12166:	/* Uses of on_failure_jump:
        -:12167:
        -:12168:           Each alternative starts with an on_failure_jump that points
        -:12169:           to the beginning of the next alternative.  Each alternative
        -:12170:           except the last ends with a jump that in effect jumps past
        -:12171:           the rest of the alternatives.  (They really jump to the
        -:12172:           ending jump of the following alternative, because tensioning
        -:12173:           these jumps is a hassle.)
        -:12174:
        -:12175:           Repeats start with an on_failure_jump that points past both
        -:12176:           the repetition text and either the following jump or
        -:12177:           pop_failure_jump back to this on_failure_jump.  */
        -:12178:	case on_failure_jump:
    #####:12179:        on_failure:
        -:12180:          DEBUG_PRINT1 ("EXECUTING on_failure_jump");
        -:12181:
    #####:12182:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -:12183:#ifdef _LIBC
        -:12184:          DEBUG_PRINT3 (" %d (to %p)", mcnt, p + mcnt);
        -:12185:#else
        -:12186:          DEBUG_PRINT3 (" %d (to 0x%x)", mcnt, p + mcnt);
        -:12187:#endif
        -:12188:
        -:12189:          /* If this on_failure_jump comes right before a group (i.e.,
        -:12190:             the original * applied to a group), save the information
        -:12191:             for that group and all inner ones, so that if we fail back
        -:12192:             to this point, the group's information will be correct.
        -:12193:             For example, in \(a*\)*\1, we need the preceding group,
        -:12194:             and in \(zz\(a*\)b*\)\2, we need the inner group.  */
        -:12195:
        -:12196:          /* We can't use `p' to check ahead because we push
        -:12197:             a failure point to `p + mcnt' after we do this.  */
    #####:12198:          p1 = p;
        -:12199:
        -:12200:          /* We need to skip no_op's before we look for the
        -:12201:             start_memory in case this on_failure_jump is happening as
        -:12202:             the result of a completed succeed_n, as in \(a\)\{1,3\}b\1
        -:12203:             against aba.  */
    #####:12204:          while (p1 < pend && (re_opcode_t) *p1 == no_op)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12205:            p1++;
        -:12206:
    #####:12207:          if (p1 < pend && (re_opcode_t) *p1 == start_memory)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12208:            {
        -:12209:              /* We have a new highest active register now.  This will
        -:12210:                 get reset at the start_memory we are about to get to,
        -:12211:                 but we will have saved all the registers relevant to
        -:12212:                 this repetition op, as described above.  */
    #####:12213:              highest_active_reg = *(p1 + 1) + *(p1 + 2);
    #####:12214:              if (lowest_active_reg == NO_LOWEST_ACTIVE_REG)
branch  0 never executed
branch  1 never executed
    #####:12215:                lowest_active_reg = *(p1 + 1);
        -:12216:            }
        -:12217:
        -:12218:          DEBUG_PRINT1 (":\n");
    #####:12219:          PUSH_FAILURE_POINT (p + mcnt, d, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:12220:          break;
        -:12221:
        -:12222:
        -:12223:        /* A smart repeat ends with `maybe_pop_jump'.
        -:12224:	   We change it to either `pop_failure_jump' or `jump'.  */
    #####:12225:        case maybe_pop_jump:
    #####:12226:          EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -:12227:          DEBUG_PRINT2 ("EXECUTING maybe_pop_jump %d.\n", mcnt);
        -:12228:          {
    #####:12229:	    register unsigned char *p2 = p;
        -:12230:
        -:12231:            /* Compare the beginning of the repeat with what in the
        -:12232:               pattern follows its end. If we can establish that there
        -:12233:               is nothing that they would both match, i.e., that we
        -:12234:               would have to backtrack because of (as in, e.g., `a*a')
        -:12235:               then we can change to pop_failure_jump, because we'll
        -:12236:               never have to backtrack.
        -:12237:
        -:12238:               This is not true in the case of alternatives: in
        -:12239:               `(a|ab)*' we do need to backtrack to the `ab' alternative
        -:12240:               (e.g., if the string was `ab').  But instead of trying to
        -:12241:               detect that here, the alternative has put on a dummy
        -:12242:               failure point which is what we will end up popping.  */
        -:12243:
        -:12244:	    /* Skip over open/close-group commands.
        -:12245:	       If what follows this loop is a ...+ construct,
        -:12246:	       look at what begins its body, since we will have to
        -:12247:	       match at least one of that.  */
        -:12248:	    while (1)
        -:12249:	      {
    #####:12250:		if (p2 + 2 < pend
branch  0 never executed
branch  1 never executed
    #####:12251:		    && ((re_opcode_t) *p2 == stop_memory
branch  0 never executed
branch  1 never executed
    #####:12252:			|| (re_opcode_t) *p2 == start_memory))
branch  0 never executed
branch  1 never executed
    #####:12253:		  p2 += 3;
    #####:12254:		else if (p2 + 6 < pend
branch  0 never executed
branch  1 never executed
    #####:12255:			 && (re_opcode_t) *p2 == dummy_failure_jump)
branch  0 never executed
branch  1 never executed
    #####:12256:		  p2 += 6;
        -:12257:		else
        -:12258:		  break;
        -:12259:	      }
        -:12260:
    #####:12261:	    p1 = p + mcnt;
        -:12262:	    /* p1[0] ... p1[2] are the `on_failure_jump' corresponding
        -:12263:	       to the `maybe_finalize_jump' of this case.  Examine what
        -:12264:	       follows.  */
        -:12265:
        -:12266:            /* If we're at the end of the pattern, we can change.  */
    #####:12267:            if (p2 == pend)
branch  0 never executed
branch  1 never executed
        -:12268:	      {
        -:12269:		/* Consider what happens when matching ":\(.*\)"
        -:12270:		   against ":/".  I don't really understand this code
        -:12271:		   yet.  */
    #####:12272:  	        p[-3] = (unsigned char) pop_failure_jump;
        -:12273:                DEBUG_PRINT1
        -:12274:                  ("  End of pattern: change to `pop_failure_jump'.\n");
        -:12275:              }
        -:12276:
    #####:12277:            else if ((re_opcode_t) *p2 == exactn
branch  0 never executed
branch  1 never executed
    #####:12278:		     || (bufp->newline_anchor && (re_opcode_t) *p2 == endline))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12279:	      {
    #####:12280:		register unsigned char c
    #####:12281:                  = *p2 == (unsigned char) endline ? '\n' : p2[2];
branch  0 never executed
branch  1 never executed
        -:12282:
    #####:12283:                if ((re_opcode_t) p1[3] == exactn && p1[5] != c)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12284:                  {
    #####:12285:  		    p[-3] = (unsigned char) pop_failure_jump;
        -:12286:                    DEBUG_PRINT3 ("  %c != %c => pop_failure_jump.\n",
        -:12287:                                  c, p1[5]);
        -:12288:                  }
        -:12289:
    #####:12290:		else if ((re_opcode_t) p1[3] == charset
branch  0 never executed
branch  1 never executed
    #####:12291:			 || (re_opcode_t) p1[3] == charset_not)
branch  0 never executed
branch  1 never executed
        -:12292:		  {
    #####:12293:		    int not = (re_opcode_t) p1[3] == charset_not;
        -:12294:
    #####:12295:		    if (c < (unsigned char) (p1[4] * BYTEWIDTH)
branch  0 never executed
branch  1 never executed
    #####:12296:			&& p1[5 + c / BYTEWIDTH] & (1 << (c % BYTEWIDTH)))
branch  0 never executed
branch  1 never executed
    #####:12297:		      not = !not;
        -:12298:
        -:12299:                    /* `not' is equal to 1 if c would match, which means
        -:12300:                        that we can't change to pop_failure_jump.  */
    #####:12301:		    if (!not)
branch  0 never executed
branch  1 never executed
        -:12302:                      {
    #####:12303:  		        p[-3] = (unsigned char) pop_failure_jump;
        -:12304:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -:12305:                      }
        -:12306:		  }
        -:12307:	      }
    #####:12308:            else if ((re_opcode_t) *p2 == charset)
branch  0 never executed
branch  1 never executed
        -:12309:	      {
        -:12310:		/* We win if the first character of the loop is not part
        -:12311:                   of the charset.  */
    #####:12312:                if ((re_opcode_t) p1[3] == exactn
branch  0 never executed
branch  1 never executed
    #####:12313: 		    && ! ((int) p2[1] * BYTEWIDTH > (int) p1[5]
branch  0 never executed
branch  1 never executed
    #####:12314: 			  && (p2[2 + p1[5] / BYTEWIDTH]
    #####:12315: 			      & (1 << (p1[5] % BYTEWIDTH)))))
branch  0 never executed
branch  1 never executed
        -:12316:		  {
    #####:12317:		    p[-3] = (unsigned char) pop_failure_jump;
        -:12318:		    DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -:12319:                  }
        -:12320:
    #####:12321:		else if ((re_opcode_t) p1[3] == charset_not)
branch  0 never executed
branch  1 never executed
        -:12322:		  {
        -:12323:		    int idx;
        -:12324:		    /* We win if the charset_not inside the loop
        -:12325:		       lists every character listed in the charset after.  */
    #####:12326:		    for (idx = 0; idx < (int) p2[1]; idx++)
branch  0 never executed
branch  1 never executed
    #####:12327:		      if (! (p2[2 + idx] == 0
branch  0 never executed
branch  1 never executed
    #####:12328:			     || (idx < (int) p1[4]
branch  0 never executed
branch  1 never executed
    #####:12329:				 && ((p2[2 + idx] & ~ p1[5 + idx]) == 0))))
branch  0 never executed
branch  1 never executed
        -:12330:			break;
        -:12331:
    #####:12332:		    if (idx == p2[1])
branch  0 never executed
branch  1 never executed
        -:12333:                      {
    #####:12334:  		        p[-3] = (unsigned char) pop_failure_jump;
        -:12335:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -:12336:                      }
        -:12337:		  }
    #####:12338:		else if ((re_opcode_t) p1[3] == charset)
branch  0 never executed
branch  1 never executed
        -:12339:		  {
        -:12340:		    int idx;
        -:12341:		    /* We win if the charset inside the loop
        -:12342:		       has no overlap with the one after the loop.  */
    #####:12343:		    for (idx = 0;
    #####:12344:			 idx < (int) p2[1] && idx < (int) p1[4];
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12345:			 idx++)
    #####:12346:		      if ((p2[2 + idx] & p1[5 + idx]) != 0)
branch  0 never executed
branch  1 never executed
    #####:12347:			break;
        -:12348:
    #####:12349:		    if (idx == p2[1] || idx == p1[4])
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12350:                      {
    #####:12351:  		        p[-3] = (unsigned char) pop_failure_jump;
        -:12352:                        DEBUG_PRINT1 ("  No match => pop_failure_jump.\n");
        -:12353:                      }
        -:12354:		  }
        -:12355:	      }
        -:12356:	  }
    #####:12357:	  p -= 2;		/* Point at relative address again.  */
    #####:12358:	  if ((re_opcode_t) p[-1] != pop_failure_jump)
branch  0 never executed
branch  1 never executed
        -:12359:	    {
    #####:12360:	      p[-1] = (unsigned char) jump;
        -:12361:              DEBUG_PRINT1 ("  Match => jump.\n");
    #####:12362:	      goto unconditional_jump;
        -:12363:	    }
        -:12364:        /* Note fall through.  */
        -:12365:
        -:12366:
        -:12367:	/* The end of a simple repeat has a pop_failure_jump back to
        -:12368:           its matching on_failure_jump, where the latter will push a
        -:12369:           failure point.  The pop_failure_jump takes off failure
        -:12370:           points put on by this pop_failure_jump's matching
        -:12371:           on_failure_jump; we got through the pattern to here from the
        -:12372:           matching on_failure_jump, so didn't fail.  */
        -:12373:        case pop_failure_jump:
        -:12374:          {
        -:12375:            /* We need to pass separate storage for the lowest and
        -:12376:               highest registers, even though we don't care about the
        -:12377:               actual values.  Otherwise, we will restore only one
        -:12378:               register from the stack, since lowest will == highest in
        -:12379:               `pop_failure_point'.  */
        -:12380:            active_reg_t dummy_low_reg, dummy_high_reg;
        -:12381:            unsigned char *pdummy;
        -:12382:            const char *sdummy;
        -:12383:
        -:12384:            DEBUG_PRINT1 ("EXECUTING pop_failure_jump.\n");
    #####:12385:            POP_FAILURE_POINT (sdummy, pdummy,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12386:                               dummy_low_reg, dummy_high_reg,
        -:12387:                               reg_dummy, reg_dummy, reg_info_dummy);
        -:12388:          }
        -:12389:	  /* Note fall through.  */
        -:12390:
    #####:12391:	unconditional_jump:
        -:12392:#ifdef _LIBC
        -:12393:	  DEBUG_PRINT2 ("\n%p: ", p);
        -:12394:#else
        -:12395:	  DEBUG_PRINT2 ("\n0x%x: ", p);
        -:12396:#endif
        -:12397:          /* Note fall through.  */
        -:12398:
        -:12399:        /* Unconditionally jump (without popping any failure points).  */
    #####:12400:        case jump:
    #####:12401:	  EXTRACT_NUMBER_AND_INCR (mcnt, p);	/* Get the amount to jump.  */
        -:12402:          DEBUG_PRINT2 ("EXECUTING jump %d ", mcnt);
    #####:12403:	  p += mcnt;				/* Do the jump.  */
        -:12404:#ifdef _LIBC
        -:12405:          DEBUG_PRINT2 ("(to %p).\n", p);
        -:12406:#else
        -:12407:          DEBUG_PRINT2 ("(to 0x%x).\n", p);
        -:12408:#endif
    #####:12409:	  break;
        -:12410:
        -:12411:
        -:12412:        /* We need this opcode so we can detect where alternatives end
        -:12413:           in `group_match_null_string_p' et al.  */
    #####:12414:        case jump_past_alt:
        -:12415:          DEBUG_PRINT1 ("EXECUTING jump_past_alt.\n");
    #####:12416:          goto unconditional_jump;
        -:12417:
        -:12418:
        -:12419:        /* Normally, the on_failure_jump pushes a failure point, which
        -:12420:           then gets popped at pop_failure_jump.  We will end up at
        -:12421:           pop_failure_jump, also, and with a pattern of, say, `a+', we
        -:12422:           are skipping over the on_failure_jump, so we have to push
        -:12423:           something meaningless for pop_failure_jump to pop.  */
    #####:12424:        case dummy_failure_jump:
        -:12425:          DEBUG_PRINT1 ("EXECUTING dummy_failure_jump.\n");
        -:12426:          /* It doesn't matter what we push for the string here.  What
        -:12427:             the code at `fail' tests is the value for the pattern.  */
    #####:12428:          PUSH_FAILURE_POINT (NULL, NULL, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:12429:          goto unconditional_jump;
        -:12430:
        -:12431:
        -:12432:        /* At the end of an alternative, we need to push a dummy failure
        -:12433:           point in case we are followed by a `pop_failure_jump', because
        -:12434:           we don't want the failure point for the alternative to be
        -:12435:           popped.  For example, matching `(a|ab)*' against `aab'
        -:12436:           requires that we match the `ab' alternative.  */
    #####:12437:        case push_dummy_failure:
        -:12438:          DEBUG_PRINT1 ("EXECUTING push_dummy_failure.\n");
        -:12439:          /* See comments just above at `dummy_failure_jump' about the
        -:12440:             two zeroes.  */
    #####:12441:          PUSH_FAILURE_POINT (NULL, NULL, -2);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
    #####:12442:          break;
        -:12443:
        -:12444:        /* Have to succeed matching what follows at least n times.
        -:12445:           After that, handle like `on_failure_jump'.  */
    #####:12446:        case succeed_n:
    #####:12447:          EXTRACT_NUMBER (mcnt, p + 2);
        -:12448:          DEBUG_PRINT2 ("EXECUTING succeed_n %d.\n", mcnt);
        -:12449:
        -:12450:          assert (mcnt >= 0);
        -:12451:          /* Originally, this is how many times we HAVE to succeed.  */
    #####:12452:          if (mcnt > 0)
branch  0 never executed
branch  1 never executed
        -:12453:            {
    #####:12454:               mcnt--;
    #####:12455:	       p += 2;
    #####:12456:               STORE_NUMBER_AND_INCR (p, mcnt);
        -:12457:#ifdef _LIBC
        -:12458:               DEBUG_PRINT3 ("  Setting %p to %d.\n", p - 2, mcnt);
        -:12459:#else
        -:12460:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p - 2, mcnt);
        -:12461:#endif
        -:12462:            }
    #####:12463:	  else if (mcnt == 0)
branch  0 never executed
branch  1 never executed
        -:12464:            {
        -:12465:#ifdef _LIBC
        -:12466:              DEBUG_PRINT2 ("  Setting two bytes from %p to no_op.\n", p+2);
        -:12467:#else
        -:12468:              DEBUG_PRINT2 ("  Setting two bytes from 0x%x to no_op.\n", p+2);
        -:12469:#endif
    #####:12470:	      p[2] = (unsigned char) no_op;
    #####:12471:              p[3] = (unsigned char) no_op;
    #####:12472:              goto on_failure;
        -:12473:            }
    #####:12474:          break;
        -:12475:
    #####:12476:        case jump_n:
    #####:12477:          EXTRACT_NUMBER (mcnt, p + 2);
        -:12478:          DEBUG_PRINT2 ("EXECUTING jump_n %d.\n", mcnt);
        -:12479:
        -:12480:          /* Originally, this is how many times we CAN jump.  */
    #####:12481:          if (mcnt)
branch  0 never executed
branch  1 never executed
        -:12482:            {
    #####:12483:               mcnt--;
    #####:12484:               STORE_NUMBER (p + 2, mcnt);
        -:12485:#ifdef _LIBC
        -:12486:               DEBUG_PRINT3 ("  Setting %p to %d.\n", p + 2, mcnt);
        -:12487:#else
        -:12488:               DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p + 2, mcnt);
        -:12489:#endif
    #####:12490:	       goto unconditional_jump;
        -:12491:            }
        -:12492:          /* If don't have to jump any more, skip over the rest of command.  */
        -:12493:	  else
    #####:12494:	    p += 4;
    #####:12495:          break;
        -:12496:
    #####:12497:	case set_number_at:
        -:12498:	  {
        -:12499:            DEBUG_PRINT1 ("EXECUTING set_number_at.\n");
        -:12500:
    #####:12501:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
    #####:12502:            p1 = p + mcnt;
    #####:12503:            EXTRACT_NUMBER_AND_INCR (mcnt, p);
        -:12504:#ifdef _LIBC
        -:12505:            DEBUG_PRINT3 ("  Setting %p to %d.\n", p1, mcnt);
        -:12506:#else
        -:12507:            DEBUG_PRINT3 ("  Setting 0x%x to %d.\n", p1, mcnt);
        -:12508:#endif
    #####:12509:	    STORE_NUMBER (p1, mcnt);
    #####:12510:            break;
        -:12511:          }
        -:12512:
        -:12513:#if 0
        -:12514:	/* The DEC Alpha C compiler 3.x generates incorrect code for the
        -:12515:	   test  WORDCHAR_P (d - 1) != WORDCHAR_P (d)  in the expansion of
        -:12516:	   AT_WORD_BOUNDARY, so this code is disabled.  Expanding the
        -:12517:	   macro and introducing temporary variables works around the bug.  */
        -:12518:
        -:12519:	case wordbound:
        -:12520:	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
        -:12521:	  if (AT_WORD_BOUNDARY (d))
        -:12522:	    break;
        -:12523:	  goto fail;
        -:12524:
        -:12525:	case notwordbound:
        -:12526:	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
        -:12527:	  if (AT_WORD_BOUNDARY (d))
        -:12528:	    goto fail;
        -:12529:	  break;
        -:12530:#else
    #####:12531:	case wordbound:
        -:12532:	{
        -:12533:	  boolean prevchar, thischar;
        -:12534:
        -:12535:	  DEBUG_PRINT1 ("EXECUTING wordbound.\n");
    #####:12536:	  if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:12537:	    break;
        -:12538:
    #####:12539:	  prevchar = WORDCHAR_P (d - 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12540:	  thischar = WORDCHAR_P (d);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12541:	  if (prevchar != thischar)
branch  0 never executed
branch  1 never executed
    #####:12542:	    break;
    #####:12543:	  goto fail;
        -:12544:	}
        -:12545:
    #####:12546:      case notwordbound:
        -:12547:	{
        -:12548:	  boolean prevchar, thischar;
        -:12549:
        -:12550:	  DEBUG_PRINT1 ("EXECUTING notwordbound.\n");
    #####:12551:	  if (AT_STRINGS_BEG (d) || AT_STRINGS_END (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
    #####:12552:	    goto fail;
        -:12553:
    #####:12554:	  prevchar = WORDCHAR_P (d - 1);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12555:	  thischar = WORDCHAR_P (d);
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12556:	  if (prevchar != thischar)
branch  0 never executed
branch  1 never executed
    #####:12557:	    goto fail;
    #####:12558:	  break;
        -:12559:	}
        -:12560:#endif
        -:12561:
    #####:12562:	case wordbeg:
        -:12563:          DEBUG_PRINT1 ("EXECUTING wordbeg.\n");
    #####:12564:	  if (WORDCHAR_P (d) && (AT_STRINGS_BEG (d) || !WORDCHAR_P (d - 1)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
branch 12 never executed
branch 13 never executed
branch 14 never executed
branch 15 never executed
branch 16 never executed
branch 17 never executed
        -:12565:	    break;
    #####:12566:          goto fail;
        -:12567:
    #####:12568:	case wordend:
        -:12569:          DEBUG_PRINT1 ("EXECUTING wordend.\n");
    #####:12570:	  if (!AT_STRINGS_BEG (d) && WORDCHAR_P (d - 1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
branch  8 never executed
branch  9 never executed
branch 10 never executed
branch 11 never executed
    #####:12571:              && (!WORDCHAR_P (d) || AT_STRINGS_END (d)))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
branch  7 never executed
        -:12572:	    break;
    #####:12573:          goto fail;
        -:12574:
        -:12575:#ifdef emacs
        -:12576:  	case before_dot:
        -:12577:          DEBUG_PRINT1 ("EXECUTING before_dot.\n");
        -:12578: 	  if (PTR_CHAR_POS ((unsigned char *) d) >= point)
        -:12579:  	    goto fail;
        -:12580:  	  break;
        -:12581:
        -:12582:  	case at_dot:
        -:12583:          DEBUG_PRINT1 ("EXECUTING at_dot.\n");
        -:12584: 	  if (PTR_CHAR_POS ((unsigned char *) d) != point)
        -:12585:  	    goto fail;
        -:12586:  	  break;
        -:12587:
        -:12588:  	case after_dot:
        -:12589:          DEBUG_PRINT1 ("EXECUTING after_dot.\n");
        -:12590:          if (PTR_CHAR_POS ((unsigned char *) d) <= point)
        -:12591:  	    goto fail;
        -:12592:  	  break;
        -:12593:
        -:12594:	case syntaxspec:
        -:12595:          DEBUG_PRINT2 ("EXECUTING syntaxspec %d.\n", mcnt);
        -:12596:	  mcnt = *p++;
        -:12597:	  goto matchsyntax;
        -:12598:
        -:12599:        case wordchar:
        -:12600:          DEBUG_PRINT1 ("EXECUTING Emacs wordchar.\n");
        -:12601:	  mcnt = (int) Sword;
        -:12602:        matchsyntax:
        -:12603:	  PREFETCH ();
        -:12604:	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
        -:12605:	  d++;
        -:12606:	  if (SYNTAX (d[-1]) != (enum syntaxcode) mcnt)
        -:12607:	    goto fail;
        -:12608:          SET_REGS_MATCHED ();
        -:12609:	  break;
        -:12610:
        -:12611:	case notsyntaxspec:
        -:12612:          DEBUG_PRINT2 ("EXECUTING notsyntaxspec %d.\n", mcnt);
        -:12613:	  mcnt = *p++;
        -:12614:	  goto matchnotsyntax;
        -:12615:
        -:12616:        case notwordchar:
        -:12617:          DEBUG_PRINT1 ("EXECUTING Emacs notwordchar.\n");
        -:12618:	  mcnt = (int) Sword;
        -:12619:        matchnotsyntax:
        -:12620:	  PREFETCH ();
        -:12621:	  /* Can't use *d++ here; SYNTAX may be an unsafe macro.  */
        -:12622:	  d++;
        -:12623:	  if (SYNTAX (d[-1]) == (enum syntaxcode) mcnt)
        -:12624:	    goto fail;
        -:12625:	  SET_REGS_MATCHED ();
        -:12626:          break;
        -:12627:
        -:12628:#else /* not emacs */
    #####:12629:	case wordchar:
        -:12630:          DEBUG_PRINT1 ("EXECUTING non-Emacs wordchar.\n");
    #####:12631:	  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12632:          if (!WORDCHAR_P (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:12633:            goto fail;
    #####:12634:	  SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12635:          d++;
    #####:12636:	  break;
        -:12637:
    #####:12638:	case notwordchar:
        -:12639:          DEBUG_PRINT1 ("EXECUTING non-Emacs notwordchar.\n");
    #####:12640:	  PREFETCH ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12641:	  if (WORDCHAR_P (d))
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
    #####:12642:            goto fail;
    #####:12643:          SET_REGS_MATCHED ();
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12644:          d++;
    #####:12645:	  break;
        -:12646:#endif /* not emacs */
        -:12647:
    #####:12648:        default:
    #####:12649:          abort ();
call    0 never executed
        -:12650:	}
    #####:12651:      continue;  /* Successfully executed one pattern command; keep going.  */
        -:12652:
        -:12653:
        -:12654:    /* We goto here if a matching operation fails. */
    #####:12655:    fail:
    #####:12656:      if (!FAIL_STACK_EMPTY ())
branch  0 never executed
branch  1 never executed
        -:12657:	{ /* A restart point is known.  Restore to that state.  */
        -:12658:          DEBUG_PRINT1 ("\nFAIL:\n");
    #####:12659:          POP_FAILURE_POINT (d, p,
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:12660:                             lowest_active_reg, highest_active_reg,
        -:12661:                             regstart, regend, reg_info);
        -:12662:
        -:12663:          /* If this failure point is a dummy, try the next one.  */
    #####:12664:          if (!p)
branch  0 never executed
branch  1 never executed
    #####:12665:	    goto fail;
        -:12666:
        -:12667:          /* If we failed to the end of the pattern, don't examine *p.  */
        -:12668:	  assert (p <= pend);
    #####:12669:          if (p < pend)
branch  0 never executed
branch  1 never executed
        -:12670:            {
    #####:12671:              boolean is_a_jump_n = false;
        -:12672:
        -:12673:              /* If failed to a backwards jump that's part of a repetition
        -:12674:                 loop, need to pop this failure point and use the next one.  */
    #####:12675:              switch ((re_opcode_t) *p)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:12676:                {
    #####:12677:                case jump_n:
    #####:12678:                  is_a_jump_n = true;
    #####:12679:                case maybe_pop_jump:
        -:12680:                case pop_failure_jump:
        -:12681:                case jump:
    #####:12682:                  p1 = p + 1;
    #####:12683:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12684:                  p1 += mcnt;
        -:12685:
    #####:12686:                  if ((is_a_jump_n && (re_opcode_t) *p1 == succeed_n)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12687:                      || (!is_a_jump_n
branch  0 never executed
branch  1 never executed
    #####:12688:                          && (re_opcode_t) *p1 == on_failure_jump))
branch  0 never executed
branch  1 never executed
    #####:12689:                    goto fail;
    #####:12690:                  break;
    #####:12691:                default:
        -:12692:                  /* do nothing */ ;
        -:12693:                }
        -:12694:            }
        -:12695:
    #####:12696:          if (d >= string1 && d <= end1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
    #####:12697:	    dend = end_match_1;
        -:12698:        }
        -:12699:      else
    #####:12700:        break;   /* Matching at this starting point really fails.  */
        -:12701:    } /* for (;;) */
        -:12702:
    #####:12703:  if (best_regs_set)
branch  0 never executed
branch  1 never executed
    #####:12704:    goto restore_best_regs;
        -:12705:
    #####:12706:  FREE_VARIABLES ();
        -:12707:
    #####:12708:  return -1;         			/* Failure to match.  */
        -:12709:} /* re_match_2 */
        -:12710:
        -:12711:/* Subroutine definitions for re_match_2.  */
        -:12712:
        -:12713:
        -:12714:/* We are passed P pointing to a register number after a start_memory.
        -:12715:
        -:12716:   Return true if the pattern up to the corresponding stop_memory can
        -:12717:   match the empty string, and false otherwise.
        -:12718:
        -:12719:   If we find the matching stop_memory, sets P to point to one past its number.
        -:12720:   Otherwise, sets P to an undefined byte less than or equal to END.
        -:12721:
        -:12722:   We don't handle duplicates properly (yet).  */
        -:12723:
        -:12724:static boolean
function group_match_null_string_p called 0 returned 0% blocks executed 0%
    #####:12725:group_match_null_string_p (p, end, reg_info)
        -:12726:    unsigned char **p, *end;
        -:12727:    register_info_type *reg_info;
        -:12728:{
        -:12729:  int mcnt;
        -:12730:  /* Point to after the args to the start_memory.  */
    #####:12731:  unsigned char *p1 = *p + 2;
        -:12732:
    #####:12733:  while (p1 < end)
branch  0 never executed
branch  1 never executed
        -:12734:    {
        -:12735:      /* Skip over opcodes that can match nothing, and return true or
        -:12736:	 false, as appropriate, when we get to one that can't, or to the
        -:12737:         matching stop_memory.  */
        -:12738:
    #####:12739:      switch ((re_opcode_t) *p1)
branch  0 never executed
branch  1 never executed
branch  2 never executed
        -:12740:        {
        -:12741:        /* Could be either a loop or a series of alternatives.  */
    #####:12742:        case on_failure_jump:
    #####:12743:          p1++;
    #####:12744:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -:12745:
        -:12746:          /* If the next operation is not a jump backwards in the
        -:12747:	     pattern.  */
        -:12748:
    #####:12749:	  if (mcnt >= 0)
branch  0 never executed
branch  1 never executed
        -:12750:	    {
        -:12751:              /* Go through the on_failure_jumps of the alternatives,
        -:12752:                 seeing if any of the alternatives cannot match nothing.
        -:12753:                 The last alternative starts with only a jump,
        -:12754:                 whereas the rest start with on_failure_jump and end
        -:12755:                 with a jump, e.g., here is the pattern for `a|b|c':
        -:12756:
        -:12757:                 /on_failure_jump/0/6/exactn/1/a/jump_past_alt/0/6
        -:12758:                 /on_failure_jump/0/6/exactn/1/b/jump_past_alt/0/3
        -:12759:                 /exactn/1/c
        -:12760:
        -:12761:                 So, we have to first go through the first (n-1)
        -:12762:                 alternatives and then deal with the last one separately.  */
        -:12763:
        -:12764:
        -:12765:              /* Deal with the first (n-1) alternatives, which start
        -:12766:                 with an on_failure_jump (see above) that jumps to right
        -:12767:                 past a jump_past_alt.  */
        -:12768:
    #####:12769:              while ((re_opcode_t) p1[mcnt-3] == jump_past_alt)
branch  0 never executed
branch  1 never executed
        -:12770:                {
        -:12771:                  /* `mcnt' holds how many bytes long the alternative
        -:12772:                     is, including the ending `jump_past_alt' and
        -:12773:                     its number.  */
        -:12774:
    #####:12775:                  if (!alt_match_null_string_p (p1, p1 + mcnt - 3,
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:12776:				                      reg_info))
    #####:12777:                    return false;
        -:12778:
        -:12779:                  /* Move to right after this alternative, including the
        -:12780:		     jump_past_alt.  */
    #####:12781:                  p1 += mcnt;
        -:12782:
        -:12783:                  /* Break if it's the beginning of an n-th alternative
        -:12784:                     that doesn't begin with an on_failure_jump.  */
    #####:12785:                  if ((re_opcode_t) *p1 != on_failure_jump)
branch  0 never executed
branch  1 never executed
    #####:12786:                    break;
        -:12787:
        -:12788:		  /* Still have to check that it's not an n-th
        -:12789:		     alternative that starts with an on_failure_jump.  */
    #####:12790:		  p1++;
    #####:12791:                  EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12792:                  if ((re_opcode_t) p1[mcnt-3] != jump_past_alt)
branch  0 never executed
branch  1 never executed
        -:12793:                    {
        -:12794:		      /* Get to the beginning of the n-th alternative.  */
    #####:12795:                      p1 -= 3;
    #####:12796:                      break;
        -:12797:                    }
        -:12798:                }
        -:12799:
        -:12800:              /* Deal with the last alternative: go back and get number
        -:12801:                 of the `jump_past_alt' just before it.  `mcnt' contains
        -:12802:                 the length of the alternative.  */
    #####:12803:              EXTRACT_NUMBER (mcnt, p1 - 2);
        -:12804:
    #####:12805:              if (!alt_match_null_string_p (p1, p1 + mcnt, reg_info))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12806:                return false;
        -:12807:
    #####:12808:              p1 += mcnt;	/* Get past the n-th alternative.  */
        -:12809:            } /* if mcnt > 0 */
    #####:12810:          break;
        -:12811:
        -:12812:
    #####:12813:        case stop_memory:
        -:12814:	  assert (p1[1] == **p);
    #####:12815:          *p = p1 + 2;
    #####:12816:          return true;
        -:12817:
        -:12818:
    #####:12819:        default:
    #####:12820:          if (!common_op_match_null_string_p (&p1, end, reg_info))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12821:            return false;
        -:12822:        }
        -:12823:    } /* while p1 < end */
        -:12824:
    #####:12825:  return false;
        -:12826:} /* group_match_null_string_p */
        -:12827:
        -:12828:
        -:12829:/* Similar to group_match_null_string_p, but doesn't deal with alternatives:
        -:12830:   It expects P to be the first byte of a single alternative and END one
        -:12831:   byte past the last. The alternative can contain groups.  */
        -:12832:
        -:12833:static boolean
function alt_match_null_string_p called 0 returned 0% blocks executed 0%
    #####:12834:alt_match_null_string_p (p, end, reg_info)
        -:12835:    unsigned char *p, *end;
        -:12836:    register_info_type *reg_info;
        -:12837:{
        -:12838:  int mcnt;
    #####:12839:  unsigned char *p1 = p;
        -:12840:
    #####:12841:  while (p1 < end)
branch  0 never executed
branch  1 never executed
        -:12842:    {
        -:12843:      /* Skip over opcodes that can match nothing, and break when we get
        -:12844:         to one that can't.  */
        -:12845:
    #####:12846:      switch ((re_opcode_t) *p1)
branch  0 never executed
branch  1 never executed
        -:12847:        {
        -:12848:	/* It's a loop.  */
    #####:12849:        case on_failure_jump:
    #####:12850:          p1++;
    #####:12851:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12852:          p1 += mcnt;
    #####:12853:          break;
        -:12854:
    #####:12855:	default:
    #####:12856:          if (!common_op_match_null_string_p (&p1, end, reg_info))
call    0 never executed
branch  1 never executed
branch  2 never executed
    #####:12857:            return false;
        -:12858:        }
        -:12859:    }  /* while p1 < end */
        -:12860:
    #####:12861:  return true;
        -:12862:} /* alt_match_null_string_p */
        -:12863:
        -:12864:
        -:12865:/* Deals with the ops common to group_match_null_string_p and
        -:12866:   alt_match_null_string_p.
        -:12867:
        -:12868:   Sets P to one after the op and its arguments, if any.  */
        -:12869:
        -:12870:static boolean
function common_op_match_null_string_p called 0 returned 0% blocks executed 0%
    #####:12871:common_op_match_null_string_p (p, end, reg_info)
        -:12872:    unsigned char **p, *end;
        -:12873:    register_info_type *reg_info;
        -:12874:{
        -:12875:  int mcnt;
        -:12876:  boolean ret;
        -:12877:  int reg_no;
    #####:12878:  unsigned char *p1 = *p;
        -:12879:
    #####:12880:  switch ((re_opcode_t) *p1++)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
branch  4 never executed
branch  5 never executed
branch  6 never executed
        -:12881:    {
    #####:12882:    case no_op:
        -:12883:    case begline:
        -:12884:    case endline:
        -:12885:    case begbuf:
        -:12886:    case endbuf:
        -:12887:    case wordbeg:
        -:12888:    case wordend:
        -:12889:    case wordbound:
        -:12890:    case notwordbound:
        -:12891:#ifdef emacs
        -:12892:    case before_dot:
        -:12893:    case at_dot:
        -:12894:    case after_dot:
        -:12895:#endif
    #####:12896:      break;
        -:12897:
    #####:12898:    case start_memory:
    #####:12899:      reg_no = *p1;
        -:12900:      assert (reg_no > 0 && reg_no <= MAX_REGNUM);
    #####:12901:      ret = group_match_null_string_p (&p1, end, reg_info);
call    0 never executed
        -:12902:
        -:12903:      /* Have to set this here in case we're checking a group which
        -:12904:         contains a group and a back reference to it.  */
        -:12905:
    #####:12906:      if (REG_MATCH_NULL_STRING_P (reg_info[reg_no]) == MATCH_NULL_UNSET_VALUE)
branch  0 never executed
branch  1 never executed
    #####:12907:        REG_MATCH_NULL_STRING_P (reg_info[reg_no]) = ret;
        -:12908:
    #####:12909:      if (!ret)
branch  0 never executed
branch  1 never executed
    #####:12910:        return false;
    #####:12911:      break;
        -:12912:
        -:12913:    /* If this is an optimized succeed_n for zero times, make the jump.  */
    #####:12914:    case jump:
    #####:12915:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12916:      if (mcnt >= 0)
branch  0 never executed
branch  1 never executed
    #####:12917:        p1 += mcnt;
        -:12918:      else
    #####:12919:        return false;
    #####:12920:      break;
        -:12921:
    #####:12922:    case succeed_n:
        -:12923:      /* Get to the number of times to succeed.  */
    #####:12924:      p1 += 2;
    #####:12925:      EXTRACT_NUMBER_AND_INCR (mcnt, p1);
        -:12926:
    #####:12927:      if (mcnt == 0)
branch  0 never executed
branch  1 never executed
        -:12928:        {
    #####:12929:          p1 -= 4;
    #####:12930:          EXTRACT_NUMBER_AND_INCR (mcnt, p1);
    #####:12931:          p1 += mcnt;
        -:12932:        }
        -:12933:      else
    #####:12934:        return false;
    #####:12935:      break;
        -:12936:
    #####:12937:    case duplicate:
    #####:12938:      if (!REG_MATCH_NULL_STRING_P (reg_info[*p1]))
branch  0 never executed
branch  1 never executed
    #####:12939:        return false;
    #####:12940:      break;
        -:12941:
    #####:12942:    case set_number_at:
    #####:12943:      p1 += 4;
        -:12944:
    #####:12945:    default:
        -:12946:      /* All other opcodes mean we cannot match the empty string.  */
    #####:12947:      return false;
        -:12948:  }
        -:12949:
    #####:12950:  *p = p1;
    #####:12951:  return true;
        -:12952:} /* common_op_match_null_string_p */
        -:12953:
        -:12954:
        -:12955:/* Return zero if TRANSLATE[S1] and TRANSLATE[S2] are identical for LEN
        -:12956:   bytes; nonzero otherwise.  */
        -:12957:
        -:12958:static int
function bcmp_translate called 0 returned 0% blocks executed 0%
    #####:12959:bcmp_translate (s1, s2, len, translate)
        -:12960:     const char *s1, *s2;
        -:12961:     register int len;
        -:12962:     RE_TRANSLATE_TYPE translate;
        -:12963:{
    #####:12964:  register const unsigned char *p1 = (const unsigned char *) s1;
    #####:12965:  register const unsigned char *p2 = (const unsigned char *) s2;
    #####:12966:  while (len)
branch  0 never executed
branch  1 never executed
        -:12967:    {
    #####:12968:      if (translate[*p1++] != translate[*p2++]) return 1;
branch  0 never executed
branch  1 never executed
    #####:12969:      len--;
        -:12970:    }
    #####:12971:  return 0;
        -:12972:}
        -:12973:
        -:12974:/* Entry points for GNU code.  */
        -:12975:
        -:12976:/* re_compile_pattern is the GNU regular expression compiler: it
        -:12977:   compiles PATTERN (of length SIZE) and puts the result in BUFP.
        -:12978:   Returns 0 if the pattern was valid, otherwise an error string.
        -:12979:
        -:12980:   Assumes the `allocated' (and perhaps `buffer') and `translate' fields
        -:12981:   are set in BUFP on entry.
        -:12982:
        -:12983:   We call regex_compile to do the actual compilation.  */
        -:12984:
        -:12985:const char *
function re_compile_pattern called 781 returned 100% blocks executed 100%
      781:12986:re_compile_pattern (pattern, length, bufp)
        -:12987:     const char *pattern;
        -:12988:     size_t length;
        -:12989:     struct re_pattern_buffer *bufp;
        -:12990:{
        -:12991:  reg_errcode_t ret;
        -:12992:
        -:12993:  /* GNU code is written to assume at least RE_NREGS registers will be set
        -:12994:     (and at least one extra will be -1).  */
      781:12995:  bufp->regs_allocated = REGS_UNALLOCATED;
        -:12996:
        -:12997:  /* And GNU code determines whether or not to get register information
        -:12998:     by passing null for the REGS argument to re_match, etc., not by
        -:12999:     setting no_sub.  */
      781:13000:  bufp->no_sub = 0;
        -:13001:
        -:13002:  /* Match anchors at newline.  */
      781:13003:  bufp->newline_anchor = 1;
        -:13004:
      781:13005:  ret = regex_compile (pattern, length, re_syntax_options, bufp);
call    0 returned 781
        -:13006:
      781:13007:  if (!ret)
branch  0 taken 722 (fallthrough)
branch  1 taken 59
      722:13008:    return NULL;
        -:13009:#ifndef FAULTY_F_KP_6
       59:13010:  return gettext (re_error_msgid + re_error_msgid_idx[(int) ret]);
        -:13011:#else
        -:13012:  return gettext (re_error_msgid - re_error_msgid_idx[(int) ret]);
        -:13013:#endif
        -:13014:}
        -:13015:#ifdef _LIBC
        -:13016:weak_alias (__re_compile_pattern, re_compile_pattern)
        -:13017:#endif
        -:13018:
        -:13019:/* Entry points compatible with 4.2 BSD regex library.  We don't define
        -:13020:   them unless specifically requested.  */
        -:13021:
        -:13022:#if defined _REGEX_RE_COMP || defined _LIBC
        -:13023:
        -:13024:/* BSD has one and only one pattern buffer.  */
        -:13025:static struct re_pattern_buffer re_comp_buf;
        -:13026:
        -:13027:char *
        -:13028:#ifdef _LIBC
        -:13029:/* Make these definitions weak in libc, so POSIX programs can redefine
        -:13030:   these names if they don't use our functions, and still use
        -:13031:   regcomp/regexec below without link errors.  */
        -:13032:weak_function
        -:13033:#endif
        -:13034:re_comp (s)
        -:13035:    const char *s;
        -:13036:{
        -:13037:  reg_errcode_t ret;
        -:13038:
        -:13039:  if (!s)
        -:13040:    {
        -:13041:      if (!re_comp_buf.buffer)
        -:13042:	return gettext ("No previous regular expression");
        -:13043:      return 0;
        -:13044:    }
        -:13045:
        -:13046:  if (!re_comp_buf.buffer)
        -:13047:    {
        -:13048:      re_comp_buf.buffer = (unsigned char *) malloc (200);
        -:13049:      if (re_comp_buf.buffer == NULL)
        -:13050:        return (char *) gettext (re_error_msgid
        -:13051:				 + re_error_msgid_idx[(int) REG_ESPACE]);
        -:13052:      re_comp_buf.allocated = 200;
        -:13053:
        -:13054:      re_comp_buf.fastmap = (char *) malloc (1 << BYTEWIDTH);
        -:13055:      if (re_comp_buf.fastmap == NULL)
        -:13056:	return (char *) gettext (re_error_msgid
        -:13057:				 + re_error_msgid_idx[(int) REG_ESPACE]);
        -:13058:    }
        -:13059:
        -:13060:  /* Since `re_exec' always passes NULL for the `regs' argument, we
        -:13061:     don't need to initialize the pattern buffer fields which affect it.  */
        -:13062:
        -:13063:  /* Match anchors at newlines.  */
        -:13064:  re_comp_buf.newline_anchor = 1;
        -:13065:
        -:13066:  ret = regex_compile (s, strlen (s), re_syntax_options, &re_comp_buf);
        -:13067:
        -:13068:  if (!ret)
        -:13069:    return NULL;
        -:13070:
        -:13071:  /* Yes, we're discarding `const' here if !HAVE_LIBINTL.  */
        -:13072:  return (char *) gettext (re_error_msgid + re_error_msgid_idx[(int) ret]);
        -:13073:}
        -:13074:
        -:13075:
        -:13076:int
        -:13077:#ifdef _LIBC
        -:13078:weak_function
        -:13079:#endif
        -:13080:re_exec (s)
        -:13081:    const char *s;
        -:13082:{
        -:13083:  const int len = strlen (s);
        -:13084:  return
        -:13085:    0 <= re_search (&re_comp_buf, s, len, 0, len, (struct re_registers *) 0);
        -:13086:}
        -:13087:
        -:13088:#endif /* _REGEX_RE_COMP */
        -:13089:
        -:13090:/* POSIX.2 functions.  Don't define these for Emacs.  */
        -:13091:
        -:13092:#ifndef emacs
        -:13093:
        -:13094:/* regcomp takes a regular expression as a string and compiles it.
        -:13095:
        -:13096:   PREG is a regex_t *.  We do not expect any fields to be initialized,
        -:13097:   since POSIX says we shouldn't.  Thus, we set
        -:13098:
        -:13099:     `buffer' to the compiled pattern;
        -:13100:     `used' to the length of the compiled pattern;
        -:13101:     `syntax' to RE_SYNTAX_POSIX_EXTENDED if the
        -:13102:       REG_EXTENDED bit in CFLAGS is set; otherwise, to
        -:13103:       RE_SYNTAX_POSIX_BASIC;
        -:13104:     `newline_anchor' to REG_NEWLINE being set in CFLAGS;
        -:13105:     `fastmap' to an allocated space for the fastmap;
        -:13106:     `fastmap_accurate' to zero;
        -:13107:     `re_nsub' to the number of subexpressions in PATTERN.
        -:13108:
        -:13109:   PATTERN is the address of the pattern string.
        -:13110:
        -:13111:   CFLAGS is a series of bits which affect compilation.
        -:13112:
        -:13113:     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we
        -:13114:     use POSIX basic syntax.
        -:13115:
        -:13116:     If REG_NEWLINE is set, then . and [^...] don't match newline.
        -:13117:     Also, regexec will try a match beginning after every newline.
        -:13118:
        -:13119:     If REG_ICASE is set, then we considers upper- and lowercase
        -:13120:     versions of letters to be equivalent when matching.
        -:13121:
        -:13122:     If REG_NOSUB is set, then when PREG is passed to regexec, that
        -:13123:     routine will report only success or failure, and nothing about the
        -:13124:     registers.
        -:13125:
        -:13126:   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for
        -:13127:   the return codes and their meanings.)  */
        -:13128:
        -:13129:int
function regcomp called 0 returned 0% blocks executed 0%
    #####:13130:regcomp (preg, pattern, cflags)
        -:13131:    regex_t *preg;
        -:13132:    const char *pattern;
        -:13133:    int cflags;
        -:13134:{
        -:13135:  reg_errcode_t ret;
    #####:13136:  reg_syntax_t syntax
    #####:13137:    = (cflags & REG_EXTENDED) ?
    #####:13138:      RE_SYNTAX_POSIX_EXTENDED : RE_SYNTAX_POSIX_BASIC;
branch  0 never executed
branch  1 never executed
        -:13139:
        -:13140:  /* regex_compile will allocate the space for the compiled pattern.  */
    #####:13141:  preg->buffer = 0;
    #####:13142:  preg->allocated = 0;
    #####:13143:  preg->used = 0;
        -:13144:
        -:13145:  /* Try to allocate space for the fastmap.  */
    #####:13146:  preg->fastmap = (char *) malloc (1 << BYTEWIDTH);
call    0 never executed
        -:13147:
    #####:13148:  if (cflags & REG_ICASE)
branch  0 never executed
branch  1 never executed
        -:13149:    {
        -:13150:      unsigned i;
        -:13151:
        -:13152:      preg->translate
    #####:13153:	= (RE_TRANSLATE_TYPE) malloc (CHAR_SET_SIZE
call    0 never executed
        -:13154:				      * sizeof (*(RE_TRANSLATE_TYPE)0));
    #####:13155:      if (preg->translate == NULL)
branch  0 never executed
branch  1 never executed
    #####:13156:        return (int) REG_ESPACE;
        -:13157:
        -:13158:      /* Map uppercase characters to corresponding lowercase ones.  */
    #####:13159:      for (i = 0; i < CHAR_SET_SIZE; i++)
branch  0 never executed
branch  1 never executed
    #####:13160:        preg->translate[i] = ISUPPER (i) ? TOLOWER (i) : i;
branch  0 never executed
branch  1 never executed
        -:13161:    }
        -:13162:  else
    #####:13163:    preg->translate = NULL;
        -:13164:
        -:13165:  /* If REG_NEWLINE is set, newlines are treated differently.  */
    #####:13166:  if (cflags & REG_NEWLINE)
branch  0 never executed
branch  1 never executed
        -:13167:    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */
    #####:13168:      syntax &= ~RE_DOT_NEWLINE;
    #####:13169:      syntax |= RE_HAT_LISTS_NOT_NEWLINE;
        -:13170:      /* It also changes the matching behavior.  */
    #####:13171:      preg->newline_anchor = 1;
        -:13172:    }
        -:13173:  else
    #####:13174:    preg->newline_anchor = 0;
        -:13175:
    #####:13176:  preg->no_sub = !!(cflags & REG_NOSUB);
        -:13177:
        -:13178:  /* POSIX says a null character in the pattern terminates it, so we
        -:13179:     can use strlen here in compiling the pattern.  */
    #####:13180:  ret = regex_compile (pattern, strlen (pattern), syntax, preg);
call    0 never executed
        -:13181:
        -:13182:  /* POSIX doesn't distinguish between an unmatched open-group and an
        -:13183:     unmatched close-group: both are REG_EPAREN.  */
    #####:13184:  if (ret == REG_ERPAREN) ret = REG_EPAREN;
branch  0 never executed
branch  1 never executed
        -:13185:
    #####:13186:  if (ret == REG_NOERROR && preg->fastmap)
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13187:    {
        -:13188:      /* Compute the fastmap now, since regexec cannot modify the pattern
        -:13189:	 buffer.  */
    #####:13190:      if (re_compile_fastmap (preg) == -2)
call    0 never executed
branch  1 never executed
branch  2 never executed
        -:13191:	{
        -:13192:	  /* Some error occured while computing the fastmap, just forget
        -:13193:	     about it.  */
    #####:13194:	  free (preg->fastmap);
    #####:13195:	  preg->fastmap = NULL;
        -:13196:	}
        -:13197:    }
        -:13198:
    #####:13199:  return (int) ret;
        -:13200:}
        -:13201:#ifdef _LIBC
        -:13202:weak_alias (__regcomp, regcomp)
        -:13203:#endif
        -:13204:
        -:13205:
        -:13206:/* regexec searches for a given pattern, specified by PREG, in the
        -:13207:   string STRING.
        -:13208:
        -:13209:   If NMATCH is zero or REG_NOSUB was set in the cflags argument to
        -:13210:   `regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at
        -:13211:   least NMATCH elements, and we set them to the offsets of the
        -:13212:   corresponding matched substrings.
        -:13213:
        -:13214:   EFLAGS specifies `execution flags' which affect matching: if
        -:13215:   REG_NOTBOL is set, then ^ does not match at the beginning of the
        -:13216:   string; if REG_NOTEOL is set, then $ does not match at the end.
        -:13217:
        -:13218:   We return 0 if we find a match and REG_NOMATCH if not.  */
        -:13219:
        -:13220:int
function regexec called 0 returned 0% blocks executed 0%
    #####:13221:regexec (preg, string, nmatch, pmatch, eflags)
        -:13222:    const regex_t *preg;
        -:13223:    const char *string;
        -:13224:    size_t nmatch;
        -:13225:    regmatch_t pmatch[];
        -:13226:    int eflags;
        -:13227:{
        -:13228:  int ret;
        -:13229:  struct re_registers regs;
        -:13230:  regex_t private_preg;
    #####:13231:  int len = strlen (string);
    #####:13232:  boolean want_reg_info = !preg->no_sub && nmatch > 0;
branch  0 never executed
branch  1 never executed
branch  2 never executed
branch  3 never executed
        -:13233:
    #####:13234:  private_preg = *preg;
        -:13235:
    #####:13236:  private_preg.not_bol = !!(eflags & REG_NOTBOL);
    #####:13237:  private_preg.not_eol = !!(eflags & REG_NOTEOL);
        -:13238:
        -:13239:  /* The user has told us exactly how many registers to return
        -:13240:     information about, via `nmatch'.  We have to pass that on to the
        -:13241:     matching routines.  */
    #####:13242:  private_preg.regs_allocated = REGS_FIXED;
        -:13243:
    #####:13244:  if (want_reg_info)
branch  0 never executed
branch  1 never executed
        -:13245:    {
    #####:13246:      regs.num_regs = nmatch;
    #####:13247:      regs.start = TALLOC (nmatch * 2, regoff_t);
call    0 never executed
    #####:13248:      if (regs.start == NULL)
branch  0 never executed
branch  1 never executed
    #####:13249:        return (int) REG_NOMATCH;
    #####:13250:      regs.end = regs.start + nmatch;
        -:13251:    }
        -:13252:
        -:13253:  /* Perform the searching operation.  */
    #####:13254:  ret = re_search (&private_preg, string, len,
branch  0 never executed
branch  1 never executed
call    2 never executed
        -:13255:                   /* start: */ 0, /* range: */ len,
        -:13256:                   want_reg_info ? &regs : (struct re_registers *) 0);
        -:13257:
        -:13258:  /* Copy the register information to the POSIX structure.  */
    #####:13259:  if (want_reg_info)
branch  0 never executed
branch  1 never executed
        -:13260:    {
    #####:13261:      if (ret >= 0)
branch  0 never executed
branch  1 never executed
        -:13262:        {
        -:13263:          unsigned r;
        -:13264:
    #####:13265:          for (r = 0; r < nmatch; r++)
branch  0 never executed
branch  1 never executed
        -:13266:            {
    #####:13267:              pmatch[r].rm_so = regs.start[r];
    #####:13268:              pmatch[r].rm_eo = regs.end[r];
        -:13269:            }
        -:13270:        }
        -:13271:
        -:13272:      /* If we needed the temporary register info, free the space now.  */
    #####:13273:      free (regs.start);
        -:13274:    }
        -:13275:
        -:13276:  /* We want zero return to mean success, unlike `re_search'.  */
    #####:13277:  return ret >= 0 ? (int) REG_NOERROR : (int) REG_NOMATCH;
        -:13278:}
        -:13279:#ifdef _LIBC
        -:13280:weak_alias (__regexec, regexec)
        -:13281:#endif
        -:13282:
        -:13283:
        -:13284:/* Returns a message corresponding to an error code, ERRCODE, returned
        -:13285:   from either regcomp or regexec.   We don't use PREG here.  */
        -:13286:
        -:13287:size_t
function regerror called 0 returned 0% blocks executed 0%
    #####:13288:regerror (errcode, preg, errbuf, errbuf_size)
        -:13289:    int errcode;
        -:13290:    const regex_t *preg;
        -:13291:    char *errbuf;
        -:13292:    size_t errbuf_size;
        -:13293:{
        -:13294:  const char *msg;
        -:13295:  size_t msg_size;
        -:13296:
    #####:13297:  if (errcode < 0
branch  0 never executed
branch  1 never executed
    #####:13298:      || errcode >= (int) (sizeof (re_error_msgid_idx)
branch  0 never executed
branch  1 never executed
        -:13299:			   / sizeof (re_error_msgid_idx[0])))
        -:13300:    /* Only error codes returned by the rest of the code should be passed
        -:13301:       to this routine.  If we are given anything else, or if other regex
        -:13302:       code generates an invalid error code, then the program has a bug.
        -:13303:       Dump core so we can fix it.  */
    #####:13304:    abort ();
call    0 never executed
        -:13305:
    #####:13306:  msg = gettext (re_error_msgid + re_error_msgid_idx[errcode]);
        -:13307:
    #####:13308:  msg_size = strlen (msg) + 1; /* Includes the null.  */
        -:13309:
    #####:13310:  if (errbuf_size != 0)
branch  0 never executed
branch  1 never executed
        -:13311:    {
    #####:13312:      if (msg_size > errbuf_size)
branch  0 never executed
branch  1 never executed
        -:13313:        {
        -:13314:#if defined HAVE_MEMPCPY || defined _LIBC
        -:13315:	  *((char *) __mempcpy (errbuf, msg, errbuf_size - 1)) = '\0';
        -:13316:#else
    #####:13317:          memcpy (errbuf, msg, errbuf_size - 1);
    #####:13318:          errbuf[errbuf_size - 1] = 0;
        -:13319:#endif
        -:13320:        }
        -:13321:      else
    #####:13322:        memcpy (errbuf, msg, msg_size);
        -:13323:    }
        -:13324:
    #####:13325:  return msg_size;
        -:13326:}
        -:13327:#ifdef _LIBC
        -:13328:weak_alias (__regerror, regerror)
        -:13329:#endif
        -:13330:
        -:13331:
        -:13332:/* Free dynamically allocated space used by PREG.  */
        -:13333:
        -:13334:void
function regfree called 0 returned 0% blocks executed 0%
    #####:13335:regfree (preg)
        -:13336:    regex_t *preg;
        -:13337:{
    #####:13338:  if (preg->buffer != NULL)
branch  0 never executed
branch  1 never executed
    #####:13339:    free (preg->buffer);
    #####:13340:  preg->buffer = NULL;
        -:13341:
    #####:13342:  preg->allocated = 0;
    #####:13343:  preg->used = 0;
        -:13344:
    #####:13345:  if (preg->fastmap != NULL)
branch  0 never executed
branch  1 never executed
    #####:13346:    free (preg->fastmap);
    #####:13347:  preg->fastmap = NULL;
    #####:13348:  preg->fastmap_accurate = 0;
        -:13349:
    #####:13350:  if (preg->translate != NULL)
branch  0 never executed
branch  1 never executed
    #####:13351:    free (preg->translate);
    #####:13352:  preg->translate = NULL;
    #####:13353:}
        -:13354:#ifdef _LIBC
        -:13355:weak_alias (__regfree, regfree)
        -:13356:#endif
        -:13357:
        -:13358:#endif /* not emacs  */
